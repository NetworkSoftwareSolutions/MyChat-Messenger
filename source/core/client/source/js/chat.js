;(function(factory) {
    var _cmd_ = {};

    if (typeof exports === 'object') {
        if (typeof require === 'function'){
            var ecmd = require('./ecmd').ECMD;
            // {"cmd": ["cmd.js"]},

            _cmd_ = factory();

            // if (ecmd) {
                Object.keys(ecmd).forEach(function (cmd) {
                    _cmd_[cmd] = ecmd[cmd];
                });
            // }

            exports.CMD = _cmd_;
        } else {
            exports.CMD = factory();
        }
    } else {
        _cmd_ = factory();

        if (window && window.mcConst && window.mcConst._CMD_){
            Object.keys(_cmd_).forEach(function (cmd) {
                window.mcConst._CMD_[cmd] = _cmd_[cmd];
            });
        }

        window.getCMD = function getCMD(){
            if (window.hasOwnProperty('_ECMD_')){
                Object.keys(window._ECMD_).forEach(function (cmd) {
                    _cmd_[cmd] = window._ECMD_[cmd];
                });
            }

            return _cmd_;
        }
    }
})(function() {
    "use strict";

    return {
        Login    : 'login',
        Register : 'register',
        Reminde  : 'reminde',
        OK       : 'OK',
        Ping     : 'ping',
        History  : 'history',
        NewFoto  : 'newfoto',
        Logs     : 'logs',
        StopLogs : 'stopLogs',
        Blocked  : 'blocked',
        cLog     : 'cLog',

        // =========================================

        sc_drop_connect: '9999',

        // Client CMD ==============================
        cs_hello                                : '0001', // команда-приветствие, отправляется от клиента при подключении к серверу. С этой команды начинается любое подключение к серверу.
        cs_login                                : '0003', // подключение к серверу под заданной учётной записью. Логин может происходить по одному из вариантов: UIN, ник или адрес электронной почты.
        cs_register_new_user                    : '0004', // зарегистрировать на сервере нового пользователя.
        cs_domain_login                         : '0005', // подключение к серверу с доменной авторизацией в Active Directory.
        cs_restore_account                      : '0006', // восстановление своей учётной записи
        cs_work_time_upload_old_data            : '0007', // отправка на сервер данных о рабочем времени клиента, пока тот был в офлайн (нужна доработка)
        cs_restore_connect_to_channels          : '0008', // восстановить вход в открытые каналы после отключения от сервера (нужна доработка)
        cs_get_bbs                              : "0009", // получить полный текст доски объявлений
        cs_get_adv_new_data                     : "000A", // запрос новых данных на рекламу
        cs_special_ping                         : "000B", // пинг сервера, проверка связи
        cs_ping                                 : "000B",// пинг от клиента, проверка, есть ли соединение. Если длительное время от клиентов не было пинга или любого другого запроса - соединение считается "мёртвым" и автоматически удаляется с сервера.
        cs_get_channels_list                    : "000D", // получить с сервера список созданных каналов
        cs_get_actions_list                     : "000E", // получить список ACTIONs, если они есть и к ним есть доступ
        cs_work_time_control_active_caption     : "000F", // отправка на сервер данных о рабочем времени, нужна доработка
        cs_get_small_user_info                  : "0010", // получить краткую информацию о пользователе
        cs_private_request                      : "0011", // запрос на открытие привата с указанным пользователем
        cs_get_hello_msg                        : "0012", // запрос содержимого приветствия канала
        cs_pong                                 : "0013", // ответ на серверную команду sc_ping
        cs_get_contacts_list                    : "0014", // получить список личных персональных контактов.
        cs_get_common_contacts_list             : "0015", // получить список общих контактов (древовидный список контактов, общий для всех пользователей сервера).
        cs_put_msg2txt_channel                  : "0016", // отправить сообщение в текстовый канал
        cs_private_msg                          : "0017", // отправить приватное сообшение другому пользователю
        cs_join_txt_channel                     : "0018", // подключиться к существующему текстовому каналу
        cs_leave_txt_channel                    : "0019", // выйти из текстового канала
        cs_add_new_bbs                          : "001A", // отправить новое сообщение на доску объявлений

        cs_create_txt_channel                   : "001D", // создать новый текстовый канал.
        cs_get_uin_info                         : "001E", // получить полную информацию об указанном пользователе
        cs_get_uin_foto                         : "001F", // получить фотографию пользователя
        cs_get_remote_uin_current_time          : "0020", // получить текущее системное время удалённого пользователя
        cs_send_my_current_time                 : "0021", // отправить свою текущую дату и время указанному пользователю
        cs_get_user_computer_info               : "0022", // получить IP/MAC адрес и название компьютера удалённого клиента
        cs_get_active_window_caption            : "0023", // получить заголовок активного окна пользователя
        cs_active_window_caption                : "0024", // отправка заголовка активного окна
        cs_get_ignores_list                     : "0025", // получить список игноров для указанного пользователя
        cs_update_ignores_list                  : "0026", // обновить персональный список игноров (доработать разбор списка)
        cs_get_favorite_channels                : "0027", // получить список "любимых" каналов
        cs_add_favorite_channel                 : "0028", // добавить канал с указаненым идентификатором в список "любимых"
        cs_delete_favorite_channel              : "0029", // удалить текстовый канал из списка "любимых"
        cs_get_msgtemplates                     : "002A", // получить список персональных "быстрых" сообщений
        cs_update_msgtemplates                  : "002B", // сохранить на сервере в своём аккаунте список "быстрых" сообщений
        cs_set_account_password                 : "002C", // установить новый пароль для своей учётной записи

        cs_add_personal_contact_group           : "001B", // добавить новую группу в персональную панель контактов
        cs_delete_id_from_personal_contacts     : "001C", // удалить группу контактов из личного списка контактов
        cs_add_new_contact                      : "002D", // добавить пользователя в личный список контактов
        cs_rename_contacts_group                : "002F", // переименовать личную группу контактов
        cs_move_personal_contact                : "0030", // перенести персональный контакт из одной группы в другую

        cs_open_remote_computer_shares          : "0031", // окрыть удалённый компьютер по сети Проводником (показать открытые ресурсы (shares))
        cs_forcibly_join_to_text_channel        : "0032", // принудительно включить выбранного пользователя в указанный текстовый канал
        cs_change_txtch_topic                   : "0033", // изменить тему текстового канала
        cs_get_public_ftp_info                  : "0034", // получить информацию с сервера о публичном доступе к общему FTP серверу
        cs_get_channel_history_messages         : "0035", // получить историю сообщений в указанном текстовом канале
        cs_rename_text_channel                  : "0036", // переименовать существующий текстовый канал
        cs_ignore_get                           : "0037", // добавить в игнор пользователя и / или получить информацию об его игнорировании
        cs_add_ignore                           : "0038", // добавить юзера в игнор-список (либо обновить данные)
        cs_clear_text_channel                   : "0039", // очистить выбранный текстовый канал от всех сообщений у всех находящихся в нём пользователей
        cs_personal_message2txtch               : "003A", // персональное/важное сообщение лично другому пользователю в текстовый канал
        cs_block_mac_by_uin                     : "003B", // заблокировать MAC адрес пользователя по его UIN
        cs_block_ip_by_uin                      : "003C", // заблокировать IP адрес пользователя по его UIN
        cs_kill_user                            : "003D", // отключить пользователя от сервера
        cs_kick_from_txt_channel                : "003E", // выгнать пользователя из текстового канала
        cs_private_beep                         : "003F", // отправить пользователю звуковой сигнал
        cs_get_server_uptime                    : "0040", // получить аптайм сервера MyChat
        cs_get_server_version                   : "0041", // получить версию сервера
        cs_halt_user                            : "0042", // отключить пользователя от сервера и завершить его приложение
        cs_set_state                            : "0043", // установить свой сетевой статус (свободен, занят и т.п.)
        cs_typing_notify                        : "0044", // отправить уведомление пользователю о том, что мы ему что-то пишем в привате
        cs_get_user_state                       : "0045", // получить статус другого пользователя
        cs_set_uin_foto                         : "0046", // установить фотографию для своего профиля
        cs_quit                                 : "0047", // пользователь отключается от сервера и посылает ему уведомление об этом
        cs_files_offline_ok                     : "0048", // пользователь согласился принять отложенные для него на сервере файлы
        cs_files_offline_late                   : "0049", // мы не хотим принимать отложенные для нас файлы прямо сейчас, примем их позже
        cs_files_offline_delete                 : "004A", // удалить все файлы, которые были отправлены офлайн указанным пользователем
        cs_get_user_quick_info                  : "004B", // получить краткую информацию об указанном пользователе
        cs_raw_data                             : "004C", // отправка произвольного пакета данных для онлайн-клиента
        cs_raw_data_txt_channel                 : "004D", // отправка произвольного пакета данных в текстовый канал
        cs_action                               : "004E", // выполнение MyChat Action
        cs_stat                                 : '0058', // отправить на сервер статистику использования сервисов чата
        cs_fatal_error_info                     : '0054', // отправить на сервер данные о произошедшей фатальной ошибке, приведшей к краху клиентского приложения

        // === file transfer ===

        cs_files_request_transfer               : '004F', // отправить запрос на отправку файлов и/или папок другому пользователю
        cs_files_transfer_deny                  : '0050', // отказаться принимать файлы от другого пользователя
        cs_files_transfer_accept                : '0051', // согласиться принимать файлы от другого пользователя
        cs_files_transfer_abort                 : '0052', // прервать передачу файлов
        cs_files_internal_send_idx              : '0053', // уведомление о начале передачи очередного файла из списка файлов для отправки
        cs_files_transfer_request_abort         : '0055', // отправить пользователю отказ от принятия файлов
        cs_files_internal_sended_ok_idx         : '0056', // успешно передан файл с указанным индексом из общего списка передаваемых файлов в сеансе связи
        cs_files_transfer_progress              : '0061', // отправить информацию другому пользователю о прогрессе передаваемых файлов. Отправляется не чаще раза в секунду
        cs_files_success_recieved               : '0062', // уведомление отправителю файлов, что все файлы успешно приняты
        cs_files_request_timeout                : '0057', // команда, которая отправляется автоматически, по истечении периода времени, когда получатель ничего не ответил на
                                                          // запрос приёма файлов(например, его не было за компьютером). Передача файлов в этом случае должна быть отменена автоматически
        // ==========================

        cs_get_users_list                       : "0059", // получить с сервера список пользователей (ФИО, пол, аватар и т.п.) согласно запросу
        cs_set_uin_info                         : '0068', // обновить информацию о профиле пользователя
        cs_find_users                           : "0060", // поиск пользователей на сервере согласно заданным критериям. Есть два варианта объекта
        cs_get_private_info                     : '0078', // получить краткую информацию о пользователе, с которым открывается приватный разговор
        cs_send_messages_buffer                 : "0079", // отправка буфера сообщений на сервер перед разрывом соединения

        cs_media_call                           : '007A',
        cs_media_call_accept                    : '007B',
        cs_media_call_reject                    : '007C',
        cs_media_call_close                     : '0080',
        cs_media_call_error                     : '0081', //произошла ошибка при сеансе аудио или видео связи
        cs_media_call_busy                      : '008E',

        cs_web_get_user_foto_file               : '007D',
        cs_web_support_i_am_busy                : '0094', // если пользователю WEB-поддержки с сайта приходит сообщение не от оператора, с кем он в данный момент говорит, он отвечает этой командой

        cs_adm_list_users                       : "0086", // получить список пользователей с сервера по заданным критериям. Нужны административные права
        cs_adm_get_server_info                  : '0090',
        cs_adm_get_user_profile                 : "0091", // получение полной информации о профиле любого пользователя, административная команда
        cs_adm_list_roles                       : '008B', // получить список групп прав пользователей (роли), нужны административные права
        cs_adm_set_user_password                : '0097', // изменить пароль пользователя
        cs_adm_create_user                      : '0096', // создать нового пользователя, административная команда
        cs_adm_remove_user                      : '0095', // удалить пользователя, административная команда
        cs_adm_modify_user_profile              : '0098', // модификация профиля юзера
        cs_adm_clear_user_foto                  : '0099', // удаление фотографии указанного пользователя, админкоманда
        cs_adm_get_server_options               : '009A', // получить все настройки сервера, админкоманда
        cs_adm_get_server_net_interfaces        : '009C', // получить список реальных IP всех сетевых интерфейсов сервера MyChat, админкоманда
        cs_adm_get_user_info_by_preset          : '009D', // получить список любых полей из профиля пользователя, админкоманда
        cs_adm_set_server_options               : '009B', // установить настройки сервера, админкоманда
        cs_adm_remove_all_logs                  : '009E', // удалить все протоколы на сервере, админкоманда
        cs_adm_make_backup_server_db            : '009F', // создать резервную копию базы данных сервера, админкоманда

        cs_adm_set_user_foto                    : "00A0", // назначить фото для пользователя

        cs_adm_get_job_positions_list           : '0093', // получить список должностей компании, административная команда
        cs_adm_job_positions_del                : '00A4', // удалить должность по индексу
        cs_adm_job_positions_add                : '00A3', // добавить новую должность
        cs_adm_job_positions_set_sequence       : '00A2', // установить последовательность должностей компании, массив, админкоманда (последовательсть ID должностей, те, что первые - "старше" тех, кто дальше)
        cs_adm_job_positions_modify             : '00A5', // изменить должность

        cs_adm_role_add                         : '00A6', // добавить новую группу прав
        cs_adm_role_delete                      : '00A7', // удалить группу прав
        cs_adm_role_modify                      : '00A8', // изменить группу прав
        cs_adm_role_set_rights                  : '00A9', // установить новые правила для группы прав
        cs_adm_role_users_list                  : '00AA', // получить список пользователей, входящих в заданную группу прав
        cs_adm_role_apply_to_users              : '00AB', // назначить роль указанному списку пользователей

        cs_adm_check_smtp                       : '00AD', // проверить работоспособность системы отправки почты

        cs_adm_enter_mychat_reg_data            : '00AE', // ввести регистрационные данные для MyChat Server
        cs_adm_enter_mychat_guest_reg_data      : '00AF', // ввести серийный номер для MyChat Guest

        cs_adm_get_websupport_groups            : '00B0', // получить список групп для веб-поддержки
        cs_adm_add_user_to_websupport_group     : '00B1', // перенести пользователя в заданную группу веб-поддержки
        cs_adm_delete_user_from_websupport      : '00B2', // удаление пользователя с группы веб-поддержки
        cs_adm_add_websupport_group             : '00B3', // добавить новую группу WEB-поддержки
        cs_adm_delete_websupport_group          : '00B4', // удалить группу веб-поддержки
        cs_adm_rename_websupport_group          : '00B5', // переименовать группу веб-поддержки
        cs_adm_get_websupport_group_users       : '00B6', // получить список пользователей указанной группы WEB-поддержки

        cs_adm_get_custom_options               : '00B7', // запросить кастомные настройки

        cs_adm_get_total_contacts_list          : '00B8', // запросить общий список контактов
        cs_adm_tcl_add_group                    : '00B9', // добавить новую группу в общий список контактов
        cs_adm_tcl_del_ids_list                 : '00BA', // удалить список групп и/или пользователей из общего списка контактов
        cs_adm_tcl_add_users_list_to_group      : '00E3', // добавить список пользователей в указанную группу
        cs_adm_tcl_move_users_and_groups        : '00E4', // переместить пользователей и/или группы в пределах общего списка контактов
        cs_adm_tcl_rename_group                 : '00E5', // переименовать группу в общем списке контактов

        cs_adm_import_users                     : '00BB', //

        cs_adm_return_server_to_zero_state      : '00BD', // вернуть базу данных MyChat Server в первоначальное состояние, все данные будут удалены. Админкоманда

        cs_adm_set_custom_options               : '00BC', // установить заданные настройки, количество полей может быть переменным
        cs_adm_get_licenses                     : '00BE', // получить информацию по лицензиям MyChat Server

        cs_adm_get_antiflood_filter_data        : '00BF', // получить информацию по антифлуд-фильтрам. Админкоманда
        cs_adm_set_antiflood_filter_data        : '00C0', // установить настройки серверных антифлуд-фильтров. Админкоманда
        cs_adm_modify_flood_except_users        : '00C1', // изменить список пользователей, которых не касаются настройки антифлуд-фильтров
        cs_adm_get_flood_except_users_list      : '00C2', // получить список пользователей, которых не касаются настройки антифлуд-фильтров

        cs_adm_get_allow_ip_list                : '00C3', // получить список IP адресов ("белый" список), которым разрешено подключаться к MyChat Server
        cs_adm_add_new_ip_to_allow_list         : '00C4', // добавить новый IP адрес, маску или диапазон в список разрешённых адресов
        cs_adm_delete_allow_ip                  : '00C5', // удалить IP адрес из списка разрешённых адресов для подключения
        cs_adm_clear_allow_ip_list              : '00C6', // полностью очистить список разрешённых IP адресов

        cs_adm_get_blocked_ip_list              : '00C7', // получить список заблокированных IP адресов (масок и диапазонов). Админкоманда
        cs_adm_add_ip_to_block_list             : '00C8', // добавить IP адрес в список заблокированных
        cs_adm_delete_blocked_ip                : '00C9', // удалить из списка заблокированных IP адрес/маску/диапазон
        cs_adm_clear_blocked_ip_list            : '00CA', // очистить список заблокированных IP адресов/масок/диапазонов

        cs_adm_get_blocked_mac_list             : '00CB', // получить список заблокированных MAC адресов
        cs_adm_delete_blocked_mac               : '00CC', // удалить заблокированный MAC адрес из общего списка
        cs_adm_add_mac_to_block_list            : '00CD', // добавить MAC адрес в список заблокированных
        cs_adm_clear_blocked_mac_list           : '00CE', // очистить список заблокированных MAC адресов

        cs_adm_get_deny_nicks_list              : '00CF', // получить список заблокированных ников в JSON-формате
        cs_adm_add_deny_nick                    : '00D0', // добавить новый ник в заблокированные
        cs_adm_delete_deny_nick                 : '00D1', // удалить ник из списка блокировок
        cs_adm_clear_deny_nicks_list            : '00D2', // полностью очистить список заблокированных ников

        cs_adm_get_deny_conf_list               : '00D3', // получить список заблокированных конференций в JSON-формате
        cs_adm_add_deny_conf                    : '00D4', // добавить новую конференцию в список заблокированных
        cs_adm_delete_deny_conf                 : '00D5', // удалить конференцию из блек-листа
        cs_adm_clear_deny_conf_list             : '00D6', // полностью очистить список заблокированных конференций

        cs_adm_get_bad_words_filters_data       : '00D7', // получить информацию по фильтрам плохих слов в чате
        cs_adm_set_bad_words_filter_data        : '00D8', // сохранить данные по фильтрам "плохих" слов
        cs_adm_get_bad_words_list               : '00D9', // получить полный список "плохих" слов. Админкоманда
        cs_adm_add_bad_word_to_filters          : '00DA', // добавить новое "плохое" слово в список фильтрации, админкоманда
        cs_adm_del_bad_word_from_filters        : '00DB', // удалить "плохое" слово и общего списка
        cs_adm_clear_bad_words_list             : '00DC', // полностью очистить список "плохих" слов, админкоманда
        cs_adm_load_badwords_except_confs       : '00DD', // получить список конференций, в которых отключен фильтр мата
        cs_adm_add_badwords_except_conf         : '00DE', // добавить новую конференцию в список исключений антимат-фильтра
        cs_adm_del_badwords_except_conf         : '00DF', // удалить конференцию из списка исключений антимат-фильтра
        cs_adm_clear_badwords_except_confs      : '00E0', // очистить список исключений конференций антимат-фильтров

        cs_adm_export_users_to_csv              : '00E1', // экспорт списка пользователей в CSV файл
        cs_adm_multiply_modify_users            : '00E2', // множественное изменение данных пользователей
        cs_get_online_users_states              : '00E6', // получить список UIN-ов и статусов всех пользователей, которые в данный момент есть онлайн
        cs_get_depts_list                       : '00E7', // получить список подразделений компании

        cs_adm_get_all_text_confs               : '00E8', // получить список всех текстовых конференций

        cs_adm_force_update_global_contacts     : '00E9', // принудительно обновить кеш общего списка контактов и разослать его всем онлайн-пользователям

        cs_adm_get_bans_list                    : '00EA', // получить список всех банов, которые в данный момент актуальны на сервере. Админкоманда
        cs_adm_del_bans                         : '00EB', // снять указанные баны по индексам, админкоманда
        cs_adm_get_moderators                   : '00EC', // получить список модераторов, админкоманда
        cs_adm_get_conf_names_by_uid_list       : '00ED', // получить список названий конференций по их UID
        cs_adm_delete_moderators                : '00EE', // удалить список модераторов
        cs_adm_add_moderator                    : '00EF', // добавить модератора конференции
        cs_adm_del_moderator_confs              : '00F0', //

        cs_get_random_uin                       : '00F3', // получить случайный UIN из списка людей онлайн
        cs_set_custom_ignore                    : '00F4', // добавить игнор для указанного пользователя
        cs_del_custom_ignore                    : '00F5', //  игнор для указанного пользователя

        cs_adm_get_auto_conf_list               : '00F6', // получить список автосоздаваемых конференций на сервере
        cs_adm_del_auto_conf                    : '00F7', // удаление автосоздаваемой конференции по идентификатору
        cs_adm_add_auto_conf                    : '00F8', // создать новый автосоздаваемый канал
        cs_adm_update_auto_conf                 : '00F9', // обновить данные об австосоздаваемой конференции
        cs_adm_add_group_to_auto_conf           : '00FA', // добавить группу для включения в автосоздаваемую конференцию
        cs_adm_del_group_from_auto_conf         : '00FB', // удалить группу пользователей из автосоздаваемой конференции

        cs_adm_get_bbs_msg_list                 : '00FC', // получить список актуальных сообщений на доске объявлений
        cs_adm_bbs_clear_actual                 : '00FD', // удалить все актуальные сообщения на доске объявлений
        cs_adm_bbs_get_msg                      : '00FE', // получить данные сообщение на доске объявлений по его идентификатору
        cs_adm_bbs_modify_msg                   : '00FF', // изменить сообщение на доске объявлений, админкоманда
        cs_adm_bbs_del_messages                 : '0100', // удалить актуальные сообщения на доске объявлений по их индексу
        cs_adm_add_bbs_message                  : '0101', // добавить новое сообщение на доску объявлений

        cs_adm_save_ad_options                  : '0102', // сохранить данные по настройке Active Directory интеграции
        cs_adm_get_ad_options                   : '0103', // получить настройки по Active Directory интеграции

        cs_adm_import_ad_users                  : '0104', // импортировать выбранных пользователей active directory

        cs_adm_get_update_packet_data           : '0105', // получить данные update-пакета для клиентов MyChat
        cs_adm_upload_update_packet             : '0106', // загрузить пакет обновления на сервер. Административная команда

        cs_adm_get_online_users_list            : '0107', // получить список онлайн-пользователей
        cs_adm_kill_users                       : '0108', // отключить от сервера указанный список пользователей (разорвать соединение). В ответ приходит sc_adm_command_complete с командой cs_adm_kill_users
        cs_adm_halt_users                       : '0109', // отправить списку пользователей команду завершения работы приложения с последующим отключением от сервера.
                                                          // В ответ приходит sc_adm_command_complete с командой cs_adm_halt_users
        cs_adm_get_ad_users_list                : '010A', // получить с сервера Active Directory список пользователей
        cs_sync_private_history_last            : '010B', // получить последние N сообщений из приватного разговора с указанным пользователей. Можно запросить максимум 100 сообщений
        cs_sync_private_history                 : '010C', // получить логи разговоров в привате (синхронизация)

        cs_adm_get_script                       : '010D', // получить скрипт по его ID
        cs_adm_get_script_event_states          : '010E', // получить список статусов доступных скриптов. Нужны админправа
        cs_adm_script_check_syntax              : '010F', // проверить синтаксис написанного серверного скрипта
        cs_adm_script_onoff                     : '0110', // включение выключение скрипта
        cs_adm_script_run                       : '0111', // запуск скрипта
        cs_adm_script_delete                    : '0112', // удалить скрипт
        cs_adm_script_save                      : '0113', // сохранить скрипт
        cs_adm_script_create                    : '0114', // создать скрипт

        cs_adm_restart_server_services          : '0115', // принудительный перезапуск встроенного WEB-сервера, админкоманда

        cs_adm_get_active_conf_list             : '011B', // получить список работающих конференций, админкоманда
        cs_adm_kill_txt_conf                    : '011C', // удалить текстовую конференцию с сервера (не автосоздаваемую). Админкоманда. В ответ приходит complete: cs_adm_kill_txt_conf либо ошибка
        cs_adm_get_users_in_conf                : '011D', // получить список пользователей в конференции
        cs_adm_kick_users_from_conf             : '011E', //выгнать из конференции указанных пользователей

        cs_info                                 : '077C', //

        cs_adm_remove_conversations             : '0183', // удалить любые протоколы разговоров на сервере и у клиентов за всё время

        // ==== KANBAN =========================================================

        cs_kanban_get_projects_list             : '0117', // получить список проектов kanban
        cs_kanban_get_stages_list               : '0118', // получить список этапов проекта
        cs_kanban_get_tasks_list                : '0119', // получить список задач kanban-доски
        cs_kanban_get_tags_list                 : '011A', // получить список тегов kanban-доски
        cs_kanban_add_project                   : '0120', // добавить новый проект на kanban-доску
        cs_kanban_add_stage                     : '0121', // добавить новый stage на kanban доску
        cs_kanban_delete_stage                  : '0122', // удалить этап указанного проекта с kanban-доски
        cs_kanban_modify_stage                  : '0123', // изменить этап проекта kanban-доски
        cs_kanban_add_task                      : '013B', // добавить новую задачу на kanban-доску
        cs_kanban_task_move                     : '013C', // перенос задачи в новый stage
        cs_kanban_task_remove                   : '013D', // удаление задачи
        cs_kanban_task_edit                     : '013E', // редактирование задачи
        cs_kanban_add_comment                   : '013F', // добавление нового комментария к таску на kanban-доске
        cs_kanban_get_comments                  : '0140', // получить список комментариев к задаче на kanban-доске
        cs_kanban_delete_comment                : '0141', // удалить комментарий к задаче с доски kanban
        cs_kanban_close_project                 : '0142', // закрыть проект kanban
        cs_kanban_reopen_project                : '0143', // открыть заново уже закрытый проект kanban
        cs_kanban_delete_project                : '0144', // удалить kanban проект
        cs_kanban_edit_project                  : '0145', // изменить kanban-проект
        cs_kanban_get_personal_options          : '0149', // получить персональный набор опций клиента по его UIN
        cs_kanban_save_personal_options         : '014A', // сохранить персональный набор настроек. JSON объект, любые поля

        cs_kanban_get_project_rights            : '014B', // получить список прав на kanban-проект
        cs_kanban_get_project_info              : '014C', // получить краткую информацию о проекте
        cs_kanban_get_task_info                 : '014D', // получить краткую информацию о задаче

        cs_kanban_get_last_performers           : '0153', // получить последних исполнителей задач для указанного проекта
        cs_kanban_get_project_tags_list         : '0168', // получить список тегов для конкретного проекта
        cs_kanban_get_dashboard                 : '0169', // получить краткую сводную информацию о проектах Kanban

        // ==============================================================

        cs_get_personal_options                 : '0149', // получить персональный набор опций клиента по его UIN
        cs_save_personal_options                : '014A', // сохранить персональный набор настроек. JSON объект, любые поля

        cs_browser_info                         : '0124', // информация о браузере пользователя, если это web-клиент

        cs_media_offer                          : '0125', // создание медиа-запроса к клиенту
        cs_media_answer                         : '0126', // создание медиа-ответа на запрос media offer
        cs_media_ice_candidate                  : '0127', // ответ STUN/TURN сервера для собеседника
        cs_media_change_settings                : '0128', // изменение настроек медиа-данных пользователя (аудио/видео)
        cs_media_ready                          : '0129', // NodeWebKit клиента успешно стартовал и работает
        cs_media_exit_from_mid                  : '012A', // пользователь вышел из media-канала

        cs_import_personal_contacts             : '012B', // импорт персональных контактов

        cs_adm_get_client_options_presets       : '012C', // получить список шаблонов настроек клиентов, админкоманда
        cs_adm_del_client_options_preset        : '012D', // удалить шаблон настроек клиента по его идентификатору, админкоманда
        cs_adm_create_client_options_preset     : '012E', // создать новый шаблон настроек для клиентов, админкоманда
        cs_adm_update_client_options_preset     : '012F', // изменить шаблон настроек, админкоманда
        cs_adm_apply_roles_to_options_presets   : '0131', // назначить роли групп прав пользователей для наборов настроек, массив

        cs_adm_add_new_user_group               : '0132', // создать новую группу пользователей
        cs_adm_get_user_groups                  : '0133', // получить список существующих групп пользователей
        cs_adm_get_group_users_list             : '0134', // получить список пользователей указанный группы
        cs_adm_add_users_to_group               : '0135', // добавить список пользователей в группу
        cs_adm_remove_users_from_group          : '0136', // удалить пользователей из группы
        cs_adm_rename_group_of_users            : '0137', // переименовать указанную группу пользователей
        cs_adm_delete_groups_list               : '0138', // удалить список групп пользователей

        cs_adm_set_integration_tools_options    : '0139', // установить настройки интеграции инструмента (phpbb... etc.)
        cs_adm_get_integration_tool_options     : '013A', // получить настройки интеграции инструмента (phpbb... etc.)

        cs_adm_get_check_domains_list           : '0146', // получить список доменов с адресами и портами, которые используются для проверки наличия пользователей в данных доменах
        cs_adm_add_check_domain                 : '0147', // добавить домен в список доменов для проверки возможности логинов доменных пользователей
        cs_adm_delete_check_domain              : '0148', // удалить домен из списка доменов для проверки подключающихся доменных пользователей

        cs_adm_get_allowed_and_blocked_plugins  : '014E', // получить списки разрешённых и запрещённых плагинов
        cs_adm_add_allowed_or_blocked_plugins   : '014F', // добавить названия плагинов в список запрещённых или разрешённых клиентских плагинов
        cs_adm_delete_allowed_or_blocked_plugin : '0150', // удалить плагин из списка разрешённых или запрещённых клиентских плагинов

        cs_adm_change_mychat_server             : '0151', // изменить параметры подключения клиентов к серверу MyChat
        cs_adm_get_script_info                  : '0152', // получить краткую информацию о скрипте, админкоманда

        // == FORUM ===========================================

        cs_forum_get_structure                  : '0156', // получить структуру форума (разделы и топики, в JSON)
        cs_forum_create_section                 : '0157', // добавить новый раздел в форум
        cs_forum_delete_section                 : '0158', // удаление раздела форума
        cs_forum_change_section                 : '0159', // перемещение/переименование раздела форума
        cs_forum_create_topic                   : '015A', // добавить новый топик в форум
        cs_forum_change_topic                   : '015B', // перемещение/переименование топика форума
        cs_forum_create_post                    : '015C', // добавить новый пост в форум

        cs_forum_delete_post                    : '015D', // удалить сообщение из форума
        cs_forum_delete_topic                   : '015E', // удалить тему из форума
        cs_forum_change_post                    : '015F', // перемещение/переименование сообщения форума
        cs_forum_get_topic_posts                : '0160', // получить список сообщений указанного топика форума
        cs_forum_get_section_info               : '0161', // получить информацию о секции (список топиков, краткая информация о них: LastChange, UIN, DisplayName, Sex, Avatar, DateTime, CountMessages)

        cs_get_book                             : '0164', // получить справочник с сервера
        cs_is_file_exists                       : '0165', // узнать, есть ли файл с таким хэш-кодом на сервере. Параметры Where и ID потом вернутся обратно пользователю в команде-ответке
        cs_get_image_thumbs                     : '0166', // получить уменьшенную копию изображения с сервера

        cs_create_token                         : '0154', // создать токен для быстрого доступа в какой-нибудь сервис чата
        cs_login_by_token                       : '0155', // логин в MyChat/kanban/forum/web по токену
        cs_get_removed_user_info                : '016F', // получить краткую информацию об удалённом пользователе

        cs_adm_get_integration_telegram_users   : '016B', // получить список пользователей для интеграции с Telegram
        cs_adm_integration_telegram_delete_user : '016C', // удалить Telegram пользователя из списка для интеграции
        cs_adm_integration_telegram_modify_user : '016D', // изменить параметры Telegram пользователя из списка для интеграции
        cs_adm_integration_telegram_clear_users_list: '016E', // очистить список пользователей для интеграции с Telegram

        cs_integration_icq_set_account          : '0170', // привязать ICQ аккаунт к своей учётной записи
        cs_integration_icq_send_message         : '0171', // отправить сообщение пользователю ICQ
        cs_adm_delete_conf_message              : '0172', // удалить сообщение из текстовой конференции

        cs_adm_get_history_info_private         : '0173', // админкоманда, получить информацию по сообщениям в привате за диапазон времени. В ответ приходит 8107 sc_adm_history_info_private
        cs_adm_get_history_private              : '0174', // админкоманда, получение истории приватов двух юзеров по диапазону индексов
        cs_adm_get_history_info_conf            : '0175', // админкоманда, получить информацию по сообщениям в конференции за диапазон времени. В ответ приходит 8109 sc_adm_history_info_conf
        cs_adm_get_history_conf                 : '0176', // админкоманда, получение истории в конференции по диапазону индексов
        cs_adm_get_history_private_user_pairs   : '0177', // админкоманда, получить все пары приватных разговоров за все время, ответ будет 810B sc_adm_history_private_user_pairs

        cs_adm_check_ports                      : '017A', // проверить, не заняты ли порты указанных сервисов, админкоманда. Если всё ок, будет complete, если нет - ошибка с первым "неудачным" портом

        cs_moder_delete_conf_message            : '017B', // удалить сообщение из текстовой конференции, нужны права для удаления сообщений в конференциях из раздела "Администрирование"

        cs_adm_reconnect_users2autoconf         : '017D', // добавить/выгнать пользователей автосоздаваемой конференции, которую только что меняли

        cs_adm_get_blocked_hwid_list            : '017E', // получить список заблокированных HardwareID, админкоманда
        cs_adm_delete_blocked_hwid              : '017F', // удалить заблокированный HardwareID адрес из общего списка
        cs_adm_clear_blocked_hwid_list          : '0180', // очистить список заблокированных HardwareID на сервере
        cs_adm_add_hwid_to_block_list           : '0181', // добавить HardwareID клиента в список блокировок
        cs_adm_get_system_logs                  : '0182', // получить системные логи за период времени, админкоманда

        cs_get_options_preset                   : '0130', // получить шаблон настроек по его идентификатору

        cs_broadcast_readed_notify              : '005E', // уведомить отправителя оповещения персональным сообщением, что его сообщение только что было прочитано получателем, набор объектов
        cs_broadcast_just_readed                : '005F', // отправить на сервер уведомление об обязательном прочтении полученных оповещений (или одного оповещения), набор объектов

        cs_adm_modify_check_domain              : '0185', // отредактировать настройки для указанного домена
        cs_adm_get_domains_list                 : '0186', // получить список доменов, с которыми может работать сервер MyChat
        
        cs_adm_forum_get_subs_groups            : '0187', // получить список групп пользователей, которые подписаны на конкретную тему либо секцию
        cs_adm_forum_add_subs_group             : '0188', // подписать группу пользователей на тему или секцию форума
        cs_adm_forum_delete_subs_group          : '0189', // удалить группу пользователей из подписки на секцию или тему форума
        cs_adm_forum_clear_subs                 : '018A', // удалить все подписки на тему или раздел форума (группы и пользователи)
        cs_adm_forum_add_subs_user              : '018B', // подписать пользователя на тему или секцию форума
        cs_adm_forum_delete_subs_user           : '018C', // удалить пользователей из подписки на секцию или тему форума
        cs_adm_forum_get_subs_users             : '018D', // получить список пользователей, которые подписаны на конкретную тему либо секцию

        cs_sync_conf_history                    : '0179', // получить логи разговоров в конференции (синхронизация). Пользователь должен находиться в указанной конференции
        cs_get_forum_subs                       : '018E', // получить список подписок на темы и разделы форума
        cs_forum_toggle_subs                    : '018F', // добавить или убрать подписку на тему либо раздел (секцию) форума
        cs_set_custom_options                   : '0190', // сохранить кастомные настройки клиента на сервере
        cs_get_custom_options                   : '0191', // получить кастомные настройки клиента на сервере

        cs_adm_integration_quiz_check_question  : '0193', // проверить существование вопроса в базе робота-викторины по тексту вопроса или по номеру
        cs_adm_integration_quiz_add_question    : '0194', // добавить новый вопрос в базу робота-викторины
        cs_adm_integration_quiz_del_question    : '0195', // удалить вопрос из базы робота-викторины по номеру
        cs_adm_integration_quiz_modify_question : '0196', // редактировать вопрос в базе робота-викторины по индексу
        cs_adm_integration_quiz_get_stat        : '0197', // получить статистику робота-викторины
        cs_adm_integration_quiz_clear_stat      : '0198', // очистить статистику робота-викторины
        cs_adm_enter_quiz_reg_data              : '0199', // ввести серийный номер для робота-викторины

        cs_users_live_search                    : '019A', // найти список пользователей на сервере
        cs_get_private_dialogs                  : '019B', // получить список своих приватных диалогов
        cs_del_private_dialog                   : '019C', // удалить диалог с указанным юзером из списка приватных диалогов
        cs_private_msg_read                     : '019D', // пользователь только что прочитал приватное сообщение из указанного диалога
        cs_private_msg_got                      : '019E', // пользователь только что получил приватное сообщение из указанного диалога
        cs_private_get_dialog_msg_states        : '019F', // получить информацию о полученных и прочитанных сообщениях в приватном диалоге с оппонентом

        cs_adm_delete_private_message           : '01A0', // удалить сообщение из приватного диалога

        cs_delete_private_message               : '01A1', // удалить сообщение из привата, нужны права для удаления произвольных сообщений в своих приватах
        cs_redirect_private_talk                : '01A2', // перенаправить приватный разговор от одного пользователя к другому

        cs_get_users_for_redirect_dialog        : '01A3', // получить список пользователей, на которых можно сделать перенаправление диалога


        // =========================================

        adm_ldap_get_user_list: 'ldap_get_user_list',
        adm_ldap_get_user_info: 'ldap_get_user_info',

        adm_ldap_user_list: 'ldap_user_list',
        adm_ldap_user_info: 'ldap_user_info',

        // Server CMD ==============================

        sc_hello                                : '8000', // ответ на соединение клиента (сигнатура версии которую присылает клиент, например "mc5.0")
        sc_error                                : "8001", // произошла какая-то ошибка
        sc_accept_connection                    : "8002", // сервер разрешает соединение
        sc_free_edition                         : "8003", // сообщение клиенту, что тот подключен к бесплатному серверу MyChat
        sc_get_all_rights                       : "8004", // список прав клиента на сервисы чата, а также список разрешённых и запрещённых плагинов на данном сервере
        sc_login                                : "8005", // fucking login...
        //sc_job_positions                        : "8006", // * список должностей компании. Нужна доработка
        sc_remote_set_options_file              : "8007", // удалённая отправка списка настроек клиенту (файл). Будет удалено, останется только команда 8022 sc_remote_set_options
        sc_get_channels_list                    : "8008", // список каналов, которые созданы на сервере
        sc_bbs_changed                          : "8009", // уведомление клиента о том, что была изменена доска объявлений
        sc_offline_private                      : "800A", // офлайн приватное сообщение для клиента
        sc_private                              : "800B", // обычное приватное сообщение для клиента
        sc_get_small_user_info                  : "800C", // получить краткую информацию о пользователе (доделать)
        sc_show_advert_block                    : "800D", // показать рекламный блок в клиенте
        sc_hide_advert_block                    : "800E", // спрятать рекламный блок
        sc_pong                                 : "800F", // отправка с сервера команды-реакции на cs_ping, проверка связи
        sc_actions_list                         : "8010", // пришёл список команд ACTIONs с сервера, нужна доработка
        sc_files_offline_exists                 : "8011", // есть отложенные файлы для клиента
        sc_grant_private_access                 : "8012", // разрешение общаться с пользователем в привате, краткая информация о собеседнике
        sc_join_txt_channel                     : "8013", // вход пользователя в текстовый канал
        sc_txt_channel_hello_msg                : "8014", // текст приветствия указанного текстового канала
        sc_txt_channel_give_grant               : "8015", // получение прав на текстовый канал
        sc_ulist_in_txt_ch                      : "8016", // список пользователей в текстовом канале
        sc_join_newbie_txt_channel              : "8017", // новый пользователь вошёл в текстовый канал
        sc_join_newbies_txt_channel             : "8073", // новые пользователи вошли в текстовый канал
        sc_online_notify                        : "8018", // уведомление о том, что пользователь, который нам интересен, появился в онлайн
        sc_broadcast                            : "8019", // текстовое оповещение
        sc_user_online                          : "801A", // указанный пользователь подключен к серверу
        sc_trial                                : "801B", // информация о том, что используемая версия сервера незарегистрирована, и сколько дней осталось до конца работы trial-версии
        sc_remote_set_options                   : "801C", // настроить клиент в соответствии с пришедшим набором настроек в JSON формате. Доделать описание
        sc_get_msgtemplates                     : "801D", // с сервера пришёл список шаблонов для "быстрых" сообщений. Нужна переделка
        sc_get_contacts_list                    : "801E", // список личных контактов клиента. Доделать
        sc_get_common_contacts_list             : "801F", // список общих контактов клиента. Доделать
        sc_ping                                 : "2080", // 8020 принудительный пинг с сервера, проверка связи при плохом соединении, нужно при получении ответить командой cs_pong
        sc_ignore                               : "8021", // отправленное сообщение было проигнорировано другим пользователем
        sc_user_state                           : "8022", // текущий статус пользователя
        sc_leave_txt_channel                    : "8023", // пользователь вышел из указанного канала, информационное уведомление
        sc_kill_txt_ch                          : "8024", // текстовый канал удалён с сервера
        sc_bbs_body                             : "8025", // содержимое доски объявлений, доработать
        sc_add_personal_contact_group           : "8026", // в персональную панель контактов была успешно добавлена новая группа
        sc_delete_personal_contact_group        : "8027", // удалить группу из личного списка контактов
        sc_txt_channel_created                  : "8028", // уведомление о том, что на сервере создан новый текстовый канал
        sc_get_uin_info                         : "8029", // получение полной информации о пользователе
        sc_get_remote_uin_current_time          : "802A", // получить текущее системное время удалённого пользователя (remote user)
        sc_user_current_time                    : "802B", // текущие системные дата и время указанного пользователя
        sc_user_foto                            : "802C", // информация о фотографии указанного пользователя
        sc_user_computer_info                   : "802D", // информация об IP/MAC адресе пользователя и сетевом имени его компьютера
        sc_get_active_window_caption            : "802E", // запрос сервера у клиента заголовока активного окна
        sc_user_active_window_caption           : "802F", // ответ сервера клиенту с заголовока активного окна
        sc_ignores_list                         : "8030", // список игноров для указанного пользователя // доработать разбор строки
        sc_favorite_channels_list               : "8031", // список "любимых" каналов пользователя
        sc_change_password                      : "8032", // для пользователя установлен новый пароль к его учётной записи. Команда приходит в ответ на попытку изменения собственного пароля, либо при изменении пароля пользователя принудительно, на сервере, администратором
        sc_add_new_contact                      : "8033", // добавить новый контакт в персональный список контактов
        sc_delete_contact                       : "8034", // удалён контакт из личного списка контактов
        sc_rename_contacts_group                : "8035", // переименована личная группа контактов
        sc_move_personal_contact                : "8036", // персональный контакт перенесён в новую группу
        sc_open_remote_computer_shares          : "8037", // открыть удалённый компьютер по сети Проводником (показать открытые ресурсы (shares))
        sc_txtch_topic_changed                  : "8038", // изменена тема текстового канала
        sc_public_ftp_info                      : "8039", // информация о публичном доступе к FTP серверу MyChat
        sc_channel_history_messages             : "803A", // получена история сообщений в текстовом канале за временной период
        sc_rename_text_channel                  : "803B", // текстовый канал переименован
        sc_user_ignore_info                     : "803C", // информация об игнорировании указанного пользователя
        sc_clear_text_channel                   : "803D", // очистить выбранный текстовый канал от всех сообщений
        sc_personal_message2txtch               : "803E", // персональное/важное сообщение лично другому пользователю в текстовый канал
        sc_kick_from_txt_channel                : "803F", // пользователя выгнали из текстового канала
        sc_private_beep                         : "8040", // отправить пользователю звуковой сигнал
        sc_server_uptime                        : "8041", // сколько времени работает сервер MyChat без перезагрузки
        sc_server_version                       : "8042", // информация о версии сервера
        sc_user_offline                         : "8043", // пользователь с указанным UIN о тключился от сервера
        sc_halt                                 : "8044", // немедленно отключиться от сервера и завершить работу приложения в принудительном порядке
        sc_typing_notify                        : "8045", // уведомление о том, что нам в привате в данный момент кто-то пишет ответ
        sc_update_user_data                     : "8046", // обновить информацию об указанном пользователей
        sc_change_server                        : "8047", // изменить параметры подключения к серверу MyChat
        sc_user_quick_info                      : "8048", // краткая информация о пользователе
        sc_raw_data                             : "8049", // отправка произвольного пакета данных для онлайн-клиента
        sc_raw_data_txt_channel                 : "804A", // отправка произвольного пакета данных в текстовый канал

        sc_files_offline_send_accept            : "804B", // подтверждение на отправку файлов в офлайн (на сервер) для указанного пользователя
        sc_files_request_transfer               : "804C", // запрос на приём файлов от указанного пользователя
        sc_files_transfer_deny                  : "804D", // пользователь отказался принимать файлы
        sc_files_transfer_accept                : "804E", // пользователь согласился принимать файлы
        sc_files_transfer_abort                 : "804F", // пользователь прервал передачу файлов
        sc_file_internal_send_idx               : "8050", // идёт передача очередного файла
        sc_files_transfer_request_abort         : "8051", // пользователь ответил отказом на запрос приёма файлов
        sc_file_internal_sended_ok_idx          : "8052", // очередной файл успешно передан
        sc_files_request_timeout                : "8053", // отказ от приёма файлов по тайм-ауту
        sc_files_transfer_progress              : '8059', // информация о прогрессе передаваемых файлов между двумя пользователями
        sc_files_success_recieved               : '805B', //
        
        sc_registered                           : "805E", // уведомление пользователя о том, что он успешно зарегистрирован на сервере
        sc_find_users_list                      : "8058", // список пользователей, в ответ на клиентский запрос поиска пользователей (cs_find_users). Набор объектов
        sc_users_list                           : "8055", // список пользователей, отправляемый на клиент. Набор объектов
        sc_serv_stat                            : '8054', // общая статистика сервера
        sc_private_info                         : '806F', // краткая информация о пользователе, полученная по шаблону

        sc_media_call                           : '8070',
        sc_media_call_accept                    : '8071',
        sc_media_call_reject                    : '8072',
        sc_media_call_close                     : '8075',
        sc_media_call_error                     : '8076',
        sc_media_call_busy                      : '8081',
        sc_media_incoming_call_missed           : '80D7', // пропущен входящий медиазвонок от указанного пользователя, вы в данный момент общались с другим человеком
        sc_media_offer                          : '80D2', // медиа-запрос к клиенту
        sc_media_answer                         : '80D3', // ответ на запрос media offer
        sc_media_ice_candidate                  : '80D4', // ответ на запрос ответ cs_media_ice_candidate
        sc_media_change_settings                : '80D5', // изменение настроек медиа-данных пользователя (аудио/видео)
        sc_media_ready                          : '80D6', // NodeWebKit клиента успешно стартовал и работает

        sc_web_user_foto_file                   : '8074',
        sc_web_support_i_am_busy                : '8087', // если пользователю WEB-поддержки с сайта приходит сообщение не от оператора, с кем он в данный момент говорит, он отвечает этой командой

        sc_adm_set_topic                        : "8079", // результат работы административной команды по установке темы конференции
        sc_adm_list_channels                    : "807A",
        sc_adm_list_users                       : "807B",
        sc_adm_get_server_info                  : "8083", // результат работы административной команды по получению полного списка созданных текстовых конференций. Набор объектов, UID канала
        sc_adm_get_user_profile                 : "8084", // получение полной информации о профиле любого пользователя, административная команда
        sc_adm_list_roles                       : '807F', // список ролей (групп права) пользователей с сервера, административная команда, массив
        sc_adm_user_created                     : '8088', // пользователь только что был создан
        sc_adm_get_job_positions_list           : '8086', // список должностей компании, массив объектов
        sc_adm_server_options                   : '8089', // настройки сервера, ответ на административную команду cs_adm_get_server_options
        sc_adm_server_net_interfaces            : '808A', // список реальных IP адресов сетевых интерфейсов сервера MyChat (IPv4 и IPv6)
        sc_adm_user_info_by_preset              : '808B', // список информационных полей указанного пользователя согласно запрошенному набору
        sc_adm_command_complete                 : '808C', // административная команда успешно выполнена

        sc_adm_job_positions_added              : '808E', // добавлена новая должность
        sc_adm_job_positions_modified           : '808F', // должность была изменена успешно

        sc_adm_role_added                       : '8090', // успешно создана новая группа прав
        sc_adm_role_modified                    : '8091', // группа прав была успешно изменена
        sc_adm_role_users_list                  : '8092', // список пользователей указанной группы прав

        sc_adm_smtp_checked                     : '8093', // SMTP проверка
        sc_invite_to_webchat_sended_ok          : '8094', // уведомление о том, что отправка приглашения для другого человека в MyChat прошла успешно
        sc_adm_websupport_groups                : '8095', // список групп для сотрудников WEB-поддержки сайта, массив
        sc_adm_websupport_group_added           : '8096', // добавлена новая группа WEB-поддержки
        sc_adm_websupport_group_users           : '8097', // список пользователей WEB-support группы
        sc_adm_websupport_group_renamed         : '8098', // группа веб-поддержки успешно переименована

        sc_adm_custom_options                   : '8099', // кастомные настройки, запрошенные с помощью команды cs_adm_get_custom_options
                                                          // Количество полей может быть переменным

        sc_adm_total_contacts_list              : '809A', // общий список контактов, массив объектов

        sc_adm_tcl_group_added                  : '809B', // группа общего списка контактов успешно создана
        sc_adm_tcl_users_added                  : '80A9', // список пользователей успешно занесён в группу общих контактов

        sc_adm_users_imported                   : '809C', // пользователи импортированы в сервер

        sc_adm_server_licenses                  : '809D', // информация о лицензиях MyChat Server

        sc_adm_antiflood_filter_data            : '809E', // информация по антифлуд-фильтрам. Админкоманда
        sc_adm_flood_except_users_list          : '809F', // список пользователей, которых не касаются серверные антифлуд-фильтры, массив. Если массив пустой - значит, таких пользователей на сервере нет

        sc_adm_allow_ip_list                    : '80A0', // список разрешённых IP адресов
        sc_adm_blocked_ip_list                  : '80A1', // список заблокированных IP адресов (масок и диапазонов), массив объектов
        sc_adm_blocked_mac_list                 : '80A2', // список заблокированных MAC адресов
        sc_adm_blocked_nicks_list               : '80A3', // список заблокированных ников, админкоманда. Массив текстовых строк
        sc_adm_blocked_confs_list               : '80A4', // список заблокированных названий конференций. Массив текстовых строк

        sc_adm_bad_words_filter_data            : '80A5', // данные по фильтрам "плохих" слов
        sc_adm_bad_words_list                   : '80A6', // полный список "плохих" слов, админкоманда. Массив текстовых строк
        sc_adm_bad_words_except_confs           : '80A7', // список конференций, в кот орых отключен антимат-фильтр. Массив текстовых строк

        sc_adm_export_users_to_csv_file         : '80A8', // список пользователей с указанными данными успешно экспортирован в CSV файл

        sc_online_users_states                  : '80AA', // список UIN-ов и статусов всех пользователей, которые в данный момент есть онлайн
        sc_dept_list                            : '80AB', // список подразделений компании, массив объектов
        sc_caches                               : '80AC', // контрольные суммы (CRC32) кешей различных данных, которые, возможно, будут нужны клиенту
        sc_adm_all_text_confs                   : '80AD', // список всех текстовых конференций, которые когда-либо создавались на сервере
        sc_just_connect_disconnect_users        : '80AE', // список пользователей, которые отключились или подключились за последнее время (раз в три секунды обычно)
        sc_adm_bans_list                        : '80AF', // список банов пользователей, массив объектов
        sc_adm_moderators_list                  : '80B0', // список модераторов чата, админкоманда, массив объектов
        sc_adm_conf_names_list_by_uid           : '80B1', // список текстовых конференций, которые когда-либо создавались на сервере.

        sc_put_msg2txt_channel                  : '80B4', // получить сообщение в текстовый канал

        sc_adm_auto_conf_list                   : '80B5', // получить список автосоздаваемых каналов
        sc_adm_auto_conf_created                : '80B6', // успешно добавлена автосоздаваемая конференция. Админкоманда

        sc_txtch_update_modes                   : '80B7', // обновить режимы текстовой конференции

        sc_adm_bbs_msg_list                     : '80B9', // список сообщений на доске объявлений, админкоманда, массив объектов
        sc_adm_bbs_msg_data                     : '80BA', // подробные данные по сообщению на доске объявлений

        sc_adm_ad_users_imported                : '80BB', // список пользователей, которых импортировали из Active Directory
        sc_adm_ad_options                       : '80BC', // настройки по Active Directory интеграции

        sc_adm_update_packet_data               : '80BD', // данные по пакетам обновления для MyChat Client
        sc_adm_online_users_list                : '80BE', // список онлайн-пользователей, которые в данный момент подключены к MyChat Server. Массив объектов
        sc_adm_ad_users_list                    : '80BF', // список пользователей домена для импорта, массив объектов. Количество полей может быть переменным, в зависимости от того, указаны они для данного пользователя
                                      //                                      в домене, или нет. Заблокированные доменные пользователи специально не "вытаскиваются".

        sc_sync_private_history                 : '80C0', // данные для синхронизации истории сообщений в привате. Массив объектов

        sc_adm_script_data                      : '80C1', // запрошенный серверный скрипт со всеми данными
        sc_adm_all_script_states                : '80C2', // список скриптов со статусами, массив объектов
        sc_adm_script_checked                   : '80C3', // проверен синтаксис скрипта
        sc_adm_script_executed                  : '80C4', // скрипт выполнен по запросу, админкоманда
        sc_adm_script_created                   : '80C5', // новый серверный скрипт создан, админкоманда, ответ на 0114 cs_adm_script_create
        sc_adm_script_deleted                   : '80C6', // скрипт только что удалён успешно, пришёл список новых идентификаторов позиций для скриптов (если они есть, если нет - список пустой)
        sc_adm_script_saved                     : '80C7', // скрипт успешно сохранён, админкоманда
        sc_adm_script_log                       : '80C8', // добавить текстовую строчку в лог редактора скриптов

        sc_adm_active_conf_list                 : '80CC', // список работающих конференций, админкоманда, ответ на запрос 011B cs_adm_get_active_conf_list. Массив объектов
        sc_adm_conf_users_list                  : '80CD', // полный список пользователей конференции, админкоманда, ответ на запрос 011D cs_adm_get_users_in_conf. Массив объектов

        // ==== KANBAN ================================================

        sc_kanban_projects_list                 : '80C9', // список проектов kanban доски, массив объектов, ответ на 0117 cs_kanban_get_projects_list
        sc_kanban_stages_list                   : '80CA', // список этапов kanban-доски, массив объектов
        sc_kanban_tags_list                     : '80CB', // список тегов kanban-доски, ответ на 011A cs_kanban_get_tags_list
        sc_kanban_tasks_list                    : '80CE', // список задач kanban доски. Массив объектов
        sc_kanban_project_created               : '80D0', // новый проект kanban-доски успешно создан
        sc_kanban_stage_created                 : '80D1', // новый этап kanban-доски успешно создан
        sc_kanban_task_created                  : '80E1', // новый проект kanban-доски успешно создан
        sc_kanban_task_comment_added            : '80E2', // новый комментарий к задаче успешно добавлен
        sc_kanban_task_comments_list            : '80E3', // список комментариев к задаче на kanban доске, массив объектов
        sc_kanban_personal_options_list         : '80E5', // список персональных настроек клиента, JSON объект
        sc_kanban_event                         : '80E6', // kanban events
        sc_kanban_project_info                  : '80E7', // информация о kanban-проекте, ответ на запрос 014C cs_kanban_get_project_info
        sc_kanban_task_info                     : '80E8', // информация о задаче на kanban-доске, ответ на запрос 014D cs_kanban_get_task_info (5.21+)
        sc_kanban_last_performers_list          : '80EB', // список последних исполнителей задач на kanban-доске, ответ на запрос 0153 cs_kanban_get_last_performers, массив объектов
        sc_kanban_project_tags_list             : '80FE', // список тегов конкретного проекта
        sc_kanban_dashboard                     : '80FF', // краткая сводная информация по текущим задачам и проектам, массив объектов

        // ====================================================

        sc_personal_options_list                : '80E5', // список персональных настроек клиента, JSON объект

        sc_apply_client_settings                : '80DB', // применить клиентские настройки

        sc_adm_client_options_presets_list      : '80D8', // список шаблонов клиентских настроек, админкоманда, ответ на запрос 122C cs_adm_get_client_options_presets. Массив объектов
        sc_adm_client_options_preset_created    : '80D9', // набор настроек клиента успешно создан, ответ на команду 122E cs_adm_create_client_options_preset
        sc_adm_client_options_preset_updated    : '80DA', // набор настроек успешно отредактирован

        sc_adm_new_user_group_created           : '80DD', // уведомление о том, что новая группа пользователей успешно создана
        sc_adm_users_groups_list                : '80DE', // список групп пользователей, масив объектов
        sc_adm_group_users_list                 : '80DF', // список пользователей в группе, массив объектов

        sc_adm_integration_tool_options         : '80E0', // настройки интеграции инструмента (phpbb... etc.)
        sc_adm_get_check_domains_list           : '80E4', // список доменов с адресами, пользователи которых могут подключаться к серверу, массив объектов

        sc_adm_allowed_and_blocked_plugins      : '80E9', // список разрешённых и запрещённых клиентских плагинов
        sc_adm_script_info                      : '80EA', // краткая информация о скрипте, ответ на 0152 cs_adm_get_script_info

        // ==== FORUM ================================================

        sc_forum_structure                        : '80EF', // структура форума MyChat, ответ на запрос 0156 cs_forum_get_structure
        sc_forum_section_or_topic_created         : '80F0', // раздел форума или тема успешно создан
        sc_forum_post_created                     : '80F2', // сообщение в форуме успешно создано
        sc_forum_section_or_topic_changed         : '80F3', // раздел или тема форума успешно изменены
        sc_forum_section_or_topic_or_post_deleted : '80F4', // раздел, тема форума или сообщение успешно удалены
        sc_forum_post_changed                     : '80F5', // пост форума изменён
        sc_forum_topic_posts                      : '80F6', // список сообщений темы форума. Массив объектов
        sc_forum_section_info                     : '80F7', // информация о секции (список топиков, краткая информация о них: LastChange, UIN, DisplayName, Sex, Avatar, CountMessages). Массив объектов

        sc_broadcast_sent_ok                    : '8100', // оповещение успешно отправлено

        // ==========================================================

        sc_private_tech_message                 : '80EE', // специальное техническое сообщение в приватный разговор
        sc_command_complete                     : '80F1', // команда успешно выполнена
        sc_book_data                            : '80FB', // возвращает содержимое справочника в ответ на команду cs_get_book

        sc_file_exists                          : '80FC', // есть или нет файл с таким хэш-кодом на сервере
        sc_image_thumbs                         : '80FD', // уменьшенная копия изображения с сервера

        sc_token_created                        : '80ED', // создан токен для доступа к сервису чата

        sc_adm_backup_server_db_ok              : '8101', // резервная копия баз данных сервера успешно создана
        sc_hide_text_conf                       : '8102', // скрыть конференцию из списка доступных
        sc_adm_integration_telegram_users_list  : '8103', // список пользователей для интеграции с Telegram. Массив объектов
        sc_adm_integration_telegram_user_added  : '8104', // уведомление, только что добавлен новый мобильный юзер в таблицу Telegram-пользователей
        sc_removed_user_info                    : '8105', // краткая информация об удалённом пользователе
        sc_login_finish                         : '8106', // клиентское приложение успешно авторизовано на сервере и ему передана вся необходимая информация (права, join-ы в конференции и т.п.)

        sc_adm_history_info_private             : '8107', // админкоманда, информация по сообщениям в привате за диапазон времени, ответ на 0173 cs_adm_get_history_info_private
        sc_adm_history_private                  : '8108', // лог приватных сообщений двух пользователей по указанному диапазону индексов, админкоманда, ответ на 0174 cs_adm_get_history_private
        sc_adm_history_info_conf                : '8109', // админкоманда, информация по сообщениям в конференции за диапазон времени, ответ на 0175 cs_adm_get_history_info_conf
        sc_adm_history_conf                     : '810A', // лог приватных сообщений двух пользователей по указанному диапазону индексов, админкоманда, ответ на 0176 cs_adm_get_history_conf
        sc_adm_history_private_user_pairs       : '810B', // админкоманда, все пары приватных разговоров за все время, ответ на 0177 cs_adm_get_history_private_user_pairs

        sc_sync_conf_history                    : '810D', // данные для синхронизации истории сообщений в конференции
        sc_info                                 : '810E', //

        sc_adm_clear_console                    : '810F', // очистить консоль вывода данных в редакторе скриптов
        sc_adm_blocked_hwid_list                : '8110', // список заблокированных HardwareID адресов
        sc_adm_system_logs                      : '8111', // системные логи за период времени, ответ на 0182 cs_adm_get_system_logs

        sc_web_services_info                    : '8114', // информация о WEB-сервисах MyChat Server. Присылается, только если они перенастроены либо изменяются в данный момент
        sc_server_ports                         : '8115', // список сетевых портов MyChat сервер, отправляется клиенту, если меняются сетевые настройки MyChat Server

        sc_adm_domains_list                     : '8116', // список доменов, с которыми может работать сервер MyChat
        sc_adm_forum_subs_groups_list           : '8117', // список групп пользователей, которые подписаны на конкретную тему либо секцию
        sc_adm_forum_subs_users_list            : '8118', // список идентификаторов пользователей, которые подписаны на конкретную тему либо секцию

        sc_forum_subs                           : '8119', // список подписок на темы и разделы форума
        sc_custom_options                       : '811A', // кастомные настройки клиента, запрошенные с сервера командой cs_set_custom_options

        sc_adm_integration_quiz_check_question  : '811B', // проверка существования вопроса в базе робота-викторины
        sc_adm_integration_quiz_question_added  : '811C', // новый вопрос в базу робота-викторины добавлен успешно
        sc_adm_integration_quiz_stat            : '811D', // статистика робота-викторины

        sc_exec_func_result                     : '811E', // результат выполнения функции на сервере
        sc_users_live_search                    : '811F', // список пользователей на сервере по заданному шаблону, результат поиска команды 019A cs_users_live_search

        sc_private_dialogs                      : '8120', // список приватных диалогов пользователя, массив объектов, свежие - сначала
        sc_del_private_dialog                   : '8121', // удалить диалог с указанным юзером из списка приватных диалогов, уведомление об успешном удалении на сервере, рассылается всем пользователям-владельцам

        sc_private_read                         : '8122', // уведомление самому себе и всем инстансам себя (multilogin) о том, что указанное приватное сообщение прочитано
        sc_private_read_notify                  : '8123', // уведомление оппоненту, что его собеседник только что прочитал приватное сообщение с указанным индексом (и все приватные сообщения до него)
        sc_private_got                          : '8124', // уведомление самому себе и всем инстансам себя (multilogin) о том, что указанное приватное сообщение получено
        sc_private_got_notify                   : '8125', // уведомление оппоненту, что его собеседник только что получил приватное сообщение с указанным индексом (и все приватные сообщения до него)
        sc_private_dialog_msg_states            : '8126', // информация о полученных и прочитанных сообщениях в приватном диалоге с оппонентом

        sc_private_redirect_complete            : '8127', // диалог успешно передан, приват можно закрыть
        sc_users_list_for_redirect_dialog       : '8128', // список пользователей для редиректа

        // ==== Server -> Node =================================================

        sn_config                               : '1',
        sn_start                                : '2',
        sn_stop                                 : '3',
        sn_quit                                 : '4',
        sn_invite                               : '5',
        sn_iApi                                 : '6',
        sn_ip_filter                            : '7',
        sn_iApi_key                             : '8',
        sn_https_error                          : '9', 
        sn_rest_request                         : '10',
        sn_icq_connect                          : '11',
        sn_icq_send_message                     : '12',
        // sn_get_backup_path                      : '13',
        sn_info                                 : '14',
        sn_path_info                            : '15',
        sn_operators                            : '16',

        // ==== Node -> Server =================================================

        ns_started                              : '1001',
        ns_stopped                              : '1002',
        ns_bye                                  : '1003',
        ns_check_invite                         : '1004',
        ns_invite_sent                          : '1005',
        ns_integrationAPI                       : '1006',
        ns_ip_filter                            : '1007',
        ns_iApi_key                             : '1008',
        ns_https_error                          : '1009',
        ns_rest_request                         : '1010',
        ns_icq_connected                        : '1011',
        ns_icq_contact_list                     : '1012',
        ns_icq_send_message                     : '1013',
        ns_get_by_groups                        : '1015',
        ns_get_by_uins                          : '1016',

        // ==== Client Type ====================================================

        ClientType: {
            WIN32           : 'win32',
            FTP             : 'ftp',
            WEB_ADMIN       : 'admin',
            WEB_KANBAN      : 'kanban',
            WEB_CHAT        : 'web',
            WEB_SUPPORT     : 'websupport',
            COMMON          : 'common',
            INTEGRATION_API : 'integrationapi',
            WEB_FORUM       : 'forum',
            WIN32_NEXT      : 'win32next',
            MACOS           : 'macos',
            ANDROID         : 'android',
            LINUX           : 'linux',
            GUEST           : 'mcguest',
            ALL             : 'any',
            UNKNOWN         : 'unknown'
        },

        PrivateTask: {
            DEFAULT                  : 0,
            SEND_FILES               : 1,
            SEND_FILES_FROM_EXPLORER : 2,
            VOICE_CALL               : 3,
            VIDEO_CALL               : 4,
            MY_SCREEN_SHARING        : 5
        },

        serverLogLevel: {
            NOTHING         : 0, // ничего не логгировать
            SERVER_ERRORS   : 10, // серверные ошибки
            NETWORK_ERRORS  : 20, // сетевые ошибки
            SERVER_INFO     : 30, // информационные сообщения о работе сервера

            CONNECTIONS     : 800, // подключения и отключения пользователей
            NETWORK         : 900, // входящий трафик
            VERBOSE         : 1000 // полный трафик от сервера к клиентам и обратно
        },

        serverLogEvents: {
            MYCHAT_TRAFFIC_IN  : 1,
            MYCHAT_TRAFFIC_OUT : 2,
            ALL_INPUT_TRAFFIC  : 3
        },

        // ==== User Rights ====================================================

        RS: {
            QLogin: 1,                                            //"811":"Подключаться к MyChat серверу",
            QBBSPost: 2,                                          //"786":"Создание новых сообщений на доске",
            QBBSView: 3,                                          //"785":"Просмотр доски объявлений",
            QTxtChCreate: 4,                                      //"797":"Создание текстовых каналов",
            QTxtChSay: 5,                                         //"844":"Отправка сообщений в текстовые каналы",
            QTxtChJoin: 6,                                        //"796":"Вход в существующие текстовые каналы",
            QPrivateOpen: 7,                                      //"831":"Открытие новых приватов",
            QPrivatesGetMessages: 8,                              //"832":"Получение приватных сообщений от других пользователей",
            QUserDetailsChange: 9,                                //"837":"Изменение персонального профиля",
            QFilesSend: 10,                                        //"841":"Разрешить отправлять файлы другим пользователям",
            QFilesReceive: 11,                                    //"842":"Разрешить принимать файлы от других пользователей",
            QOperatorBan: 12,                                     //"821":"Право наказывать пользователей (ban)",
            QOperatorTurnOutFromChannel: 13,                      //"820":"Право изгнания пользователей из текстовых каналов (kick)",
            QKill: 14,                                            //
            QBlockIP: 15,                                         //
            QBlockMAC: 16,                                        //
            QOperatorTxtChTopicSet: 17,                           //"818":"Изменение темы текстовых каналов",
            QFTPPublic: 18,                                       //"840":"Доступ к общей папке на файловом сервере",
            QFTPPersonal: 19,                                     //"839":"Доступ к личной папке на файловом сервере",
            QRemoteAdm: 20,                                       //
            QOperatorClearChannelText: 21,                        //"819":"Очистка текстовых каналов у всех пользователей",
            QContactsListChange: 22,                              //"799":"Изменение персональной панели контактов",
            QBroadcasts: 23,                                      //"823":"Отправка оповещения другим пользователям",
            QAllowPersonalMsg: 24,                                //"794":"Отправка персональных сообщений в каналах",
            QAllowAlertMsg: 25,                                   //"795":"Отправка важных персональных сообщений в каналах",
            QAllowSysInfoView: 26,                                //"815":"Просмотр сетевого имени компьютера и IP-адреса пользователя",
            QSendImages: 27,                                      //"792":"Вставка изображений",
            QAllowIgnores: 28,                                    //"805":"Игнорирование других пользователей",
            QAllowInvites: 29,                                    //"810":"Отправка приглашений в каналы другим пользователям",
            QImagesPrivates: 30,                                  //"830":"Вставка изображений",
            QShowCommonContactsList: 31,                          //"800":"Показывать общий список контактов",
            QHalt: 32,
            QTxtChRename: 33,
            QTxtChDelete: 34,
            QForciblyInvites: 35,
            QBlockUIN: 36,
            QAllowPlugins: 37,                                    //"827":"Использование плагинов",
            QAllowOptionsChange: 38,                              //"806":"Изменение настроек клиентского приложения",
            QAllowMyFavoriteChannels: 39,                         //"793":"Доступ к ''Моим любимым каналам''",
            QAllowCloseProgram: 40,
            QAllowContactsListsTotal: 41,                         // разрешить или запретить полностью доступ к панели контактов
            QAllowAccountsManager: 42,                            // разрешить пользоваться менеджером учётных записей
            QWEBAllowViewLogsSelfPrivates: 43,                    // просмотр своих разговоров в приватах
            QWEBAllowViewLogsAllChannels: 44,                     // просмотр всех разговоров в каналах
            QWEBAllowViewLogsAllPrivates: 45,                     // просмотр всех разговоров в приватах
            QAllowFindUsersTool: 46,                              // разрешить поиск пользователей
            QAllowActions: 47,                                    // разрешить вставку в текст Action-ов
            QAllowClientLogPrivatesAndChannels: 48,               // разрешить или запретить клиенту писать логи локально, у себя на компьютере
            QMessengerStyle: 49,                                  // Messenger-style отображения майчат клиента
            QAllowOpenComputer: 50,                               // показывать или нет в меню опцию "Открыть компьютер" по щелчку на имени юзера
            QExceptionAllowRecievePrivates: 51,                   // Приём приватных сообщений от пользователей, которым запрещена отправка приватных сообщений
            QAllowViewRemoteUserMACAddress: 52,                   // разрешить смотреть MAC адрес удалённого юзера
            QAllowViewRemoteUserActiveProcess: 53,                // разрешить смотреть активный процесс удалённого юзера
            QWEBAllowViewFTPLog: 54,                              // Просмотр FTP протоколов
            QWEBAllowViewSystemLog: 55,                           // Просмотр системных протоколов
            QEnableTaskWorkersJobTimeControlSystem: 56,           // контроль рабочего времени
            QWEBSupportAllowAccess: 57,                           // доступ к WEB-интерфейсу веб-суппорта
            QWEBAllowAdmin: 58,                                   // администрирование сервере через WEB
            QAllowProgramBlockTool: 59,                           // Блокирование работающей программы паролем
            QAllowNetworkStatusChange: 60,                        // Изменение сетевого статуса
            QEnableAllowedClientsPluginsList: 61,                 // Активировать список разрешённых клиентских плагинов
            QEnableBlockedCLientsPluginsList: 62,                 // Активировать список запрещённых клиенских плагинов
            QEnablePluginsManagement: 63,                         // Разрешить управление плагинами на клиенте
            QAllowImagesInBroadcasts: 64,                         // вставка картинок в оповещениях
            QEnableFontLayoutsInMessages: 65,                     // использование шрифтовой разметки в отправляемых сообщениях
            QAllowCreateHiddenChannels: 66,                       // - (это ещё не внесено в базу данных) разрешить создавать скрытые каналы
            QEnableTransferFilesOnlyViaServer: 67,                // передавать файлы только через сервер
            QEnableImmunityFromBans: 68,                          // иммунитет от банов
            QEnableAdvertBlock: 69,                               // показывать или нет рекламный блок
            QBlockPrivatesExceptPersonalContacts: 70,             // Запретить приваты со всеми, кроме входящих в личный список контактов
            QBlockPrivatesExceptCommonContacts: 71,               // Запретить приваты со всеми, кроме входящих в общий список контактов
            QEnableImmunityFromIgnores: 72,                       // Иммунитет от игноров
            QIntegrationAPIEnableSendMsgFromAnyUser: 73,          // Разрешить отправку сообщений от имени этих пользователей
            QEnableVoiceCalls: 74,                                // Голосовые звонки
            QEnableVideoCalls: 75,                                // Видеозвонки
            QAllowGetVoiceCalls: 76,                              // Разрешить получать голосовые звонки
            QAllowGetVideoCalls: 77,                              // Разрешить получать видеозвонки
            QAllowAddNewPlugins: 78,                              // Добавление новых плагинов
            QAllowDeletePlugins: 79,                              // Удаление плагинов
            QAllowChangeAccountPassword: 80,                      // Изменение пароля своей учётной записи
            QAllowAccessForeignersToPersonalFiles: 81,            // Разрешить доступ к личным файлам для других пользователей ("только чтение")
            QAllowPublishLinkToPersonalFiles: 82,                 // Разрешить публиковать ссылку на "Мои файлы на сервере"
            QFTPPublicWrite: 83,                                  // разрешить писать в общую папку
            QFTPPersonalWrite: 84,                                // разрешить писать в личную папку
            QAllowSendInvites: 85,                                // разрешить отправлять приглашения в MyChat другим людям
            QWEBAllowViewNodeJSLogs: 86,                          // разрешить просмотр логов NodeJS сервера
            QWEBAllowViewAuditLogs: 87,                           // разрешить просмотр логов аудита

            QKanbanAccess: 134,                                   // доступ к Kanban
            QCommonAllowMainMenu: 144,                            // главное меню программы
            QCommonAllowDialogs: 145,                             // панель диалогов

            QForumAccess: 146,                                    // доступ ко встроенному форуму
            QForumCreateSections: 147,                            // форум, "Можно создавать новые разделы"
            QForumChangeSections: 148,                            // форум, "Изменение разделов (удаление, переименование, перенос)"
            QForumCreateTopics: 149,                              // форум, "Можно создавать новые темы"
            QForumChangeTopics: 150,                              // форум, "Изменение тем (удаление, переименование, перенос)"
            QForumCreatePosts: 151,                               // форум, "Можно создавать новые сообщения"
            QForumChangePosts: 152,                               // форум, "Изменение сообщений (удаление, модификация, перенос)"
            QForumChangeSelfPosts: 153,                           // форум, "Изменение собственных сообщений (удаление, модификация, перенос)"

            QForumDeleteSections: 154,                            // форум, "Удаление секций"
            QForumDeleteTopics: 155,                              // форум, "Удаление тем"
            QForumDeletePosts: 156,                               // форум, "Удаление сообщений"
            QForumDeleteSelfPosts: 157,                           // форум, "Удаление собственных сообщений"
            QBroadcastsOnlyInMyGroups: 158,                       // оповещения, "Отправка оповещений только в пределах своих групп пользователей"
            QTxtChViewHidden : 159,                               // Конференции, "Просмотр скрытых конференций"
            QICQAccess: 160,                                      // "Интеграция с ICQ", "Доступ к ICQ"
            QTxtConfSendFiles: 161,                               // "Конференции", "Вставка файлов"
            QPrivSendMessages: 162,                               // "Приваты", "Отправка сообщений"
            QPrivInsertFiles: 163,                                // "Приваты", "Вставка файлов"
            QAllowRemoveConfMessages: 164,                        // "Администрирование", "Удаление любых сообщений в конференциях"
            QAdmAccessToRemoveConfMessages: 165,                  // "админка", "Инструменты", "Просмотр протоколов", Удаление сообщений из протоколов конференций
            QAllowViewHistoryTool: 166,                           // Просмотр истории сообщений
            QAllowViewRemoteUserProfile: 174,                     //  "Профиль", "Просмотр профилей других пользователей"
            QAllowFilterHardware: 175,
            QAllowSettingsFolders: 176,
            
            QAdmAccessLicensesWipe: 177,                          // админка, "Доступ к функциям управления сервером", "Лицензии", "Очистка данных"
            QAdmToolWipe: 178,                                    // админка, доступ к инструменту "Очистка данных"
            QEnableScreenSharing: 179,                            // "Приваты", Трансляция экрана
            QAllowGetScreenSharing: 180,                          // "Приваты", Разрешить получать трансляции экрана
            
            QForumChangeTopicsColor : 181,                        // "Форум", "Изменение цвета для тем"
            QForumSubsNotify        : 182,                        // "Форум", "Подписка/отписка на уведомления в секциях и темах"
            QForumInsertImages      : 183,                        // "Форум", "Вставка изображений в сообщениях"
            QForumInsertFiles       : 184,                        // "Форум", "Вставка файлов в сообщениях"

            QKanbanAddTask          : 186,                        // "Kanban", "Добавление заданий"
            QAdmAccessLicensesQuiz  : 187,                        // админка, "Доступ к функциям управления сервером", "Лицензии", "MyChat викторина"
            QAdmAccessToRemovePrivMessages  : 188,                // "админка", "Инструменты", "Просмотр протоколов", Удаление приватных сообщений из протоколов"
            QCommonAllowScreenshotTool      : 189,                // Отправка снимка экрана в чат
            QAllowRemovePrivateMessages     : 190,                // Удаление любых сообщений в приватах
            QCommonAllowQuickMessages       : 191,                // "Быстрые" сообщения
            QAllowRedirectDialogs           : 192                 // Перенаправление диалогов
        },

        // =====================================================================

        msgType: {
             OLD_SHIT            : 0,
             TEXT                : 1,
            IMAGE               : 2,
            BEEP                : 3,
            OLD_FILE            : 4,
            MARKDOWN            : 5,
            ACTION              : 6,
            LAN_LINK            : 7,
            ANY_LINK            : 8,
            PREVIEW_CUSTOM_LINK : 9,
             INTEGRATION_API     : 10,
            SOURCE_CODE         : 11,
            MEDIA_CALL          : 12,
            IGNORE              : 13,
            SERVICE             : 14,
            CONF_PERSONAL       : 15,
            CONF_ALERT          : 16,
            CONF_CHANGE_TOPIC   : 17,
            CONF_BAN            : 18,
            CONF_TURN_OUT       : 19,
            BROADCAST_NOTIFY    : 20,
            COMMENT             : 21, // simple text, not shown in WEB support (for homemedhelp)
             KANBAN_NOTIFY       : 22, // уведомления с канбан-доски
            FILE                : 23,
            LOCATION            : 24, // географическая позиция
            CONTACT             : 25, // vCard
            AUDIO               : 26, // аудиозапись
            VIDEO               : 27, // видеозапись
            ADM_DELETE_MESSAGE  : 28, // удаление любого сообщения по его индексу
             FORUM_NOTIFY       : 29, // уведомления с форума
            SHOW_RECEIVED_FILES : 'srf', //
            SHOW_UPLOADED_FILES : 'suf', //
            PRIVATE_REDIRECT    : 30 // перенаправление приватного сообщения от одного пользователя - другому
        },
        
        msgClientType: {
            WIN32   : 0,
            WEB     : 1,
            MACOS   : 2,
            LINUX   : 3,
            ANDROID : 4
        },

        loginStyle: {
            STANDARD       : '0',
            AD             : '1',
            NO_PASS        : '2',
            AD_TRANSPARENT : '3'
        },

        msgMods: {
            NONE     : 0,
            MODIFIED : 1,
            DELETED  : 2
        },

        Errors: {
            WrongPassword       : 14,
            UserNotExist        : 17,
            WrongServerVersion  : 81,
            NetworkError        : 224,
            Disconnected        : 223,
            
            '---' : '---'
        },
        
        nsInternalErrors: {
            TELEGRAM_SCRIPT_NOT_FOUND      : 1,
            TELEGRAM_SCRIPT_DISABLED       : 2,
            INVALID_SCRIPT_RESULT          : 3,
            SCRIPT_TIMED_OUT               : 4,
            SCRIPT_SYNTAX                  : 5,
            SCRIPT_RUNTIME                 : 6,
            SCRIPT_NO_ONREQUESTBYREST      : 7,
            SCRIPT_INVALID_ONREQUESTBYREST : 8
        },

        updateConsoleCMD : "--updateClient",
        normalStart      : "--start",

        _last_: '_last_' // просто, шоб було
        // ==========================================
    };
});

/*
 // ==== Client => Electron =============================================

 ce_get_server_list         : '7001', // найти сервера чата в локальной сети
     ce_test_server_ip          : '7002', // тест IP адреса
     ce_set_language            : '7003', //
     ce_modify_server           : '7004', // обновление сервера
     ce_add_server              : '7005', // добавление сервера
     ce_del_server              : '7006', // удаление сервера
     ce_quit_from_program       : '7007', //
     ce_get_client_settings     : '7008', //
     ce_set_client_settings_mydata : '7009', // сохранение настроек в базу
     ce_hide_program            : '700A', // спрятать окно чата в трей
     ce_show_notify             : '700B', // show notify
     ce_save_autoconnect_server : '700C', // сохраняем ид сервера к которому нужно подключаться и рароль пользователя + сервера
     ce_load_autoconnect_server : '700D', // вычитать информацию про сервер к которому нужно подключаться
     ce_hide_or_close_by_x      : '700E', // прятать или закрывать программу по нажатию на крестик окна
     ce_storage_get             : '700F', // получение значения storage у пользователя uin с индексом сервера srv
     ce_storage_save            : '7010', // добавление/обновление новых данный в storage
     ce_storage_remove          : '7011', // удаление данных из storage
     ce_open_internal_url       : '7012', // открыть адрес со своего сервера

     ce_statistics_get          : '7013', // получение данных статистики
     ce_statistics_save         : '7014', // сохранение статистики
     ce_get_mc_client_info      : '7015', // получение системной информации про клиент чата

     // ==== Electron => Client =============================================

     ec_get_server_list         : '9001', // список серверов чата в локальной сети
     ec_test_server_ip          : '9002', // ответ теста адреса
     ec_complete_command        : '9003', // подтверждение выполнение команды
     ec_server_added            : '9004', // сервер добавлен, возвращает его id
     ec_error                   : '9005', // возникла ошибка
     ec_server_saved            : '9006', // была изменена информация про сервер
     ec_get_client_settings     : '9007', //
     ec_load_autoconnect_server : '9008', // получить инфо по автосерверу
     ec_open_dialog             : '9009', // открыть приват или конференцию, сейчас вызывается по лику на трей-нотифай
     ec_storage_get             : '900A', // получение данных из storage

     ec_statistics_get          : '900B', // данные статистики
     ec_get_mc_client_info      : '900C', //

     // ==== electron errors=================================================

     errElectron : {
     eDuplicateServer : 1, // возникает при добавлении сервера, когда уже есть сервера с такой парой адреса и порта
         eUnknownServerID : 2  // передан неизвестный ИД сервера для сохранения
 },
*/

;(function(factory) {
    if (typeof exports === 'object') {
        exports.ECMD = factory();
    } else
    if (window){
        var ecmd = factory();

        if (window.mcConst && window.mcConst._CMD_){
            Object.keys(ecmd).forEach(function (cmd) {
                window.mcConst._CMD_[cmd] = ecmd[cmd];
            });
        } else {
            window._ECMD_ = ecmd;
        }
    }
})(function() {
    "use strict";

    return {
        // ==== Client => Electron =============================================

        ce_get_server_list         : '7001', // найти сервера чата в локальной сети
        ce_test_server_ip          : '7002', // тест IP адреса
        ce_set_language            : '7003', //
        ce_modify_server           : '7004', // обновление сервера
        ce_add_server              : '7005', // добавление сервера
        ce_del_server              : '7006', // удаление сервера
        ce_quit_from_program       : '7007', //
        ce_get_client_settings     : '7008', //
        ce_set_client_settings     : '7009', // сохранение настроек в базу
        ce_hide_program            : '700A', // спрятать окно чата в трей
        ce_show_notify             : '700B', // show notify
        ce_save_autoconnect_server : '700C', // сохраняем ид сервера к которому нужно подключаться и рароль пользователя + сервера
        ce_load_autoconnect_server : '700D', // вычитать информацию про сервер к которому нужно подключаться
        ce_hide_or_close_by_x      : '700E', // прятать или закрывать программу по нажатию на крестик окна
        ce_storage_get             : '700F', // получение значения storage у пользователя uin с индексом сервера srv
        ce_storage_save            : '7010', // добавление/обновление новых данный в storage
        ce_storage_remove          : '7011', // удаление данных из storage
        ce_open_internal_url       : '7012', // открыть адрес со своего сервера

        ce_statistics_get          : '7013', // получение данных статистики
        ce_statistics_save         : '7014', // сохранение статистики
        ce_get_mc_client_info      : '7015', // получение системной информации про клиент чата

        ce_break_blink             : '7016', // убираем мигающий конвертик с трея
        ce_show_on_top             : '7017', // пришло новое сообщение BBS

        ce_ftp_login               : '7018', // ftp
        ce_ftp_quit                : '7019', //
        ce_ftp_list                : '701A', // получить список файлов FTP каталога
        ce_ftp_download            : '701B', //
        ce_ftp_upload              : '701C', //

        ce_console_log             : '701E', //

        ce_file_download_abort     : '701D', //
        ce_file_upload_abort       : '701F', //
        ce_file_upload_start       : '7020', //
        ce_file_upload_prepare_abort:'7021', // abort sha1 calc
        ce_file_check_exist        : '7023', // отправляется после ec_check_file_exist
        ce_file_download_url       : '7025', // handleRedirect

        ce_get_clipboard_files_list: '7022', //
        ce_hide_window             : '7024', //

        ce_file_open_in_folder     : '7026', //
        ce_file_open_or_download   : '7028', //

        ce_special_link_user_info  : '7027', // отправляется данные про пользователя, по чьей ссылке мы кликнули в чатя, для скачивания файла

        ce_history_get_dialogs     : '7029', //
        ce_history_set_dialogs     : '702A', //
        ce_history_remove_dialogs  : '702B', //

        ce_file_direct_upload_start     : '702C', //
        ce_file_direct_upload_abort     : '702D', //
        ce_file_direct_upload_complete  : '702E', //
        ce_file_direct_upload_prepare   : '702F', //

        ce_get_logs_list           : '7030', //
        ce_get_user_folder         : '7031', //

        ce_file_set_new_folder_for_user : '7032', //

        ce_file_direct_receive_start    : '7033', //

        ce_stop_ftp_server         : '7034', //
        ce_remove_ftp_user         : '7035', //

        ce_file_open_folder        : '7036', //

        ce_get_logs_files          : '7037', //
        ce_toggle_min_max          : '7038', //
        ce_toggle_kiosk            : '7039', //

        ce_web_services_info       : '703A', //
        ce_client_disconnected     : '703B', //
        ce_server_ports            : '703C', //
        ce_disable_always_on_top   : '703D', //
        ce_restart_client          : '703E', //

        ce_start_ftp_server        : '703F', //
        ce_client_connected        : '7040', //

        // ==== Electron => Client =============================================

        ec_get_server_list         : '9001', // список серверов чата в локальной сети
        ec_test_server_ip          : '9002', // ответ теста адреса
        ec_complete_command        : '9003', // подтверждение выполнение команды
        ec_server_added            : '9004', // сервер добавлен, возвращает его id
        ec_error                   : '9005', // возникла ошибка
        ec_server_saved            : '9006', // была изменена информация про сервер
        ec_get_client_settings     : '9007', //
        ec_load_autoconnect_server : '9008', // получить инфо по автосерверу
        ec_open_dialog             : '9009', // открыть приват или конференцию, сейчас вызывается по лику на трей-нотифай
        ec_storage_get             : '900A', // получение данных из storage

        ec_statistics_get          : '900B', // данные статистики
        ec_get_mc_client_info      : '900C', //

        ec_open_local_kanban       : '900D', // был переход по ссылке на канбан

        ec_ftp_login               : '900E', //
        ec_ftp_error               : '900F', //
        ec_ftp_uploaded            : '9010', //
        ec_ftp_list                : '9011', //
        ec_ftp_progress            : '9012', //

        ec_get_clipboard_files_list: '9019', //

        ec_file_download_start     : '9017', //
        ec_file_download_progress  : '9013', //
        ec_file_download_complete  : '9015', //
        ec_file_download_aborted   : '9018', //

        ec_file_upload_start       : '9020', //
        ec_file_upload_progress    : '9014', //
        ec_file_upload_complete    : '9016', //
        ec_file_upload_aborted     : '9021', //

        ec_file_upload_prepare_start   : '9024', //
        ec_file_upload_prepare_progress: '9022', //

        ec_file_check_exist        : '9025', //

        ec_mainWindowFocused       : '9026', //
        ec_history_get_dialogs     : '9027', //

        ec_file_direct_upload_start     : '9028', //
        ec_file_direct_upload_aborted   : '9029', //
        ec_file_direct_upload_progress  : '902A', //
        ec_file_direct_upload_complete  : '902B', //

        ec_get_logs_list           : '902C', //
        ec_drop_connect            : '902D', //

        ec_file_direct_upload_no_files  : '902E', //
        ec_get_user_folder              : '902F', //

        ec_file_set_new_folder_for_user : '9030', //
        ec_file_direct_receive_start    : '9031', //
        ec_file_direct_receive_client_disconnected : '9032', //

        ec_get_logs_files           : '9033', //
        ec_system_suspend           : '9034', //
        ec_system_resume            : '9035', //
        ec_download_update          : '9036', //

        ec_mainWindowBlur           : '9037', //

        ec_file_download_file_no_found  : '9038',

        // ==== electron errors=================================================

        errElectron : {
            eDuplicateServer : 1, // возникает при добавлении сервера, когда уже есть сервера с такой парой адреса и порта
            eUnknownServerID : 2, // передан неизвестный ИД сервера для сохранения
            eFtpNotConnected : 3, // нет FTP подключения
            eFtpError        : 4,
            eFileDownload    : 5,
            eFileUpload      : 6
        },

        _last_ : '---'
    }
});

window.JS_SHA1_NO_COMMON_JS = true;

var mcConst = {
    Title : "MyChat",
    LMSG  : [],
    _CMD_ : window.hasOwnProperty('getCMD') ? getCMD() : {},
    countHistoryMessagesLoad: 45,
    minChatFrameWidth : 300,

    isWindowFocused: true,

    socketIO : null,
    
    ClientSettings: {},

    changeProtocol: location.protocol,

    nodePathes: {
        images: "sendimages",
        files : "files"
    },

    imageSize: {
        small : {
            x: 120,
            y: 120,
            xy: '120x120'
        },
        medium: {
            x: 150,
            y: 150,
            xy: '150x150'
        },
        big   : {
            x: 200,
            y: 200,
            xy: '200x200'
        },
        "0"   : {
            x: 120,
            y: 120,
            xy: '120x120'
        },
        "1"   : {
            x: 150,
            y: 150,
            xy: '150x150'
        },
        "2"   : {
            x: 200,
            y: 200,
            xy: '200x200'
        }
    },

    loadGif : "<img src='source/images/loading.gif'>",

    reconnectTime : 5000,

    lockPrevHotKeys: true,

    maxAvailableDate: '01.01.3000.00.00.00',
    neverDate: '01.01.1900.00.00.00',

    storageOpts: {
        OPENUSERS : 'openUsers-',
        SEQUENCE  : 'sequence-',
        STATUSICO : 'statusU-',
        DIALOGOPT : 'dialogOpt-',
        WRAPOPTS  : 'wrapOpts-',
        INPUTOPTS : 'inputOpts-',
        HISTORYDLG: 'historyDialogs-',
        CURRENTITM: 'currentItem-',

        // -------

        cUserOpt : 'cUserOpt-'
    },

    Lang : "ru",

    containers: {
        left   : "wrapperLeft",
        center : "wrapperCenter",
        right  : "wrapperRight"
    },

    lockInterface : 'lockInterface',

    mirrorStreamName : 'mirrorStreamName',
    videoStreamName  : 'videoStreamName',
    audioStreamName  : 'audioStreamName',
    videoContainer   : 'videoFrameContainer',

    storageFields: {
        lang    : 'cliLang',
        Login   : "cliLogin",
        Pwd     : "cliPwd",
        ServPwd : "cliServPwd",
        Rm      : "cliRm",
        AutoRld : "cliNoAutoConnect"
    },

    userFields : 'REMOTECLIENTTYPE,REMOTEINTERFACESLIST,LASTACCESS,LASTSPEAKTIME,STATE,TAG,HARDWAREID,DOMAIN,' +
                 'DOMAINREGTIME,DOMAINCHANGETIME,VER,UTC,REPUTATION,NICK,DISPLAYNAME,EMAIL,GROUPRIGHTS,COMPNETNAME,' +
                 'IP,MAC,UIN,ACTIVE,REGISTERED,WORKDEPT,TEAMLEAD', //

    dataModels : {
        Login            : 'Login',
        Main             : 'Main',
        ChatWrapper      : 'ChatWrapper',
        ChatFrame        : 'ChatFrame',
        ConfUserList     : 'ConfUserList',
        UserProfile      : 'UserProfile',
        Files            : 'Files',
        CommonContacts   : 'CommonContacts',
        PersonalContacts : 'PersonalContacts',
        Dialogs          : 'Dialogs',
        PrivateConfs     : 'PrivateConfs',
        PrivateInfo      : 'PrivateInfo',
        ServerManager    : 'ServerManager',
        ConfManager      : 'ConfManager',
        MainMenu         : 'MainMenu',
        Kanban           : 'Kanban',
        BBS              : 'BBS',
        CommonFiles      : 'CommonFiles',
        HistoryDialogs   : 'HistoryDialogs',
        ViewLogs         : 'ViewLogs',
        ReceiveFiles     : 'ReceiveFiles',
        Settings         : 'Settings',
        Broadcast        : 'Broadcast',
        Update           : 'Update',
        Forum            : "Forum",

        History          : 'History'
    },

    sexIcon : {
        0: "<span class='fa fa-user'></span>",
        1: "<span class='fa fa-male'></span>",
        2: "<span class='fa fa-female'></span>"
    },

    imagesPath : {
        noFilter   : 'source/images/nofilter20.png',
        loading    : 'source/images/loading.gif',
        all        : 'source/images/',
        flags      : 'source/images/flags/',
        loadImage  : 'source/images/loadimg.gif',
        nofile     : 'source/images/nofile.gif'
    },

    pathAliases : {
        AliasAdmin    : "admin", // папка-псевдоним, путь к админке
        AliasAPI      : "API", // папка-псевдоним, путь к Integration API
        AliasChat     : "chat", // папка-псевдоним, путь к WEB-чату
        AliasFiles    : "files", // папка-псевдоним, путь к файлам, залитым на сервер
        AliasForum    : "forum", // папка-псевдоним, путь ко встроенному форуму
        AliasKanban   : "kanban", // папка-псевдоним, путь к канбан-доске
        
        LobbyEnable   : true, // включен доступ к списку сервисов MyChat
        ForumEnable   : true, // включить доступ ко встроенному форуму
        KanbanEnable  : true, // включить доступ к канбан-доске
        ChatEnable    : true, // включить доступ к WEB-чату
        AdminEnable   : true // включить доступ к WEB-админке
    },

    whereFiles: {
        private: 1,
        conf   : 2,
        forum  : 3,
        kanban : 4,
        bbs    : 5,
        broadc : 6
    },

    states: {
        offline    : -1,
        online     : 0,
        away       : 1,
        dnd        : 2,
        webOnline  : 3
    },

    currentState: 0,

    LicenseInfo : {
        "ServerRegisteredBy"      : "Network Software Solutions", // на кого зарегистрирован сервер
        "IsFree"                  : false,                        // (5.7+) если сервер бесплатный, то true, иначе - false
        "IsMyChatGuestRegistered" : false                          // зарегистрирован ли сервис MyChat Guest
    },

    customLogin : false,

    lockWindowHeight : 80,

    ApplyPanelShowed : false,

    errMessageExpire : 5000,

    guestGroupId : 7,

    userFoto : {
        w : 135,
        h : 157
    },

    CRLF : '\r\n',
    CR   : '\r',
    LF   : '\n',

    ignores: {
        all          : "all", //- игнорировать всё
        confs        : "confs", //- сообщения в конференциях
        confpersonal : "confpersonal", //- личные сообщения в конференциях
        confalert    : "confalert", //- личные важные сообщения в конференциях
        private      : "private", //- приватные сообщения
        privatebeep  : "privatebeep", //- звуковые сигналы в привате
        info         : "info", //- запросы персональной информации о пользователе
        files        : "files", //- отправка файлов
        plugins      : "plugins" //- запросы плагинов
    },

    MyRightsSet : [
      /*
        + {1}   QLogin, "811":"Подключаться к MyChat серверу",
        + {2}   QBBSPost, "786":"Создание новых сообщений на доске",
        + {3}   QBBSView, "785":"Просмотр доски объявлений",
        + {4}   QTxtChCreate, "797":"Создание текстовых каналов",
        + {5}   QTxtChSay, "844":"Отправка сообщений в текстовые каналы",
        + {6}   QTxtChJoin, "796":"Вход в существующие текстовые каналы",
        + {7}   QPrivateOpen, "831":"Открытие новых приватов",
        + {8}   QPrivatesGetMessages, "832":"Получение приватных сообщений от других пользователей",
        + {9}   QUserDetailsChange, "837":"Изменение персонального профиля",
        + {10}  QFilesSend, "841":"Разрешить отправлять файлы другим пользователям",
        + {11}  QFilesReceive, "842":"Разрешить принимать файлы от других пользователей",
        + {12}  QOperatorBan, "821":"Право наказывать пользователей (ban)",
        + {13}  QOperatorTurnOutFromChannel, "820":"Право изгнания пользователей из текстовых каналов (kick)",
        + {14}  QKill,
        + {15}  QBlockIP,
        + {16}  QBlockMAC,
        + {17}  QOperatorTxtChTopicSet, "818":"Изменение темы текстовых каналов",
        + {18}  QFTPPublic, "840":"Доступ к общей папке на файловом сервере",
        + {19}  QFTPPersonal, "839":"Доступ к личной папке на файловом сервере",
        + {20}  QRemoteAdm,
        + {21}  QOperatorClearChannelText, "819":"Очистка текстовых каналов у всех пользователей",
        + {22}  QContactsListChange, "799":"Изменение персональной панели контактов",
        + {23}  QBroadcasts, "823":"Отправка оповещения другим пользователям",
        + {24}  QAllowPersonalMsg, "794":"Отправка персональных сообщений в каналах",
        + {25}  QAllowAlertMsg, "795":"Отправка важных персональных сообщений в каналах",
        + {26}  QAllowSysInfoView, "815":"Просмотр сетевого имени компьютера и IP-адреса пользователя",
        + {27}  QSendImages, "792":"Вставка изображений",
        + {28}  QAllowIgnores, "805":"Игнорирование других пользователей",
        + {29}  QAllowInvites, "810":"Отправка приглашений в каналы другим пользователям",
        + {30}  QImagesPrivates, "830":"Вставка изображений",
        + {31}  QShowCommonContactsList, "800":"Показывать общий список контактов",
        + {32}  QHalt,
        + {33}  QTxtChRename,
        + {34}  QTxtChDelete,
        + {35}  QForciblyInvites,
        + {36}  QBlockUIN,
        + {37}  QAllowPlugins, "827":"Использование плагинов",
        + {38}  QAllowOptionsChange, "806":"Изменение настроек клиентского приложения",
        + {39}  QAllowMyFavoriteChannels, "793":"Доступ к ''Моим любимым каналам''",
        + {40}  QAllowCloseProgram,
        + {41}  QAllowContactsListsTotal,                         // разрешить или запретить полностью доступ к панели контактов
        + {42}  QAllowAccountsManager,                            // разрешить пользоваться менеджером учётных записей
        + {43}  QWEBAllowViewLogsSelfPrivates,                    // просмотр своих разговоров в приватах
        + {44}  QWEBAllowViewLogsAllChannels,                     // просмотр всех разговоров в каналах
        + {45}  QWEBAllowViewLogsAllPrivates,                     // просмотр всех разговоров в приватах
        + {46}  QAllowFindUsersTool,                              // разрешить поиск пользователей
        + {47}  QAllowActions,                                    // разрешить вставку в текст Action-ов
        + {48}  QAllowClientLogPrivatesAndChannels,               // разрешить или запретить клиенту писать логи локально, у себя на компьютере
        + {49}  QMessengerStyle,                                  // Messenger-style отображения майчат клиента
        + {50}  QAllowOpenComputer,                               // показывать или нет в меню опцию "Открыть компьютер" по щелчку на имени юзера
        + {51}  QExceptionAllowRecievePrivates,                   // Приём приватных сообщений от пользователей, которым запрещена отправка приватных сообщений
        + {52}  QAllowViewRemoteUserMACAddress,                   // разрешить смотреть MAC адрес удалённого юзера
        + {53}  QAllowViewRemoteUserActiveProcess,                // разрешить смотреть активный процесс удалённого юзера
        + {54}  QWEBAllowViewFTPLog,                              // Просмотр FTP протоколов
        + {55}  QWEBAllowViewSystemLog,                           // Просмотр системных протоколов
        + {56}  QEnableTaskWorkersJobTimeControlSystem,           // контроль рабочего времени
        + {57}  QWEBSupportAllowAccess,                           // доступ к WEB-интерфейсу веб-суппорта
        + {58}  QWEBAllowAdmin,                                   // администрирование сервере через WEB
        + {59}  QAllowProgramBlockTool,                           // Блокирование работающей программы паролем
        + {60}  QAllowNetworkStatusChange,                        // Изменение сетевого статуса
        + {61}  QEnableAllowedClientsPluginsList,                 // Активировать список разрешённых клиентских плагинов
        + {62}: QEnableBlockedCLientsPluginsList,                 // Активировать список запрещённых клиенских плагино,
        + {63}  QEnablePluginsManagement,                         // Разрешить управление плагинами на клиенте
        + {64}  QAllowImagesInBroadcasts,                         // вставка картинок в оповещениях
        + {65}  QEnableFontLayoutsInMessages,                     // использование шрифтовой разметки в отправляемых сообщениях
          {66}  QAllowCreateHiddenChannels,                       // - (это ещё не внесено в базу данных) разрешить создавать скрытые каналы
        + {67}  QEnableTransferFilesOnlyViaServer,                // передавать файлы только через сервер
        + {68}  QEnableImmunityFromBans,                          // иммунитет от банов
        + {69}  QEnableAdvertBlock                                // показывать или нет рекламный блок
        + {70}  QBlockPrivatesExceptPersonalContacts,             // Запретить приваты со всеми, кроме входящих в личный список контактов
        + {71}  QBlockPrivatesExceptCommonContacts,               // Запретить приваты со всеми, кроме входящих в общий список контактов
        + {72}  QEnableImmunityFromIgnores,                       // Иммунитет от игноров
        + {73}  QIntegrationAPIEnableSendMsgFromAnyUser,          // Разрешить отправку сообщений от имени этих пользователей
        + {74}  QEnableVoiceCalls,                                // Голосовые звонки
        + {75}  QEnableVideoCalls,                                // Видеозвонки
        + {76}  QAllowGetVoiceCalls,                              // Разрешить получать голосовые звонки
        + {77}  QAllowGetVideoCalls,                              // Разрешить получать видеозвонки
        + {78}  QAllowAddNewPlugins,                              // Добавление новых плагинов
        + {79}  QAllowDeletePlugins,                              // Удаление плагинов
        + {80}  QAllowChangeAccountPassword,                      // Изменение пароля своей учётной записи
        + {81}  QAllowAccessForeignersToPersonalFiles,            // Разрешить доступ к личным файлам для других пользователей ("только чтение")
        + {82}  QAllowPublishLinkToPersonalFiles,                 // Разрешить публиковать ссылку на "Мои файлы на сервере"
        + {83}  QFTPPublicWrite,                                  // разрешить писать в общую папку
        + {84}  QFTPPersonalWrite                                 // разрешить писать в личную папку
        + {85}  QAllowSendInvites                                 // разрешить отправлять приглашения в MyChat другим людям
        + {86}  QWEBAllowViewNodeJSLogs,                          // разрешить просмотр логов NodeJS сервера
        + {87}  QWEBAllowViewAuditLogs                            // разрешить просмотр логов аудита
      */
    ],

    LoginInfo : {
        login   : "",
        pwd     : "",
        servPwd : "",
        rm      : ""
    },

    Auth      : '',
    PWD       : '',
    servPass  : '',

    BrowserID : '',
    SessionID : '',

    LoggedIn  : false,
    nowLogin  : false,

    terminator       : '\u2022',
    terminator2      : '\u0002',
    terminator3      : '\u0003',
    newLine          : '\u000b',

    myChatLinkTitle  : "?specialMyChatLinkTitle=",

    PingTimer        : null,
    PingInterval     : 200,

    mcPara           : "L$",
    mcParaRight      : "R#$",
    mcParaCenter     : "C#$",

    UserInfo   : {                       // информация о залогиненом юзере
        "UIN"             : 0,           // UIN пользователя, который залогинен в системе
        "Nick"            : "Anonymous", // ник пользователя, который сообщил ему сервер
        "Sex"             : 1,           // пол пользователя
        "Avatar"          : 0,           // номер аватара пользователя
        "Status"          : 0,
        "LoginStyle"      : "login",     // тип логина: "login" - обычный логин, "domain" - доменная авторизация
        "AutoAwayTime"    : 15,          // время в минутах, после которого будет считаться, что пользователь неактивен
                                         // за компьютером, если он не нажимал ничего на клавиатуре и не шевелил мышкой
        "ServerSignature" : "",          // специальная сигнатура сервера MyChat, нужна для системы статистики
        "HWID"            : "",          // серийник сервера
        "Domain"          : "domain"     // если доменная авторизация, "LoginStyle" = "domain", то в этом параметре
                                         // передаётся ещё и имя домена, с которого проходит аторизация.
                                         // Если доменной авторизации нет - этот параметр не передаётся
    },

    ErrorText  : {},
    SrvErrorText: {},

    CanDisplayNotificator : false,
    NotificatorObject     : null,

    ExtendedMode           : true,
    CanChangToExtendedMode : true,
    WidthForExtendedMode   : 800,

    oneDay : 1000*60*60*24,

    navWidth : 270,

    isShowed : null,
    nextShow : '',

    scrResize : null,
    navResize : null,

    noNotify : false,
    notify   : null,
    idNotify : 0,

    ServerInfo: {
        Host: '127.0.0.1',
        Port: 2004,
        ID  : null
    },

    keyCodes : {
        // Alphabet
        a:65, b:66, c:67, d:68, e:69,
        f:70, g:71, h:72, i:73, j:74,
        k:75, l:76, m:77, n:78, o:79,
        p:80, q:81, r:82, s:83, t:84,
        u:85, v:86, w:87, x:88, y:89,
        z:90,

        // Numbers
        n0:48, n1:49, n2:50, n3:51, n4:52,
        n5:53, n6:54, n7:55, n8:56, n9:57,

        // Controls
        tab:  9, enter :13,  shift :16, backspace:8,
        ctrl:17, alt   :18,  esc   :27, space    :32,
        menu:93, pause :19,  cmd   :91, insert   :45,
        home:36, pageup:33,'delete':46, end      :35,
        pagedown:34,

        // F*
        f1:112, f2:113, f3:114, f4 :115, f5 :116, f6 :117,
        f7:118, f8:119, f9:120, f10:121, f11:122, f12:123,

        // numpad
        np0: 96, np1: 97, np2: 98, np3: 99, np4:100,
        np5:101, np6:102, np7:103, np8:104, np9:105,

        npslash:11,npstar:106,nphyphen:109,npplus:107,npdot:110,

        // Lock
        capslock:20, numlock:144, scrolllock:145,

        // Symbols
        equals: 61, hyphen   :109, coma  :188, dot:190,
        gravis:192, backslash:220, sbopen:219, sbclose:221,
        slash :191, semicolon: 59, apostrophe : 222,

        // Arrows
        aleft:37, aup:  38, aright:39, adown:40,

        PrintSymbols :
            [32, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 65,
                66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76,
                77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87,
                88, 89, 90, 96, 97, 98, 99, 100,101,102,103,
                105,106,107,109,110,111,186,187,188,189,190,
                104,191,192,219,220,221,222],

        EditSymbols  : [8,  32, 46],

        Digits :
            [48, 49, 50, 51,  52, 53, 54, 55, 56, 57,
                96, 97, 98, 99, 100,101,102,103,104,105],

        ControlFunc	 :
            [ 33, 34, 35, 36, 37, 38, 39, 40,112,113,
                114,115,116,117,118,119,120,121,122,123],

        ControlsKeys : [36, 33, 35, 34, 37, 38, 39, 40],

        PrintAndEdit : function(){
            return mcConst.keyCodes.PrintSymbols.concat(mcConst.keyCodes.EditSymbols);
        }
    },

    KanbanEvents: {
        TASK_ADDED             : 1,
        TASK_PERFORMER_CHANGED : 2,
        COMMENT_ADDED          : 3,
        TASK_MOVED             : 4,
        TASK_CHANGED           : 5,
        TASK_DELETED           : 6,
        PROJECT_CLOSED         : 7
    },

    historyTypes: {
        count: 1,
        range: 2,
        list : 3
    },

    FTP: {
        CommonUser: 'mcuser',
        CommonPWD : 'mychat'
    }
};(function () {
    var /*
 * Rusha, a JavaScript implementation of the Secure Hash Algorithm, SHA-1,
 * as defined in FIPS PUB 180-1, tuned for high performance with large inputs.
 * (http://github.com/srijs/rusha)
 *
 * Inspired by Paul Johnstons implementation (http://pajhome.org.uk/crypt/md5).
 *
 * Copyright (c) 2013 Sam Rijs (http://awesam.de).
 * Released under the terms of the MIT license as follows:
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 */
    util = {
        getDataType: function (data) {
            if (typeof data === 'string') {
                return 'string';
            }
            if (data instanceof Array) {
                return 'array';
            }
            if (typeof global !== 'undefined' && global.Buffer && global.Buffer.isBuffer(data)) {
                return 'buffer';
            }
            if (data instanceof ArrayBuffer) {
                return 'arraybuffer';
            }
            if (data.buffer instanceof ArrayBuffer) {
                return 'view';
            }
            if (data instanceof Blob) {
                return 'blob';
            }
            throw new Error('Unsupported data type.');
        }
    };
    function Rusha(chunkSize) {
        'use strict';
        var // Private object structure.
        self$2 = { fill: 0 };
        var // Calculate the length of buffer that the sha1 routine uses
        // including the padding.
        padlen = function (len) {
            for (len += 9; len % 64 > 0; len += 1);
            return len;
        };
        var padZeroes = function (bin, len) {
            var h8 = new Uint8Array(bin.buffer);
            var om = len % 4, align = len - om;
            switch (om) {
            case 0:
                h8[align + 3] = 0;
            case 1:
                h8[align + 2] = 0;
            case 2:
                h8[align + 1] = 0;
            case 3:
                h8[align + 0] = 0;
            }
            for (var i$2 = (len >> 2) + 1; i$2 < bin.length; i$2++)
                bin[i$2] = 0;
        };
        var padData = function (bin, chunkLen, msgLen) {
            bin[chunkLen >> 2] |= 128 << 24 - (chunkLen % 4 << 3);
            // To support msgLen >= 2 GiB, use a float division when computing the
            // high 32-bits of the big-endian message length in bits.
            bin[((chunkLen >> 2) + 2 & ~15) + 14] = msgLen / (1 << 29) | 0;
            bin[((chunkLen >> 2) + 2 & ~15) + 15] = msgLen << 3;
        };
        var // Convert a binary string and write it to the heap.
        // A binary string is expected to only contain char codes < 256.
        convStr = function (H8, H32, start, len, off) {
            var str = this, i$2, om = off % 4, lm = (len + om) % 4, j = len - lm;
            switch (om) {
            case 0:
                H8[off] = str.charCodeAt(start + 3);
            case 1:
                H8[off + 1 - (om << 1) | 0] = str.charCodeAt(start + 2);
            case 2:
                H8[off + 2 - (om << 1) | 0] = str.charCodeAt(start + 1);
            case 3:
                H8[off + 3 - (om << 1) | 0] = str.charCodeAt(start);
            }
            if (len < lm + om) {
                return;
            }
            for (i$2 = 4 - om; i$2 < j; i$2 = i$2 + 4 | 0) {
                H32[off + i$2 >> 2] = str.charCodeAt(start + i$2) << 24 | str.charCodeAt(start + i$2 + 1) << 16 | str.charCodeAt(start + i$2 + 2) << 8 | str.charCodeAt(start + i$2 + 3);
            }
            switch (lm) {
            case 3:
                H8[off + j + 1 | 0] = str.charCodeAt(start + j + 2);
            case 2:
                H8[off + j + 2 | 0] = str.charCodeAt(start + j + 1);
            case 1:
                H8[off + j + 3 | 0] = str.charCodeAt(start + j);
            }
        };
        var // Convert a buffer or array and write it to the heap.
        // The buffer or array is expected to only contain elements < 256.
        convBuf = function (H8, H32, start, len, off) {
            var buf = this, i$2, om = off % 4, lm = (len + om) % 4, j = len - lm;
            switch (om) {
            case 0:
                H8[off] = buf[start + 3];
            case 1:
                H8[off + 1 - (om << 1) | 0] = buf[start + 2];
            case 2:
                H8[off + 2 - (om << 1) | 0] = buf[start + 1];
            case 3:
                H8[off + 3 - (om << 1) | 0] = buf[start];
            }
            if (len < lm + om) {
                return;
            }
            for (i$2 = 4 - om; i$2 < j; i$2 = i$2 + 4 | 0) {
                H32[off + i$2 >> 2 | 0] = buf[start + i$2] << 24 | buf[start + i$2 + 1] << 16 | buf[start + i$2 + 2] << 8 | buf[start + i$2 + 3];
            }
            switch (lm) {
            case 3:
                H8[off + j + 1 | 0] = buf[start + j + 2];
            case 2:
                H8[off + j + 2 | 0] = buf[start + j + 1];
            case 1:
                H8[off + j + 3 | 0] = buf[start + j];
            }
        };
        var convBlob = function (H8, H32, start, len, off) {
            var blob = this, i$2, om = off % 4, lm = (len + om) % 4, j = len - lm;
            var buf = new Uint8Array(reader.readAsArrayBuffer(blob.slice(start, start + len)));
            switch (om) {
            case 0:
                H8[off] = buf[3];
            case 1:
                H8[off + 1 - (om << 1) | 0] = buf[2];
            case 2:
                H8[off + 2 - (om << 1) | 0] = buf[1];
            case 3:
                H8[off + 3 - (om << 1) | 0] = buf[0];
            }
            if (len < lm + om) {
                return;
            }
            for (i$2 = 4 - om; i$2 < j; i$2 = i$2 + 4 | 0) {
                H32[off + i$2 >> 2 | 0] = buf[i$2] << 24 | buf[i$2 + 1] << 16 | buf[i$2 + 2] << 8 | buf[i$2 + 3];
            }
            switch (lm) {
            case 3:
                H8[off + j + 1 | 0] = buf[j + 2];
            case 2:
                H8[off + j + 2 | 0] = buf[j + 1];
            case 1:
                H8[off + j + 3 | 0] = buf[j];
            }
        };
        var convFn = function (data) {
            switch (util.getDataType(data)) {
            case 'string':
                return convStr.bind(data);
            case 'array':
                return convBuf.bind(data);
            case 'buffer':
                return convBuf.bind(data);
            case 'arraybuffer':
                return convBuf.bind(new Uint8Array(data));
            case 'view':
                return convBuf.bind(new Uint8Array(data.buffer, data.byteOffset, data.byteLength));
            case 'blob':
                return convBlob.bind(data);
            }
        };
        var slice = function (data, offset) {
            switch (util.getDataType(data)) {
            case 'string':
                return data.slice(offset);
            case 'array':
                return data.slice(offset);
            case 'buffer':
                return data.slice(offset);
            case 'arraybuffer':
                return data.slice(offset);
            case 'view':
                return data.buffer.slice(offset);
            }
        };
        var // Precompute 00 - ff strings
        precomputedHex = new Array(256);
        for (var i = 0; i < 256; i++) {
            precomputedHex[i] = (i < 16 ? '0' : '') + i.toString(16);
        }
        var // Convert an ArrayBuffer into its hexadecimal string representation.
        hex = function (arrayBuffer) {
            var binarray = new Uint8Array(arrayBuffer);
            var res = new Array(arrayBuffer.byteLength);
            for (var i$2 = 0; i$2 < res.length; i$2++) {
                res[i$2] = precomputedHex[binarray[i$2]];
            }
            return res.join('');
        };
        var ceilHeapSize = function (v) {
            // The asm.js spec says:
            // The heap object's byteLength must be either
            // 2^n for n in [12, 24) or 2^24 * n for n ≥ 1.
            // Also, byteLengths smaller than 2^16 are deprecated.
            var p;
            if (// If v is smaller than 2^16, the smallest possible solution
                // is 2^16.
                v <= 65536)
                return 65536;
            if (// If v < 2^24, we round up to 2^n,
                // otherwise we round up to 2^24 * n.
                v < 16777216) {
                for (p = 1; p < v; p = p << 1);
            } else {
                for (p = 16777216; p < v; p += 16777216);
            }
            return p;
        };
        var // Initialize the internal data structures to a new capacity.
        init = function (size) {
            if (size % 64 > 0) {
                throw new Error('Chunk size must be a multiple of 128 bit');
            }
            self$2.offset = 0;
            self$2.maxChunkLen = size;
            self$2.padMaxChunkLen = padlen(size);
            // The size of the heap is the sum of:
            // 1. The padded input message size
            // 2. The extended space the algorithm needs (320 byte)
            // 3. The 160 bit state the algoritm uses
            self$2.heap = new ArrayBuffer(ceilHeapSize(self$2.padMaxChunkLen + 320 + 20));
            self$2.h32 = new Int32Array(self$2.heap);
            self$2.h8 = new Int8Array(self$2.heap);
            self$2.core = new Rusha._core({
                Int32Array: Int32Array,
                DataView: DataView
            }, {}, self$2.heap);
            self$2.buffer = null;
        };
        // Iinitializethe datastructures according
        // to a chunk siyze.
        init(chunkSize || 64 * 1024);
        var initState = function (heap, padMsgLen) {
            self$2.offset = 0;
            var io = new Int32Array(heap, padMsgLen + 320, 5);
            io[0] = 1732584193;
            io[1] = -271733879;
            io[2] = -1732584194;
            io[3] = 271733878;
            io[4] = -1009589776;
        };
        var padChunk = function (chunkLen, msgLen) {
            var padChunkLen = padlen(chunkLen);
            var view = new Int32Array(self$2.heap, 0, padChunkLen >> 2);
            padZeroes(view, chunkLen);
            padData(view, chunkLen, msgLen);
            return padChunkLen;
        };
        var // Write data to the heap.
        write = function (data, chunkOffset, chunkLen, off) {
            convFn(data)(self$2.h8, self$2.h32, chunkOffset, chunkLen, off || 0);
        };
        var // Initialize and call the RushaCore,
        // assuming an input buffer of length len * 4.
        coreCall = function (data, chunkOffset, chunkLen, msgLen, finalize) {
            var padChunkLen = chunkLen;
            write(data, chunkOffset, chunkLen);
            if (finalize) {
                padChunkLen = padChunk(chunkLen, msgLen);
            }
            self$2.core.hash(padChunkLen, self$2.padMaxChunkLen);
        };
        var getRawDigest = function (heap, padMaxChunkLen) {
            var io = new Int32Array(heap, padMaxChunkLen + 320, 5);
            var out = new Int32Array(5);
            var arr = new DataView(out.buffer);
            arr.setInt32(0, io[0], false);
            arr.setInt32(4, io[1], false);
            arr.setInt32(8, io[2], false);
            arr.setInt32(12, io[3], false);
            arr.setInt32(16, io[4], false);
            return out;
        };
        var // Calculate the hash digest as an array of 5 32bit integers.
        rawDigest = this.rawDigest = function (str) {
            var msgLen = str.byteLength || str.length || str.size || 0;
            initState(self$2.heap, self$2.padMaxChunkLen);
            var chunkOffset = 0, chunkLen = self$2.maxChunkLen;
            for (chunkOffset = 0; msgLen > chunkOffset + chunkLen; chunkOffset += chunkLen) {
                coreCall(str, chunkOffset, chunkLen, msgLen, false);
            }
            coreCall(str, chunkOffset, msgLen - chunkOffset, msgLen, true);
            return getRawDigest(self$2.heap, self$2.padMaxChunkLen);
        };
        // The digest and digestFrom* interface returns the hash digest
        // as a hex string.
        this.digest = this.digestFromString = this.digestFromBuffer = this.digestFromArrayBuffer = function (str) {
            return hex(rawDigest(str).buffer);
        };
        this.resetState = function () {
            initState(self$2.heap, self$2.padMaxChunkLen);
            return this;
        };
        this.append = function (chunk) {
            var chunkOffset = 0;
            var chunkLen = chunk.byteLength || chunk.length || chunk.size || 0;
            var turnOffset = self$2.offset % self$2.maxChunkLen;
            var inputLen;
            self$2.offset += chunkLen;
            while (chunkOffset < chunkLen) {
                inputLen = Math.min(chunkLen - chunkOffset, self$2.maxChunkLen - turnOffset);
                write(chunk, chunkOffset, inputLen, turnOffset);
                turnOffset += inputLen;
                chunkOffset += inputLen;
                if (turnOffset === self$2.maxChunkLen) {
                    self$2.core.hash(self$2.maxChunkLen, self$2.padMaxChunkLen);
                    turnOffset = 0;
                }
            }
            return this;
        };
        this.getState = function () {
            var turnOffset = self$2.offset % self$2.maxChunkLen;
            var heap;
            if (!turnOffset) {
                var io = new Int32Array(self$2.heap, self$2.padMaxChunkLen + 320, 5);
                heap = io.buffer.slice(io.byteOffset, io.byteOffset + io.byteLength);
            } else {
                heap = self$2.heap.slice(0);
            }
            return {
                offset: self$2.offset,
                heap: heap
            };
        };
        this.setState = function (state) {
            self$2.offset = state.offset;
            if (state.heap.byteLength === 20) {
                var io = new Int32Array(self$2.heap, self$2.padMaxChunkLen + 320, 5);
                io.set(new Int32Array(state.heap));
            } else {
                self$2.h32.set(new Int32Array(state.heap));
            }
            return this;
        };
        var rawEnd = this.rawEnd = function () {
            var msgLen = self$2.offset;
            var chunkLen = msgLen % self$2.maxChunkLen;
            var padChunkLen = padChunk(chunkLen, msgLen);
            self$2.core.hash(padChunkLen, self$2.padMaxChunkLen);
            var result = getRawDigest(self$2.heap, self$2.padMaxChunkLen);
            initState(self$2.heap, self$2.padMaxChunkLen);
            return result;
        };
        this.end = function () {
            return hex(rawEnd().buffer);
        };
    }
    ;
    // The low-level RushCore module provides the heart of Rusha,
    // a high-speed sha1 implementation working on an Int32Array heap.
    // At first glance, the implementation seems complicated, however
    // with the SHA1 spec at hand, it is obvious this almost a textbook
    // implementation that has a few functions hand-inlined and a few loops
    // hand-unrolled.
    Rusha._core = function RushaCore(stdlib, foreign, heap) {
        'use asm';
        var H = new stdlib.Int32Array(heap);
        function hash(k, x) {
            // k in bytes
            k = k | 0;
            x = x | 0;
            var i = 0, j = 0, y0 = 0, z0 = 0, y1 = 0, z1 = 0, y2 = 0, z2 = 0, y3 = 0, z3 = 0, y4 = 0, z4 = 0, t0 = 0, t1 = 0;
            y0 = H[x + 320 >> 2] | 0;
            y1 = H[x + 324 >> 2] | 0;
            y2 = H[x + 328 >> 2] | 0;
            y3 = H[x + 332 >> 2] | 0;
            y4 = H[x + 336 >> 2] | 0;
            for (i = 0; (i | 0) < (k | 0); i = i + 64 | 0) {
                z0 = y0;
                z1 = y1;
                z2 = y2;
                z3 = y3;
                z4 = y4;
                for (j = 0; (j | 0) < 64; j = j + 4 | 0) {
                    t1 = H[i + j >> 2] | 0;
                    t0 = ((y0 << 5 | y0 >>> 27) + (y1 & y2 | ~y1 & y3) | 0) + ((t1 + y4 | 0) + 1518500249 | 0) | 0;
                    y4 = y3;
                    y3 = y2;
                    y2 = y1 << 30 | y1 >>> 2;
                    y1 = y0;
                    y0 = t0;
                    H[k + j >> 2] = t1;
                }
                for (j = k + 64 | 0; (j | 0) < (k + 80 | 0); j = j + 4 | 0) {
                    t1 = (H[j - 12 >> 2] ^ H[j - 32 >> 2] ^ H[j - 56 >> 2] ^ H[j - 64 >> 2]) << 1 | (H[j - 12 >> 2] ^ H[j - 32 >> 2] ^ H[j - 56 >> 2] ^ H[j - 64 >> 2]) >>> 31;
                    t0 = ((y0 << 5 | y0 >>> 27) + (y1 & y2 | ~y1 & y3) | 0) + ((t1 + y4 | 0) + 1518500249 | 0) | 0;
                    y4 = y3;
                    y3 = y2;
                    y2 = y1 << 30 | y1 >>> 2;
                    y1 = y0;
                    y0 = t0;
                    H[j >> 2] = t1;
                }
                for (j = k + 80 | 0; (j | 0) < (k + 160 | 0); j = j + 4 | 0) {
                    t1 = (H[j - 12 >> 2] ^ H[j - 32 >> 2] ^ H[j - 56 >> 2] ^ H[j - 64 >> 2]) << 1 | (H[j - 12 >> 2] ^ H[j - 32 >> 2] ^ H[j - 56 >> 2] ^ H[j - 64 >> 2]) >>> 31;
                    t0 = ((y0 << 5 | y0 >>> 27) + (y1 ^ y2 ^ y3) | 0) + ((t1 + y4 | 0) + 1859775393 | 0) | 0;
                    y4 = y3;
                    y3 = y2;
                    y2 = y1 << 30 | y1 >>> 2;
                    y1 = y0;
                    y0 = t0;
                    H[j >> 2] = t1;
                }
                for (j = k + 160 | 0; (j | 0) < (k + 240 | 0); j = j + 4 | 0) {
                    t1 = (H[j - 12 >> 2] ^ H[j - 32 >> 2] ^ H[j - 56 >> 2] ^ H[j - 64 >> 2]) << 1 | (H[j - 12 >> 2] ^ H[j - 32 >> 2] ^ H[j - 56 >> 2] ^ H[j - 64 >> 2]) >>> 31;
                    t0 = ((y0 << 5 | y0 >>> 27) + (y1 & y2 | y1 & y3 | y2 & y3) | 0) + ((t1 + y4 | 0) - 1894007588 | 0) | 0;
                    y4 = y3;
                    y3 = y2;
                    y2 = y1 << 30 | y1 >>> 2;
                    y1 = y0;
                    y0 = t0;
                    H[j >> 2] = t1;
                }
                for (j = k + 240 | 0; (j | 0) < (k + 320 | 0); j = j + 4 | 0) {
                    t1 = (H[j - 12 >> 2] ^ H[j - 32 >> 2] ^ H[j - 56 >> 2] ^ H[j - 64 >> 2]) << 1 | (H[j - 12 >> 2] ^ H[j - 32 >> 2] ^ H[j - 56 >> 2] ^ H[j - 64 >> 2]) >>> 31;
                    t0 = ((y0 << 5 | y0 >>> 27) + (y1 ^ y2 ^ y3) | 0) + ((t1 + y4 | 0) - 899497514 | 0) | 0;
                    y4 = y3;
                    y3 = y2;
                    y2 = y1 << 30 | y1 >>> 2;
                    y1 = y0;
                    y0 = t0;
                    H[j >> 2] = t1;
                }
                y0 = y0 + z0 | 0;
                y1 = y1 + z1 | 0;
                y2 = y2 + z2 | 0;
                y3 = y3 + z3 | 0;
                y4 = y4 + z4 | 0;
            }
            H[x + 320 >> 2] = y0;
            H[x + 324 >> 2] = y1;
            H[x + 328 >> 2] = y2;
            H[x + 332 >> 2] = y3;
            H[x + 336 >> 2] = y4;
        }
        return { hash: hash };
    };

    if (// If we're running in a DOM context, export
        // the Rusha object to toplevel.
        typeof window !== 'undefined') {
        window.Rusha = Rusha;
    } else 
    if (// If we'e running in Node.JS, export a module.
        typeof module !== 'undefined') {
        module.exports = Rusha;
    } 

    if (// If we're running in a webworker, accept
        // messages containing a jobid and a buffer
        // or blob object, and return the hash result.
        typeof FileReaderSync !== 'undefined') {
        var reader = new FileReaderSync();
        var hashData = function hash(hasher, data, cb) {
            try {
                return cb(null, hasher.digest(data));
            } catch (e) {
                return cb(e);
            }
        };
        var hashFile = function hashArrayBuffer(hasher, readTotal, blockSize, file, cb) {
            var reader$2 = new self.FileReader();
            reader$2.onloadend = function onloadend() {
                var buffer = reader$2.result;
                readTotal += reader$2.result.byteLength;
                try {
                    hasher.append(buffer);
                } catch (e) {
                    cb(e);
                    return;
                }
                if (readTotal < file.size) {
                    hashFile(hasher, readTotal, blockSize, file, cb);
                } else {
                    cb(null, hasher.end());
                }
            };
            reader$2.readAsArrayBuffer(file.slice(readTotal, readTotal + blockSize));
        };
        self.onmessage = function onMessage(event) {
            var data = event.data.data, file = event.data.file, id = event.data.id;
            if (typeof id === 'undefined')
                return;
            if (!file && !data)
                return;
            var blockSize = event.data.blockSize || 4 * 1024 * 1024;
            var hasher = new Rusha(blockSize);
            hasher.resetState();
            var done = function done$2(err, hash) {
                if (!err) {
                    self.postMessage({
                        id: id,
                        hash: hash
                    });
                } else {
                    self.postMessage({
                        id: id,
                        error: err.name
                    });
                }
            };
            if (data)
                hashData(hasher, data, done);
            if (file)
                hashFile(hasher, 0, blockSize, file, done);
        };
    }
}());(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.adapter = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/*
 *  Copyright (c) 2017 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */
'use strict';

var SDPUtils = require('sdp');

function writeMediaSection(transceiver, caps, type, stream, dtlsRole) {
  var sdp = SDPUtils.writeRtpDescription(transceiver.kind, caps);

  // Map ICE parameters (ufrag, pwd) to SDP.
  sdp += SDPUtils.writeIceParameters(
      transceiver.iceGatherer.getLocalParameters());

  // Map DTLS parameters to SDP.
  sdp += SDPUtils.writeDtlsParameters(
      transceiver.dtlsTransport.getLocalParameters(),
      type === 'offer' ? 'actpass' : dtlsRole || 'active');

  sdp += 'a=mid:' + transceiver.mid + '\r\n';

  if (transceiver.direction) {
    sdp += 'a=' + transceiver.direction + '\r\n';
  } else if (transceiver.rtpSender && transceiver.rtpReceiver) {
    sdp += 'a=sendrecv\r\n';
  } else if (transceiver.rtpSender) {
    sdp += 'a=sendonly\r\n';
  } else if (transceiver.rtpReceiver) {
    sdp += 'a=recvonly\r\n';
  } else {
    sdp += 'a=inactive\r\n';
  }

  if (transceiver.rtpSender) {
    // spec.
    var msid = 'msid:' + stream.id + ' ' +
        transceiver.rtpSender.track.id + '\r\n';
    sdp += 'a=' + msid;

    // for Chrome.
    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +
        ' ' + msid;
    if (transceiver.sendEncodingParameters[0].rtx) {
      sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +
          ' ' + msid;
      sdp += 'a=ssrc-group:FID ' +
          transceiver.sendEncodingParameters[0].ssrc + ' ' +
          transceiver.sendEncodingParameters[0].rtx.ssrc +
          '\r\n';
    }
  }
  // FIXME: this should be written by writeRtpDescription.
  sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +
      ' cname:' + SDPUtils.localCName + '\r\n';
  if (transceiver.rtpSender && transceiver.sendEncodingParameters[0].rtx) {
    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +
        ' cname:' + SDPUtils.localCName + '\r\n';
  }
  return sdp;
}

// Edge does not like
// 1) stun: filtered after 14393 unless ?transport=udp is present
// 2) turn: that does not have all of turn:host:port?transport=udp
// 3) turn: with ipv6 addresses
// 4) turn: occurring muliple times
function filterIceServers(iceServers, edgeVersion) {
  var hasTurn = false;
  iceServers = JSON.parse(JSON.stringify(iceServers));
  return iceServers.filter(function(server) {
    if (server && (server.urls || server.url)) {
      var urls = server.urls || server.url;
      if (server.url && !server.urls) {
        console.warn('RTCIceServer.url is deprecated! Use urls instead.');
      }
      var isString = typeof urls === 'string';
      if (isString) {
        urls = [urls];
      }
      urls = urls.filter(function(url) {
        var validTurn = url.indexOf('turn:') === 0 &&
            url.indexOf('transport=udp') !== -1 &&
            url.indexOf('turn:[') === -1 &&
            !hasTurn;

        if (validTurn) {
          hasTurn = true;
          return true;
        }
        return url.indexOf('stun:') === 0 && edgeVersion >= 14393 &&
            url.indexOf('?transport=udp') === -1;
      });

      delete server.url;
      server.urls = isString ? urls[0] : urls;
      return !!urls.length;
    }
    return false;
  });
}

// Determines the intersection of local and remote capabilities.
function getCommonCapabilities(localCapabilities, remoteCapabilities) {
  var commonCapabilities = {
    codecs: [],
    headerExtensions: [],
    fecMechanisms: []
  };

  var findCodecByPayloadType = function(pt, codecs) {
    pt = parseInt(pt, 10);
    for (var i = 0; i < codecs.length; i++) {
      if (codecs[i].payloadType === pt ||
          codecs[i].preferredPayloadType === pt) {
        return codecs[i];
      }
    }
  };

  var rtxCapabilityMatches = function(lRtx, rRtx, lCodecs, rCodecs) {
    var lCodec = findCodecByPayloadType(lRtx.parameters.apt, lCodecs);
    var rCodec = findCodecByPayloadType(rRtx.parameters.apt, rCodecs);
    return lCodec && rCodec &&
        lCodec.name.toLowerCase() === rCodec.name.toLowerCase();
  };

  localCapabilities.codecs.forEach(function(lCodec) {
    for (var i = 0; i < remoteCapabilities.codecs.length; i++) {
      var rCodec = remoteCapabilities.codecs[i];
      if (lCodec.name.toLowerCase() === rCodec.name.toLowerCase() &&
          lCodec.clockRate === rCodec.clockRate) {
        if (lCodec.name.toLowerCase() === 'rtx' &&
            lCodec.parameters && rCodec.parameters.apt) {
          // for RTX we need to find the local rtx that has a apt
          // which points to the same local codec as the remote one.
          if (!rtxCapabilityMatches(lCodec, rCodec,
              localCapabilities.codecs, remoteCapabilities.codecs)) {
            continue;
          }
        }
        rCodec = JSON.parse(JSON.stringify(rCodec)); // deepcopy
        // number of channels is the highest common number of channels
        rCodec.numChannels = Math.min(lCodec.numChannels,
            rCodec.numChannels);
        // push rCodec so we reply with offerer payload type
        commonCapabilities.codecs.push(rCodec);

        // determine common feedback mechanisms
        rCodec.rtcpFeedback = rCodec.rtcpFeedback.filter(function(fb) {
          for (var j = 0; j < lCodec.rtcpFeedback.length; j++) {
            if (lCodec.rtcpFeedback[j].type === fb.type &&
                lCodec.rtcpFeedback[j].parameter === fb.parameter) {
              return true;
            }
          }
          return false;
        });
        // FIXME: also need to determine .parameters
        //  see https://github.com/openpeer/ortc/issues/569
        break;
      }
    }
  });

  localCapabilities.headerExtensions.forEach(function(lHeaderExtension) {
    for (var i = 0; i < remoteCapabilities.headerExtensions.length;
         i++) {
      var rHeaderExtension = remoteCapabilities.headerExtensions[i];
      if (lHeaderExtension.uri === rHeaderExtension.uri) {
        commonCapabilities.headerExtensions.push(rHeaderExtension);
        break;
      }
    }
  });

  // FIXME: fecMechanisms
  return commonCapabilities;
}

// is action=setLocalDescription with type allowed in signalingState
function isActionAllowedInSignalingState(action, type, signalingState) {
  return {
    offer: {
      setLocalDescription: ['stable', 'have-local-offer'],
      setRemoteDescription: ['stable', 'have-remote-offer']
    },
    answer: {
      setLocalDescription: ['have-remote-offer', 'have-local-pranswer'],
      setRemoteDescription: ['have-local-offer', 'have-remote-pranswer']
    }
  }[type][action].indexOf(signalingState) !== -1;
}

function maybeAddCandidate(iceTransport, candidate) {
  // Edge's internal representation adds some fields therefore
  // not all fieldѕ are taken into account.
  var alreadyAdded = iceTransport.getRemoteCandidates()
      .find(function(remoteCandidate) {
        return candidate.foundation === remoteCandidate.foundation &&
            candidate.ip === remoteCandidate.ip &&
            candidate.port === remoteCandidate.port &&
            candidate.priority === remoteCandidate.priority &&
            candidate.protocol === remoteCandidate.protocol &&
            candidate.type === remoteCandidate.type;
      });
  if (!alreadyAdded) {
    iceTransport.addRemoteCandidate(candidate);
  }
  return !alreadyAdded;
}

module.exports = function(window, edgeVersion) {
  var RTCPeerConnection = function(config) {
    var self = this;

    var _eventTarget = document.createDocumentFragment();
    ['addEventListener', 'removeEventListener', 'dispatchEvent']
        .forEach(function(method) {
          self[method] = _eventTarget[method].bind(_eventTarget);
        });

    this.onicecandidate = null;
    this.onaddstream = null;
    this.ontrack = null;
    this.onremovestream = null;
    this.onsignalingstatechange = null;
    this.oniceconnectionstatechange = null;
    this.onicegatheringstatechange = null;
    this.onnegotiationneeded = null;
    this.ondatachannel = null;
    this.canTrickleIceCandidates = null;

    this.needNegotiation = false;

    this.localStreams = [];
    this.remoteStreams = [];

    this.localDescription = null;
    this.remoteDescription = null;

    this.signalingState = 'stable';
    this.iceConnectionState = 'new';
    this.iceGatheringState = 'new';

    config = JSON.parse(JSON.stringify(config || {}));

    this.usingBundle = config.bundlePolicy === 'max-bundle';
    if (config.rtcpMuxPolicy === 'negotiate') {
      var e = new Error('rtcpMuxPolicy \'negotiate\' is not supported');
      e.name = 'NotSupportedError';
      throw(e);
    } else if (!config.rtcpMuxPolicy) {
      config.rtcpMuxPolicy = 'require';
    }

    switch (config.iceTransportPolicy) {
      case 'all':
      case 'relay':
        break;
      default:
        config.iceTransportPolicy = 'all';
        break;
    }

    switch (config.bundlePolicy) {
      case 'balanced':
      case 'max-compat':
      case 'max-bundle':
        break;
      default:
        config.bundlePolicy = 'balanced';
        break;
    }

    config.iceServers = filterIceServers(config.iceServers || [], edgeVersion);

    this._iceGatherers = [];
    if (config.iceCandidatePoolSize) {
      for (var i = config.iceCandidatePoolSize; i > 0; i--) {
        this._iceGatherers = new window.RTCIceGatherer({
          iceServers: config.iceServers,
          gatherPolicy: config.iceTransportPolicy
        });
      }
    } else {
      config.iceCandidatePoolSize = 0;
    }

    this._config = config;

    // per-track iceGathers, iceTransports, dtlsTransports, rtpSenders, ...
    // everything that is needed to describe a SDP m-line.
    this.transceivers = [];

    this._sdpSessionId = SDPUtils.generateSessionId();
    this._sdpSessionVersion = 0;

    this._dtlsRole = undefined; // role for a=setup to use in answers.
  };

  RTCPeerConnection.prototype._emitGatheringStateChange = function() {
    var event = new Event('icegatheringstatechange');
    this.dispatchEvent(event);
    if (typeof this.onicegatheringstatechange === 'function') {
      this.onicegatheringstatechange(event);
    }
  };

  RTCPeerConnection.prototype.getConfiguration = function() {
    return this._config;
  };

  RTCPeerConnection.prototype.getLocalStreams = function() {
    return this.localStreams;
  };

  RTCPeerConnection.prototype.getRemoteStreams = function() {
    return this.remoteStreams;
  };

  // internal helper to create a transceiver object.
  // (whih is not yet the same as the WebRTC 1.0 transceiver)
  RTCPeerConnection.prototype._createTransceiver = function(kind) {
    var hasBundleTransport = this.transceivers.length > 0;
    var transceiver = {
      track: null,
      iceGatherer: null,
      iceTransport: null,
      dtlsTransport: null,
      localCapabilities: null,
      remoteCapabilities: null,
      rtpSender: null,
      rtpReceiver: null,
      kind: kind,
      mid: null,
      sendEncodingParameters: null,
      recvEncodingParameters: null,
      stream: null,
      wantReceive: true
    };
    if (this.usingBundle && hasBundleTransport) {
      transceiver.iceTransport = this.transceivers[0].iceTransport;
      transceiver.dtlsTransport = this.transceivers[0].dtlsTransport;
    } else {
      var transports = this._createIceAndDtlsTransports();
      transceiver.iceTransport = transports.iceTransport;
      transceiver.dtlsTransport = transports.dtlsTransport;
    }
    this.transceivers.push(transceiver);
    return transceiver;
  };

  RTCPeerConnection.prototype.addTrack = function(track, stream) {
    var transceiver;
    for (var i = 0; i < this.transceivers.length; i++) {
      if (!this.transceivers[i].track &&
          this.transceivers[i].kind === track.kind) {
        transceiver = this.transceivers[i];
      }
    }
    if (!transceiver) {
      transceiver = this._createTransceiver(track.kind);
    }

    this._maybeFireNegotiationNeeded();

    if (this.localStreams.indexOf(stream) === -1) {
      this.localStreams.push(stream);
    }

    transceiver.track = track;
    transceiver.stream = stream;
    transceiver.rtpSender = new window.RTCRtpSender(track,
        transceiver.dtlsTransport);
    return transceiver.rtpSender;
  };

  RTCPeerConnection.prototype.addStream = function(stream) {
    var self = this;
    if (edgeVersion >= 15025) {
      stream.getTracks().forEach(function(track) {
        self.addTrack(track, stream);
      });
    } else {
      // Clone is necessary for local demos mostly, attaching directly
      // to two different senders does not work (build 10547).
      // Fixed in 15025 (or earlier)
      var clonedStream = stream.clone();
      stream.getTracks().forEach(function(track, idx) {
        var clonedTrack = clonedStream.getTracks()[idx];
        track.addEventListener('enabled', function(event) {
          clonedTrack.enabled = event.enabled;
        });
      });
      clonedStream.getTracks().forEach(function(track) {
        self.addTrack(track, clonedStream);
      });
    }
  };

  RTCPeerConnection.prototype.removeStream = function(stream) {
    var idx = this.localStreams.indexOf(stream);
    if (idx > -1) {
      this.localStreams.splice(idx, 1);
      this._maybeFireNegotiationNeeded();
    }
  };

  RTCPeerConnection.prototype.getSenders = function() {
    return this.transceivers.filter(function(transceiver) {
      return !!transceiver.rtpSender;
    })
    .map(function(transceiver) {
      return transceiver.rtpSender;
    });
  };

  RTCPeerConnection.prototype.getReceivers = function() {
    return this.transceivers.filter(function(transceiver) {
      return !!transceiver.rtpReceiver;
    })
    .map(function(transceiver) {
      return transceiver.rtpReceiver;
    });
  };


  RTCPeerConnection.prototype._createIceGatherer = function(sdpMLineIndex,
      usingBundle) {
    var self = this;
    if (usingBundle && sdpMLineIndex > 0) {
      return this.transceivers[0].iceGatherer;
    } else if (this._iceGatherers.length) {
      return this._iceGatherers.shift();
    }
    var iceGatherer = new window.RTCIceGatherer({
      iceServers: this._config.iceServers,
      gatherPolicy: this._config.iceTransportPolicy
    });
    Object.defineProperty(iceGatherer, 'state',
        {value: 'new', writable: true}
    );

    this.transceivers[sdpMLineIndex].candidates = [];
    this.transceivers[sdpMLineIndex].bufferCandidates = function(event) {
      var end = !event.candidate || Object.keys(event.candidate).length === 0;
      // polyfill since RTCIceGatherer.state is not implemented in
      // Edge 10547 yet.
      iceGatherer.state = end ? 'completed' : 'gathering';
      if (self.transceivers[sdpMLineIndex].candidates !== null) {
        self.transceivers[sdpMLineIndex].candidates.push(event.candidate);
      }
    };
    iceGatherer.addEventListener('localcandidate',
      this.transceivers[sdpMLineIndex].bufferCandidates);
    return iceGatherer;
  };

  // start gathering from an RTCIceGatherer.
  RTCPeerConnection.prototype._gather = function(mid, sdpMLineIndex) {
    var self = this;
    var iceGatherer = this.transceivers[sdpMLineIndex].iceGatherer;
    if (iceGatherer.onlocalcandidate) {
      return;
    }
    var candidates = this.transceivers[sdpMLineIndex].candidates;
    this.transceivers[sdpMLineIndex].candidates = null;
    iceGatherer.removeEventListener('localcandidate',
      this.transceivers[sdpMLineIndex].bufferCandidates);
    iceGatherer.onlocalcandidate = function(evt) {
      if (self.usingBundle && sdpMLineIndex > 0) {
        // if we know that we use bundle we can drop candidates with
        // ѕdpMLineIndex > 0. If we don't do this then our state gets
        // confused since we dispose the extra ice gatherer.
        return;
      }
      var event = new Event('icecandidate');
      event.candidate = {sdpMid: mid, sdpMLineIndex: sdpMLineIndex};

      var cand = evt.candidate;
      // Edge emits an empty object for RTCIceCandidateComplete‥
      var end = !cand || Object.keys(cand).length === 0;
      if (end) {
        // polyfill since RTCIceGatherer.state is not implemented in
        // Edge 10547 yet.
        if (iceGatherer.state === 'new' || iceGatherer.state === 'gathering') {
          iceGatherer.state = 'completed';
        }
      } else {
        if (iceGatherer.state === 'new') {
          iceGatherer.state = 'gathering';
        }
        // RTCIceCandidate doesn't have a component, needs to be added
        cand.component = 1;
        event.candidate.candidate = SDPUtils.writeCandidate(cand);
      }

      // update local description.
      var sections = SDPUtils.splitSections(self.localDescription.sdp);
      if (!end) {
        sections[event.candidate.sdpMLineIndex + 1] +=
            'a=' + event.candidate.candidate + '\r\n';
      } else {
        sections[event.candidate.sdpMLineIndex + 1] +=
            'a=end-of-candidates\r\n';
      }
      self.localDescription.sdp = sections.join('');
      var complete = self.transceivers.every(function(transceiver) {
        return transceiver.iceGatherer &&
            transceiver.iceGatherer.state === 'completed';
      });

      if (self.iceGatheringState !== 'gathering') {
        self.iceGatheringState = 'gathering';
        self._emitGatheringStateChange();
      }

      // Emit candidate. Also emit null candidate when all gatherers are
      // complete.
      if (!end) {
        self.dispatchEvent(event);
        if (typeof self.onicecandidate === 'function') {
          self.onicecandidate(event);
        }
      }
      if (complete) {
        self.dispatchEvent(new Event('icecandidate'));
        if (typeof self.onicecandidate === 'function') {
          self.onicecandidate(new Event('icecandidate'));
        }
        self.iceGatheringState = 'complete';
        self._emitGatheringStateChange();
      }
    };

    // emit already gathered candidates.
    window.setTimeout(function() {
      candidates.forEach(function(candidate) {
        var e = new Event('RTCIceGatherEvent');
        e.candidate = candidate;
        iceGatherer.onlocalcandidate(e);
      });
    }, 0);
  };

  // Create ICE transport and DTLS transport.
  RTCPeerConnection.prototype._createIceAndDtlsTransports = function() {
    var self = this;
    var iceTransport = new window.RTCIceTransport(null);
    iceTransport.onicestatechange = function() {
      self._updateConnectionState();
    };

    var dtlsTransport = new window.RTCDtlsTransport(iceTransport);
    dtlsTransport.ondtlsstatechange = function() {
      self._updateConnectionState();
    };
    dtlsTransport.onerror = function() {
      // onerror does not set state to failed by itself.
      Object.defineProperty(dtlsTransport, 'state',
          {value: 'failed', writable: true});
      self._updateConnectionState();
    };

    return {
      iceTransport: iceTransport,
      dtlsTransport: dtlsTransport
    };
  };

  // Destroy ICE gatherer, ICE transport and DTLS transport.
  // Without triggering the callbacks.
  RTCPeerConnection.prototype._disposeIceAndDtlsTransports = function(
      sdpMLineIndex) {
    var iceGatherer = this.transceivers[sdpMLineIndex].iceGatherer;
    if (iceGatherer) {
      delete iceGatherer.onlocalcandidate;
      delete this.transceivers[sdpMLineIndex].iceGatherer;
    }
    var iceTransport = this.transceivers[sdpMLineIndex].iceTransport;
    if (iceTransport) {
      delete iceTransport.onicestatechange;
      delete this.transceivers[sdpMLineIndex].iceTransport;
    }
    var dtlsTransport = this.transceivers[sdpMLineIndex].dtlsTransport;
    if (dtlsTransport) {
      delete dtlsTransport.ondtlsstatechange;
      delete dtlsTransport.onerror;
      delete this.transceivers[sdpMLineIndex].dtlsTransport;
    }
  };

  // Start the RTP Sender and Receiver for a transceiver.
  RTCPeerConnection.prototype._transceive = function(transceiver,
      send, recv) {
    var params = getCommonCapabilities(transceiver.localCapabilities,
        transceiver.remoteCapabilities);
    if (send && transceiver.rtpSender) {
      params.encodings = transceiver.sendEncodingParameters;
      params.rtcp = {
        cname: SDPUtils.localCName,
        compound: transceiver.rtcpParameters.compound
      };
      if (transceiver.recvEncodingParameters.length) {
        params.rtcp.ssrc = transceiver.recvEncodingParameters[0].ssrc;
      }
      transceiver.rtpSender.send(params);
    }
    if (recv && transceiver.rtpReceiver && params.codecs.length > 0) {
      // remove RTX field in Edge 14942
      if (transceiver.kind === 'video'
          && transceiver.recvEncodingParameters
          && edgeVersion < 15019) {
        transceiver.recvEncodingParameters.forEach(function(p) {
          delete p.rtx;
        });
      }
      params.encodings = transceiver.recvEncodingParameters;
      params.rtcp = {
        cname: transceiver.rtcpParameters.cname,
        compound: transceiver.rtcpParameters.compound
      };
      if (transceiver.sendEncodingParameters.length) {
        params.rtcp.ssrc = transceiver.sendEncodingParameters[0].ssrc;
      }
      transceiver.rtpReceiver.receive(params);
    }
  };

  RTCPeerConnection.prototype.setLocalDescription = function(description) {
    var self = this;
    var args = arguments;

    if (!isActionAllowedInSignalingState('setLocalDescription',
        description.type, this.signalingState)) {
      return new Promise(function(resolve, reject) {
        var e = new Error('Can not set local ' + description.type +
            ' in state ' + self.signalingState);
        e.name = 'InvalidStateError';
        if (args.length > 2 && typeof args[2] === 'function') {
          args[2].apply(null, [e]);
        }
        reject(e);
      });
    }

    var sections;
    var sessionpart;
    if (description.type === 'offer') {
      // VERY limited support for SDP munging. Limited to:
      // * changing the order of codecs
      sections = SDPUtils.splitSections(description.sdp);
      sessionpart = sections.shift();
      sections.forEach(function(mediaSection, sdpMLineIndex) {
        var caps = SDPUtils.parseRtpParameters(mediaSection);
        self.transceivers[sdpMLineIndex].localCapabilities = caps;
      });

      this.transceivers.forEach(function(transceiver, sdpMLineIndex) {
        self._gather(transceiver.mid, sdpMLineIndex);
      });
    } else if (description.type === 'answer') {
      sections = SDPUtils.splitSections(self.remoteDescription.sdp);
      sessionpart = sections.shift();
      var isIceLite = SDPUtils.matchPrefix(sessionpart,
          'a=ice-lite').length > 0;
      sections.forEach(function(mediaSection, sdpMLineIndex) {
        var transceiver = self.transceivers[sdpMLineIndex];
        var iceGatherer = transceiver.iceGatherer;
        var iceTransport = transceiver.iceTransport;
        var dtlsTransport = transceiver.dtlsTransport;
        var localCapabilities = transceiver.localCapabilities;
        var remoteCapabilities = transceiver.remoteCapabilities;

        // treat bundle-only as not-rejected.
        var rejected = SDPUtils.isRejected(mediaSection) &&
            !SDPUtils.matchPrefix(mediaSection, 'a=bundle-only').length === 1;

        if (!rejected && !transceiver.isDatachannel) {
          var remoteIceParameters = SDPUtils.getIceParameters(
              mediaSection, sessionpart);
          var remoteDtlsParameters = SDPUtils.getDtlsParameters(
              mediaSection, sessionpart);
          if (isIceLite) {
            remoteDtlsParameters.role = 'server';
          }

          if (!self.usingBundle || sdpMLineIndex === 0) {
            self._gather(transceiver.mid, sdpMLineIndex);
            if (iceTransport.state === 'new') {
              iceTransport.start(iceGatherer, remoteIceParameters,
                  isIceLite ? 'controlling' : 'controlled');
            }
            if (dtlsTransport.state === 'new') {
              dtlsTransport.start(remoteDtlsParameters);
            }
          }

          // Calculate intersection of capabilities.
          var params = getCommonCapabilities(localCapabilities,
              remoteCapabilities);

          // Start the RTCRtpSender. The RTCRtpReceiver for this
          // transceiver has already been started in setRemoteDescription.
          self._transceive(transceiver,
              params.codecs.length > 0,
              false);
        }
      });
    }

    this.localDescription = {
      type: description.type,
      sdp: description.sdp
    };
    switch (description.type) {
      case 'offer':
        this._updateSignalingState('have-local-offer');
        break;
      case 'answer':
        this._updateSignalingState('stable');
        break;
      default:
        throw new TypeError('unsupported type "' + description.type +
            '"');
    }

    // If a success callback was provided, emit ICE candidates after it
    // has been executed. Otherwise, emit callback after the Promise is
    // resolved.
    var cb = arguments.length > 1 && typeof arguments[1] === 'function' &&
        arguments[1];
    return new Promise(function(resolve) {
      if (cb) {
        cb.apply(null);
      }
      resolve();
    });
  };

  RTCPeerConnection.prototype.setRemoteDescription = function(description) {
    var self = this;
    var args = arguments;

    if (!isActionAllowedInSignalingState('setRemoteDescription',
        description.type, this.signalingState)) {
      return new Promise(function(resolve, reject) {
        var e = new Error('Can not set remote ' + description.type +
            ' in state ' + self.signalingState);
        e.name = 'InvalidStateError';
        if (args.length > 2 && typeof args[2] === 'function') {
          args[2].apply(null, [e]);
        }
        reject(e);
      });
    }

    var streams = {};
    this.remoteStreams.forEach(function(stream) {
      streams[stream.id] = stream;
    });
    var receiverList = [];
    var sections = SDPUtils.splitSections(description.sdp);
    var sessionpart = sections.shift();
    var isIceLite = SDPUtils.matchPrefix(sessionpart,
        'a=ice-lite').length > 0;
    var usingBundle = SDPUtils.matchPrefix(sessionpart,
        'a=group:BUNDLE ').length > 0;
    this.usingBundle = usingBundle;
    var iceOptions = SDPUtils.matchPrefix(sessionpart,
        'a=ice-options:')[0];
    if (iceOptions) {
      this.canTrickleIceCandidates = iceOptions.substr(14).split(' ')
          .indexOf('trickle') >= 0;
    } else {
      this.canTrickleIceCandidates = false;
    }

    sections.forEach(function(mediaSection, sdpMLineIndex) {
      var lines = SDPUtils.splitLines(mediaSection);
      var kind = SDPUtils.getKind(mediaSection);
      // treat bundle-only as not-rejected.
      var rejected = SDPUtils.isRejected(mediaSection) &&
          !SDPUtils.matchPrefix(mediaSection, 'a=bundle-only').length === 1;
      var protocol = lines[0].substr(2).split(' ')[2];

      var direction = SDPUtils.getDirection(mediaSection, sessionpart);
      var remoteMsid = SDPUtils.parseMsid(mediaSection);

      var mid = SDPUtils.getMid(mediaSection) || SDPUtils.generateIdentifier();

      // Reject datachannels which are not implemented yet.
      if (kind === 'application' && protocol === 'DTLS/SCTP') {
        self.transceivers[sdpMLineIndex] = {
          mid: mid,
          isDatachannel: true
        };
        return;
      }

      var transceiver;
      var iceGatherer;
      var iceTransport;
      var dtlsTransport;
      var rtpReceiver;
      var sendEncodingParameters;
      var recvEncodingParameters;
      var localCapabilities;

      var track;
      // FIXME: ensure the mediaSection has rtcp-mux set.
      var remoteCapabilities = SDPUtils.parseRtpParameters(mediaSection);
      var remoteIceParameters;
      var remoteDtlsParameters;
      if (!rejected) {
        remoteIceParameters = SDPUtils.getIceParameters(mediaSection,
            sessionpart);
        remoteDtlsParameters = SDPUtils.getDtlsParameters(mediaSection,
            sessionpart);
        remoteDtlsParameters.role = 'client';
      }
      recvEncodingParameters =
          SDPUtils.parseRtpEncodingParameters(mediaSection);

      var rtcpParameters = SDPUtils.parseRtcpParameters(mediaSection);

      var isComplete = SDPUtils.matchPrefix(mediaSection,
          'a=end-of-candidates', sessionpart).length > 0;
      var cands = SDPUtils.matchPrefix(mediaSection, 'a=candidate:')
          .map(function(cand) {
            return SDPUtils.parseCandidate(cand);
          })
          .filter(function(cand) {
            return cand.component === 1;
          });

      // Check if we can use BUNDLE and dispose transports.
      if ((description.type === 'offer' || description.type === 'answer') &&
          !rejected && usingBundle && sdpMLineIndex > 0 &&
          self.transceivers[sdpMLineIndex]) {
        self._disposeIceAndDtlsTransports(sdpMLineIndex);
        self.transceivers[sdpMLineIndex].iceGatherer =
            self.transceivers[0].iceGatherer;
        self.transceivers[sdpMLineIndex].iceTransport =
            self.transceivers[0].iceTransport;
        self.transceivers[sdpMLineIndex].dtlsTransport =
            self.transceivers[0].dtlsTransport;
        if (self.transceivers[sdpMLineIndex].rtpSender) {
          self.transceivers[sdpMLineIndex].rtpSender.setTransport(
              self.transceivers[0].dtlsTransport);
        }
        if (self.transceivers[sdpMLineIndex].rtpReceiver) {
          self.transceivers[sdpMLineIndex].rtpReceiver.setTransport(
              self.transceivers[0].dtlsTransport);
        }
      }
      if (description.type === 'offer' && !rejected) {
        transceiver = self.transceivers[sdpMLineIndex] ||
            self._createTransceiver(kind);
        transceiver.mid = mid;

        if (!transceiver.iceGatherer) {
          transceiver.iceGatherer = self._createIceGatherer(sdpMLineIndex,
              usingBundle);
        }

        if (cands.length && transceiver.iceTransport.state === 'new') {
          if (isComplete && (!usingBundle || sdpMLineIndex === 0)) {
            transceiver.iceTransport.setRemoteCandidates(cands);
          } else {
            cands.forEach(function(candidate) {
              maybeAddCandidate(transceiver.iceTransport, candidate);
            });
          }
        }

        localCapabilities = window.RTCRtpReceiver.getCapabilities(kind);

        // filter RTX until additional stuff needed for RTX is implemented
        // in adapter.js
        if (edgeVersion < 15019) {
          localCapabilities.codecs = localCapabilities.codecs.filter(
              function(codec) {
                return codec.name !== 'rtx';
              });
        }

        sendEncodingParameters = transceiver.sendEncodingParameters || [{
          ssrc: (2 * sdpMLineIndex + 2) * 1001
        }];

        var isNewTrack = false;
        if (direction === 'sendrecv' || direction === 'sendonly') {
          isNewTrack = !transceiver.rtpReceiver;
          rtpReceiver = transceiver.rtpReceiver ||
              new window.RTCRtpReceiver(transceiver.dtlsTransport, kind);

          if (isNewTrack) {
            var stream;
            track = rtpReceiver.track;
            // FIXME: does not work with Plan B.
            if (remoteMsid) {
              if (!streams[remoteMsid.stream]) {
                streams[remoteMsid.stream] = new window.MediaStream();
                Object.defineProperty(streams[remoteMsid.stream], 'id', {
                  get: function() {
                    return remoteMsid.stream;
                  }
                });
              }
              Object.defineProperty(track, 'id', {
                get: function() {
                  return remoteMsid.track;
                }
              });
              stream = streams[remoteMsid.stream];
            } else {
              if (!streams.default) {
                streams.default = new window.MediaStream();
              }
              stream = streams.default;
            }
            stream.addTrack(track);
            receiverList.push([track, rtpReceiver, stream]);
          }
        }

        transceiver.localCapabilities = localCapabilities;
        transceiver.remoteCapabilities = remoteCapabilities;
        transceiver.rtpReceiver = rtpReceiver;
        transceiver.rtcpParameters = rtcpParameters;
        transceiver.sendEncodingParameters = sendEncodingParameters;
        transceiver.recvEncodingParameters = recvEncodingParameters;

        // Start the RTCRtpReceiver now. The RTPSender is started in
        // setLocalDescription.
        self._transceive(self.transceivers[sdpMLineIndex],
            false,
            isNewTrack);
      } else if (description.type === 'answer' && !rejected) {
        transceiver = self.transceivers[sdpMLineIndex];
        iceGatherer = transceiver.iceGatherer;
        iceTransport = transceiver.iceTransport;
        dtlsTransport = transceiver.dtlsTransport;
        rtpReceiver = transceiver.rtpReceiver;
        sendEncodingParameters = transceiver.sendEncodingParameters;
        localCapabilities = transceiver.localCapabilities;

        self.transceivers[sdpMLineIndex].recvEncodingParameters =
            recvEncodingParameters;
        self.transceivers[sdpMLineIndex].remoteCapabilities =
            remoteCapabilities;
        self.transceivers[sdpMLineIndex].rtcpParameters = rtcpParameters;

        if (cands.length && iceTransport.state === 'new') {
          if ((isIceLite || isComplete) &&
              (!usingBundle || sdpMLineIndex === 0)) {
            iceTransport.setRemoteCandidates(cands);
          } else {
            cands.forEach(function(candidate) {
              maybeAddCandidate(transceiver.iceTransport, candidate);
            });
          }
        }

        if (!usingBundle || sdpMLineIndex === 0) {
          if (iceTransport.state === 'new') {
            iceTransport.start(iceGatherer, remoteIceParameters,
                'controlling');
          }
          if (dtlsTransport.state === 'new') {
            dtlsTransport.start(remoteDtlsParameters);
          }
        }

        self._transceive(transceiver,
            direction === 'sendrecv' || direction === 'recvonly',
            direction === 'sendrecv' || direction === 'sendonly');

        if (rtpReceiver &&
            (direction === 'sendrecv' || direction === 'sendonly')) {
          track = rtpReceiver.track;
          if (remoteMsid) {
            if (!streams[remoteMsid.stream]) {
              streams[remoteMsid.stream] = new window.MediaStream();
            }
            streams[remoteMsid.stream].addTrack(track);
            receiverList.push([track, rtpReceiver, streams[remoteMsid.stream]]);
          } else {
            if (!streams.default) {
              streams.default = new window.MediaStream();
            }
            streams.default.addTrack(track);
            receiverList.push([track, rtpReceiver, streams.default]);
          }
        } else {
          // FIXME: actually the receiver should be created later.
          delete transceiver.rtpReceiver;
        }
      }
    });

    if (this._dtlsRole === undefined) {
      this._dtlsRole = description.type === 'offer' ? 'active' : 'passive';
    }

    this.remoteDescription = {
      type: description.type,
      sdp: description.sdp
    };
    switch (description.type) {
      case 'offer':
        this._updateSignalingState('have-remote-offer');
        break;
      case 'answer':
        this._updateSignalingState('stable');
        break;
      default:
        throw new TypeError('unsupported type "' + description.type +
            '"');
    }
    Object.keys(streams).forEach(function(sid) {
      var stream = streams[sid];
      if (stream.getTracks().length) {
        if (self.remoteStreams.indexOf(stream) === -1) {
          self.remoteStreams.push(stream);
          var event = new Event('addstream');
          event.stream = stream;
          window.setTimeout(function() {
            self.dispatchEvent(event);
            if (typeof self.onaddstream === 'function') {
              self.onaddstream(event);
            }
          });
        }

        receiverList.forEach(function(item) {
          var track = item[0];
          var receiver = item[1];
          if (stream.id !== item[2].id) {
            return;
          }
          var trackEvent = new Event('track');
          trackEvent.track = track;
          trackEvent.receiver = receiver;
          trackEvent.transceiver = {receiver: receiver};
          trackEvent.streams = [stream];
          window.setTimeout(function() {
            self.dispatchEvent(trackEvent);
            if (typeof self.ontrack === 'function') {
              self.ontrack(trackEvent);
            }
          });
        });
      }
    });

    // check whether addIceCandidate({}) was called within four seconds after
    // setRemoteDescription.
    window.setTimeout(function() {
      if (!(self && self.transceivers)) {
        return;
      }
      self.transceivers.forEach(function(transceiver) {
        if (transceiver.iceTransport &&
            transceiver.iceTransport.state === 'new' &&
            transceiver.iceTransport.getRemoteCandidates().length > 0) {
          console.warn('Timeout for addRemoteCandidate. Consider sending ' +
              'an end-of-candidates notification');
          transceiver.iceTransport.addRemoteCandidate({});
        }
      });
    }, 4000);

    return new Promise(function(resolve) {
      if (args.length > 1 && typeof args[1] === 'function') {
        args[1].apply(null);
      }
      resolve();
    });
  };

  RTCPeerConnection.prototype.close = function() {
    this.transceivers.forEach(function(transceiver) {
      /* not yet
      if (transceiver.iceGatherer) {
        transceiver.iceGatherer.close();
      }
      */
      if (transceiver.iceTransport) {
        transceiver.iceTransport.stop();
      }
      if (transceiver.dtlsTransport) {
        transceiver.dtlsTransport.stop();
      }
      if (transceiver.rtpSender) {
        transceiver.rtpSender.stop();
      }
      if (transceiver.rtpReceiver) {
        transceiver.rtpReceiver.stop();
      }
    });
    // FIXME: clean up tracks, local streams, remote streams, etc
    this._updateSignalingState('closed');
  };

  // Update the signaling state.
  RTCPeerConnection.prototype._updateSignalingState = function(newState) {
    this.signalingState = newState;
    var event = new Event('signalingstatechange');
    this.dispatchEvent(event);
    if (typeof this.onsignalingstatechange === 'function') {
      this.onsignalingstatechange(event);
    }
  };

  // Determine whether to fire the negotiationneeded event.
  RTCPeerConnection.prototype._maybeFireNegotiationNeeded = function() {
    var self = this;
    if (this.signalingState !== 'stable' || this.needNegotiation === true) {
      return;
    }
    this.needNegotiation = true;
    window.setTimeout(function() {
      if (self.needNegotiation === false) {
        return;
      }
      self.needNegotiation = false;
      var event = new Event('negotiationneeded');
      self.dispatchEvent(event);
      if (typeof self.onnegotiationneeded === 'function') {
        self.onnegotiationneeded(event);
      }
    }, 0);
  };

  // Update the connection state.
  RTCPeerConnection.prototype._updateConnectionState = function() {
    var newState;
    var states = {
      'new': 0,
      closed: 0,
      connecting: 0,
      checking: 0,
      connected: 0,
      completed: 0,
      disconnected: 0,
      failed: 0
    };
    this.transceivers.forEach(function(transceiver) {
      states[transceiver.iceTransport.state]++;
      states[transceiver.dtlsTransport.state]++;
    });
    // ICETransport.completed and connected are the same for this purpose.
    states.connected += states.completed;

    newState = 'new';
    if (states.failed > 0) {
      newState = 'failed';
    } else if (states.connecting > 0 || states.checking > 0) {
      newState = 'connecting';
    } else if (states.disconnected > 0) {
      newState = 'disconnected';
    } else if (states.new > 0) {
      newState = 'new';
    } else if (states.connected > 0 || states.completed > 0) {
      newState = 'connected';
    }

    if (newState !== this.iceConnectionState) {
      this.iceConnectionState = newState;
      var event = new Event('iceconnectionstatechange');
      this.dispatchEvent(event);
      if (typeof this.oniceconnectionstatechange === 'function') {
        this.oniceconnectionstatechange(event);
      }
    }
  };

  RTCPeerConnection.prototype.createOffer = function() {
    var self = this;
    var args = arguments;

    var offerOptions;
    if (arguments.length === 1 && typeof arguments[0] !== 'function') {
      offerOptions = arguments[0];
    } else if (arguments.length === 3) {
      offerOptions = arguments[2];
    }

    var numAudioTracks = this.transceivers.filter(function(t) {
      return t.kind === 'audio';
    }).length;
    var numVideoTracks = this.transceivers.filter(function(t) {
      return t.kind === 'video';
    }).length;

    // Determine number of audio and video tracks we need to send/recv.
    if (offerOptions) {
      // Reject Chrome legacy constraints.
      if (offerOptions.mandatory || offerOptions.optional) {
        throw new TypeError(
            'Legacy mandatory/optional constraints not supported.');
      }
      if (offerOptions.offerToReceiveAudio !== undefined) {
        if (offerOptions.offerToReceiveAudio === true) {
          numAudioTracks = 1;
        } else if (offerOptions.offerToReceiveAudio === false) {
          numAudioTracks = 0;
        } else {
          numAudioTracks = offerOptions.offerToReceiveAudio;
        }
      }
      if (offerOptions.offerToReceiveVideo !== undefined) {
        if (offerOptions.offerToReceiveVideo === true) {
          numVideoTracks = 1;
        } else if (offerOptions.offerToReceiveVideo === false) {
          numVideoTracks = 0;
        } else {
          numVideoTracks = offerOptions.offerToReceiveVideo;
        }
      }
    }

    this.transceivers.forEach(function(transceiver) {
      if (transceiver.kind === 'audio') {
        numAudioTracks--;
        if (numAudioTracks < 0) {
          transceiver.wantReceive = false;
        }
      } else if (transceiver.kind === 'video') {
        numVideoTracks--;
        if (numVideoTracks < 0) {
          transceiver.wantReceive = false;
        }
      }
    });

    // Create M-lines for recvonly streams.
    while (numAudioTracks > 0 || numVideoTracks > 0) {
      if (numAudioTracks > 0) {
        this._createTransceiver('audio');
        numAudioTracks--;
      }
      if (numVideoTracks > 0) {
        this._createTransceiver('video');
        numVideoTracks--;
      }
    }

    var sdp = SDPUtils.writeSessionBoilerplate(this._sdpSessionId,
        this._sdpSessionVersion++);
    this.transceivers.forEach(function(transceiver, sdpMLineIndex) {
      // For each track, create an ice gatherer, ice transport,
      // dtls transport, potentially rtpsender and rtpreceiver.
      var track = transceiver.track;
      var kind = transceiver.kind;
      var mid = SDPUtils.generateIdentifier();
      transceiver.mid = mid;

      if (!transceiver.iceGatherer) {
        transceiver.iceGatherer = self._createIceGatherer(sdpMLineIndex,
            self.usingBundle);
      }

      var localCapabilities = window.RTCRtpSender.getCapabilities(kind);
      // filter RTX until additional stuff needed for RTX is implemented
      // in adapter.js
      if (edgeVersion < 15019) {
        localCapabilities.codecs = localCapabilities.codecs.filter(
            function(codec) {
              return codec.name !== 'rtx';
            });
      }
      localCapabilities.codecs.forEach(function(codec) {
        // work around https://bugs.chromium.org/p/webrtc/issues/detail?id=6552
        // by adding level-asymmetry-allowed=1
        if (codec.name === 'H264' &&
            codec.parameters['level-asymmetry-allowed'] === undefined) {
          codec.parameters['level-asymmetry-allowed'] = '1';
        }
      });

      // generate an ssrc now, to be used later in rtpSender.send
      var sendEncodingParameters = transceiver.sendEncodingParameters || [{
        ssrc: (2 * sdpMLineIndex + 1) * 1001
      }];
      if (track) {
        // add RTX
        if (edgeVersion >= 15019 && kind === 'video' &&
            !sendEncodingParameters[0].rtx) {
          sendEncodingParameters[0].rtx = {
            ssrc: sendEncodingParameters[0].ssrc + 1
          };
        }
      }

      if (transceiver.wantReceive) {
        transceiver.rtpReceiver = new window.RTCRtpReceiver(
            transceiver.dtlsTransport, kind);
      }

      transceiver.localCapabilities = localCapabilities;
      transceiver.sendEncodingParameters = sendEncodingParameters;
    });

    // always offer BUNDLE and dispose on return if not supported.
    if (this._config.bundlePolicy !== 'max-compat') {
      sdp += 'a=group:BUNDLE ' + this.transceivers.map(function(t) {
        return t.mid;
      }).join(' ') + '\r\n';
    }
    sdp += 'a=ice-options:trickle\r\n';

    this.transceivers.forEach(function(transceiver, sdpMLineIndex) {
      sdp += writeMediaSection(transceiver, transceiver.localCapabilities,
          'offer', transceiver.stream, self._dtlsRole);
      sdp += 'a=rtcp-rsize\r\n';

      if (transceiver.iceGatherer && self.iceGatheringState !== 'new' &&
          (sdpMLineIndex === 0 || !self.usingBundle)) {
        transceiver.iceGatherer.getLocalCandidates().forEach(function(cand) {
          cand.component = 1;
          sdp += 'a=' + SDPUtils.writeCandidate(cand) + '\r\n';
        });

        if (transceiver.iceGatherer.state === 'completed') {
          sdp += 'a=end-of-candidates\r\n';
        }
      }
    });

    var desc = new window.RTCSessionDescription({
      type: 'offer',
      sdp: sdp
    });
    return new Promise(function(resolve) {
      if (args.length > 0 && typeof args[0] === 'function') {
        args[0].apply(null, [desc]);
        resolve();
        return;
      }
      resolve(desc);
    });
  };

  RTCPeerConnection.prototype.createAnswer = function() {
    var self = this;
    var args = arguments;

    var sdp = SDPUtils.writeSessionBoilerplate(this._sdpSessionId,
        this._sdpSessionVersion++);
    if (this.usingBundle) {
      sdp += 'a=group:BUNDLE ' + this.transceivers.map(function(t) {
        return t.mid;
      }).join(' ') + '\r\n';
    }
    var mediaSectionsInOffer = SDPUtils.splitSections(
        this.remoteDescription.sdp).length - 1;
    this.transceivers.forEach(function(transceiver, sdpMLineIndex) {
      if (sdpMLineIndex + 1 > mediaSectionsInOffer) {
        return;
      }
      if (transceiver.isDatachannel) {
        sdp += 'm=application 0 DTLS/SCTP 5000\r\n' +
            'c=IN IP4 0.0.0.0\r\n' +
            'a=mid:' + transceiver.mid + '\r\n';
        return;
      }

      // FIXME: look at direction.
      if (transceiver.stream) {
        var localTrack;
        if (transceiver.kind === 'audio') {
          localTrack = transceiver.stream.getAudioTracks()[0];
        } else if (transceiver.kind === 'video') {
          localTrack = transceiver.stream.getVideoTracks()[0];
        }
        if (localTrack) {
          // add RTX
          if (edgeVersion >= 15019 && transceiver.kind === 'video' &&
              !transceiver.sendEncodingParameters[0].rtx) {
            transceiver.sendEncodingParameters[0].rtx = {
              ssrc: transceiver.sendEncodingParameters[0].ssrc + 1
            };
          }
        }
      }

      // Calculate intersection of capabilities.
      var commonCapabilities = getCommonCapabilities(
          transceiver.localCapabilities,
          transceiver.remoteCapabilities);

      var hasRtx = commonCapabilities.codecs.filter(function(c) {
        return c.name.toLowerCase() === 'rtx';
      }).length;
      if (!hasRtx && transceiver.sendEncodingParameters[0].rtx) {
        delete transceiver.sendEncodingParameters[0].rtx;
      }

      sdp += writeMediaSection(transceiver, commonCapabilities,
          'answer', transceiver.stream, self._dtlsRole);
      if (transceiver.rtcpParameters &&
          transceiver.rtcpParameters.reducedSize) {
        sdp += 'a=rtcp-rsize\r\n';
      }
    });

    var desc = new window.RTCSessionDescription({
      type: 'answer',
      sdp: sdp
    });
    return new Promise(function(resolve) {
      if (args.length > 0 && typeof args[0] === 'function') {
        args[0].apply(null, [desc]);
        resolve();
        return;
      }
      resolve(desc);
    });
  };

  RTCPeerConnection.prototype.addIceCandidate = function(candidate) {
    var err;
    var sections;
    if (!candidate || candidate.candidate === '') {
      for (var j = 0; j < this.transceivers.length; j++) {
        if (this.transceivers[j].isDatachannel) {
          continue;
        }
        this.transceivers[j].iceTransport.addRemoteCandidate({});
        sections = SDPUtils.splitSections(this.remoteDescription.sdp);
        sections[j + 1] += 'a=end-of-candidates\r\n';
        this.remoteDescription.sdp = sections.join('');
        if (this.usingBundle) {
          break;
        }
      }
    } else if (!(candidate.sdpMLineIndex !== undefined || candidate.sdpMid)) {
      throw new TypeError('sdpMLineIndex or sdpMid required');
    } else if (!this.remoteDescription) {
      err = new Error('Can not add ICE candidate without ' +
          'a remote description');
      err.name = 'InvalidStateError';
    } else {
      var sdpMLineIndex = candidate.sdpMLineIndex;
      if (candidate.sdpMid) {
        for (var i = 0; i < this.transceivers.length; i++) {
          if (this.transceivers[i].mid === candidate.sdpMid) {
            sdpMLineIndex = i;
            break;
          }
        }
      }
      var transceiver = this.transceivers[sdpMLineIndex];
      if (transceiver) {
        if (transceiver.isDatachannel) {
          return Promise.resolve();
        }
        var cand = Object.keys(candidate.candidate).length > 0 ?
            SDPUtils.parseCandidate(candidate.candidate) : {};
        // Ignore Chrome's invalid candidates since Edge does not like them.
        if (cand.protocol === 'tcp' && (cand.port === 0 || cand.port === 9)) {
          return Promise.resolve();
        }
        // Ignore RTCP candidates, we assume RTCP-MUX.
        if (cand.component && cand.component !== 1) {
          return Promise.resolve();
        }
        // when using bundle, avoid adding candidates to the wrong
        // ice transport. And avoid adding candidates added in the SDP.
        if (sdpMLineIndex === 0 || (sdpMLineIndex > 0 &&
            transceiver.iceTransport !== this.transceivers[0].iceTransport)) {
          if (!maybeAddCandidate(transceiver.iceTransport, cand)) {
            err = new Error('Can not add ICE candidate');
            err.name = 'OperationError';
          }
        }

        if (!err) {
          // update the remoteDescription.
          var candidateString = candidate.candidate.trim();
          if (candidateString.indexOf('a=') === 0) {
            candidateString = candidateString.substr(2);
          }
          sections = SDPUtils.splitSections(this.remoteDescription.sdp);
          sections[sdpMLineIndex + 1] += 'a=' +
              (cand.type ? candidateString : 'end-of-candidates')
              + '\r\n';
          this.remoteDescription.sdp = sections.join('');
        }
      } else {
        err = new Error('Can not add ICE candidate');
        err.name = 'OperationError';
      }
    }
    var args = arguments;
    return new Promise(function(resolve, reject) {
      if (err) {
        if (args.length > 2 && typeof args[2] === 'function') {
          args[2].apply(null, [err]);
        }
        reject(err);
      } else {
        if (args.length > 1 && typeof args[1] === 'function') {
          args[1].apply(null);
        }
        resolve();
      }
    });
  };

  RTCPeerConnection.prototype.getStats = function() {
    var promises = [];
    this.transceivers.forEach(function(transceiver) {
      ['rtpSender', 'rtpReceiver', 'iceGatherer', 'iceTransport',
          'dtlsTransport'].forEach(function(method) {
            if (transceiver[method]) {
              promises.push(transceiver[method].getStats());
            }
          });
    });
    var cb = arguments.length > 1 && typeof arguments[1] === 'function' &&
        arguments[1];
    var fixStatsType = function(stat) {
      return {
        inboundrtp: 'inbound-rtp',
        outboundrtp: 'outbound-rtp',
        candidatepair: 'candidate-pair',
        localcandidate: 'local-candidate',
        remotecandidate: 'remote-candidate'
      }[stat.type] || stat.type;
    };
    return new Promise(function(resolve) {
      // shim getStats with maplike support
      var results = new Map();
      Promise.all(promises).then(function(res) {
        res.forEach(function(result) {
          Object.keys(result).forEach(function(id) {
            result[id].type = fixStatsType(result[id]);
            results.set(id, result[id]);
          });
        });
        if (cb) {
          cb.apply(null, results);
        }
        resolve(results);
      });
    });
  };
  return RTCPeerConnection;
};

},{"sdp":2}],2:[function(require,module,exports){
 /* eslint-env node */
'use strict';

// SDP helpers.
var SDPUtils = {};

// Generate an alphanumeric identifier for cname or mids.
// TODO: use UUIDs instead? https://gist.github.com/jed/982883
SDPUtils.generateIdentifier = function() {
  return Math.random().toString(36).substr(2, 10);
};

// The RTCP CNAME used by all peerconnections from the same JS.
SDPUtils.localCName = SDPUtils.generateIdentifier();

// Splits SDP into lines, dealing with both CRLF and LF.
SDPUtils.splitLines = function(blob) {
  return blob.trim().split('\n').map(function(line) {
    return line.trim();
  });
};
// Splits SDP into sessionpart and mediasections. Ensures CRLF.
SDPUtils.splitSections = function(blob) {
  var parts = blob.split('\nm=');
  return parts.map(function(part, index) {
    return (index > 0 ? 'm=' + part : part).trim() + '\r\n';
  });
};

// Returns lines that start with a certain prefix.
SDPUtils.matchPrefix = function(blob, prefix) {
  return SDPUtils.splitLines(blob).filter(function(line) {
    return line.indexOf(prefix) === 0;
  });
};

// Parses an ICE candidate line. Sample input:
// candidate:702786350 2 udp 41819902 8.8.8.8 60769 typ relay raddr 8.8.8.8
// rport 55996"
SDPUtils.parseCandidate = function(line) {
  var parts;
  // Parse both variants.
  if (line.indexOf('a=candidate:') === 0) {
    parts = line.substring(12).split(' ');
  } else {
    parts = line.substring(10).split(' ');
  }

  var candidate = {
    foundation: parts[0],
    component: parseInt(parts[1], 10),
    protocol: parts[2].toLowerCase(),
    priority: parseInt(parts[3], 10),
    ip: parts[4],
    port: parseInt(parts[5], 10),
    // skip parts[6] == 'typ'
    type: parts[7]
  };

  for (var i = 8; i < parts.length; i += 2) {
    switch (parts[i]) {
      case 'raddr':
        candidate.relatedAddress = parts[i + 1];
        break;
      case 'rport':
        candidate.relatedPort = parseInt(parts[i + 1], 10);
        break;
      case 'tcptype':
        candidate.tcpType = parts[i + 1];
        break;
      case 'ufrag':
        candidate.ufrag = parts[i + 1]; // for backward compability.
        candidate.usernameFragment = parts[i + 1];
        break;
      default: // extension handling, in particular ufrag
        candidate[parts[i]] = parts[i + 1];
        break;
    }
  }
  return candidate;
};

// Translates a candidate object into SDP candidate attribute.
SDPUtils.writeCandidate = function(candidate) {
  var sdp = [];
  sdp.push(candidate.foundation);
  sdp.push(candidate.component);
  sdp.push(candidate.protocol.toUpperCase());
  sdp.push(candidate.priority);
  sdp.push(candidate.ip);
  sdp.push(candidate.port);

  var type = candidate.type;
  sdp.push('typ');
  sdp.push(type);
  if (type !== 'host' && candidate.relatedAddress &&
      candidate.relatedPort) {
    sdp.push('raddr');
    sdp.push(candidate.relatedAddress); // was: relAddr
    sdp.push('rport');
    sdp.push(candidate.relatedPort); // was: relPort
  }
  if (candidate.tcpType && candidate.protocol.toLowerCase() === 'tcp') {
    sdp.push('tcptype');
    sdp.push(candidate.tcpType);
  }
  if (candidate.ufrag) {
    sdp.push('ufrag');
    sdp.push(candidate.ufrag);
  }
  return 'candidate:' + sdp.join(' ');
};

// Parses an ice-options line, returns an array of option tags.
// a=ice-options:foo bar
SDPUtils.parseIceOptions = function(line) {
  return line.substr(14).split(' ');
}

// Parses an rtpmap line, returns RTCRtpCoddecParameters. Sample input:
// a=rtpmap:111 opus/48000/2
SDPUtils.parseRtpMap = function(line) {
  var parts = line.substr(9).split(' ');
  var parsed = {
    payloadType: parseInt(parts.shift(), 10) // was: id
  };

  parts = parts[0].split('/');

  parsed.name = parts[0];
  parsed.clockRate = parseInt(parts[1], 10); // was: clockrate
  // was: channels
  parsed.numChannels = parts.length === 3 ? parseInt(parts[2], 10) : 1;
  return parsed;
};

// Generate an a=rtpmap line from RTCRtpCodecCapability or
// RTCRtpCodecParameters.
SDPUtils.writeRtpMap = function(codec) {
  var pt = codec.payloadType;
  if (codec.preferredPayloadType !== undefined) {
    pt = codec.preferredPayloadType;
  }
  return 'a=rtpmap:' + pt + ' ' + codec.name + '/' + codec.clockRate +
      (codec.numChannels !== 1 ? '/' + codec.numChannels : '') + '\r\n';
};

// Parses an a=extmap line (headerextension from RFC 5285). Sample input:
// a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
// a=extmap:2/sendonly urn:ietf:params:rtp-hdrext:toffset
SDPUtils.parseExtmap = function(line) {
  var parts = line.substr(9).split(' ');
  return {
    id: parseInt(parts[0], 10),
    direction: parts[0].indexOf('/') > 0 ? parts[0].split('/')[1] : 'sendrecv',
    uri: parts[1]
  };
};

// Generates a=extmap line from RTCRtpHeaderExtensionParameters or
// RTCRtpHeaderExtension.
SDPUtils.writeExtmap = function(headerExtension) {
  return 'a=extmap:' + (headerExtension.id || headerExtension.preferredId) +
      (headerExtension.direction && headerExtension.direction !== 'sendrecv'
          ? '/' + headerExtension.direction
          : '') +
      ' ' + headerExtension.uri + '\r\n';
};

// Parses an ftmp line, returns dictionary. Sample input:
// a=fmtp:96 vbr=on;cng=on
// Also deals with vbr=on; cng=on
SDPUtils.parseFmtp = function(line) {
  var parsed = {};
  var kv;
  var parts = line.substr(line.indexOf(' ') + 1).split(';');
  for (var j = 0; j < parts.length; j++) {
    kv = parts[j].trim().split('=');
    parsed[kv[0].trim()] = kv[1];
  }
  return parsed;
};

// Generates an a=ftmp line from RTCRtpCodecCapability or RTCRtpCodecParameters.
SDPUtils.writeFmtp = function(codec) {
  var line = '';
  var pt = codec.payloadType;
  if (codec.preferredPayloadType !== undefined) {
    pt = codec.preferredPayloadType;
  }
  if (codec.parameters && Object.keys(codec.parameters).length) {
    var params = [];
    Object.keys(codec.parameters).forEach(function(param) {
      params.push(param + '=' + codec.parameters[param]);
    });
    line += 'a=fmtp:' + pt + ' ' + params.join(';') + '\r\n';
  }
  return line;
};

// Parses an rtcp-fb line, returns RTCPRtcpFeedback object. Sample input:
// a=rtcp-fb:98 nack rpsi
SDPUtils.parseRtcpFb = function(line) {
  var parts = line.substr(line.indexOf(' ') + 1).split(' ');
  return {
    type: parts.shift(),
    parameter: parts.join(' ')
  };
};
// Generate a=rtcp-fb lines from RTCRtpCodecCapability or RTCRtpCodecParameters.
SDPUtils.writeRtcpFb = function(codec) {
  var lines = '';
  var pt = codec.payloadType;
  if (codec.preferredPayloadType !== undefined) {
    pt = codec.preferredPayloadType;
  }
  if (codec.rtcpFeedback && codec.rtcpFeedback.length) {
    // FIXME: special handling for trr-int?
    codec.rtcpFeedback.forEach(function(fb) {
      lines += 'a=rtcp-fb:' + pt + ' ' + fb.type +
      (fb.parameter && fb.parameter.length ? ' ' + fb.parameter : '') +
          '\r\n';
    });
  }
  return lines;
};

// Parses an RFC 5576 ssrc media attribute. Sample input:
// a=ssrc:3735928559 cname:something
SDPUtils.parseSsrcMedia = function(line) {
  var sp = line.indexOf(' ');
  var parts = {
    ssrc: parseInt(line.substr(7, sp - 7), 10)
  };
  var colon = line.indexOf(':', sp);
  if (colon > -1) {
    parts.attribute = line.substr(sp + 1, colon - sp - 1);
    parts.value = line.substr(colon + 1);
  } else {
    parts.attribute = line.substr(sp + 1);
  }
  return parts;
};

// Extracts the MID (RFC 5888) from a media section.
// returns the MID or undefined if no mid line was found.
SDPUtils.getMid = function(mediaSection) {
  var mid = SDPUtils.matchPrefix(mediaSection, 'a=mid:')[0];
  if (mid) {
    return mid.substr(6);
  }
}

SDPUtils.parseFingerprint = function(line) {
  var parts = line.substr(14).split(' ');
  return {
    algorithm: parts[0].toLowerCase(), // algorithm is case-sensitive in Edge.
    value: parts[1]
  };
};

// Extracts DTLS parameters from SDP media section or sessionpart.
// FIXME: for consistency with other functions this should only
//   get the fingerprint line as input. See also getIceParameters.
SDPUtils.getDtlsParameters = function(mediaSection, sessionpart) {
  var lines = SDPUtils.matchPrefix(mediaSection + sessionpart,
      'a=fingerprint:');
  // Note: a=setup line is ignored since we use the 'auto' role.
  // Note2: 'algorithm' is not case sensitive except in Edge.
  return {
    role: 'auto',
    fingerprints: lines.map(SDPUtils.parseFingerprint)
  };
};

// Serializes DTLS parameters to SDP.
SDPUtils.writeDtlsParameters = function(params, setupType) {
  var sdp = 'a=setup:' + setupType + '\r\n';
  params.fingerprints.forEach(function(fp) {
    sdp += 'a=fingerprint:' + fp.algorithm + ' ' + fp.value + '\r\n';
  });
  return sdp;
};
// Parses ICE information from SDP media section or sessionpart.
// FIXME: for consistency with other functions this should only
//   get the ice-ufrag and ice-pwd lines as input.
SDPUtils.getIceParameters = function(mediaSection, sessionpart) {
  var lines = SDPUtils.splitLines(mediaSection);
  // Search in session part, too.
  lines = lines.concat(SDPUtils.splitLines(sessionpart));
  var iceParameters = {
    usernameFragment: lines.filter(function(line) {
      return line.indexOf('a=ice-ufrag:') === 0;
    })[0].substr(12),
    password: lines.filter(function(line) {
      return line.indexOf('a=ice-pwd:') === 0;
    })[0].substr(10)
  };
  return iceParameters;
};

// Serializes ICE parameters to SDP.
SDPUtils.writeIceParameters = function(params) {
  return 'a=ice-ufrag:' + params.usernameFragment + '\r\n' +
      'a=ice-pwd:' + params.password + '\r\n';
};

// Parses the SDP media section and returns RTCRtpParameters.
SDPUtils.parseRtpParameters = function(mediaSection) {
  var description = {
    codecs: [],
    headerExtensions: [],
    fecMechanisms: [],
    rtcp: []
  };
  var lines = SDPUtils.splitLines(mediaSection);
  var mline = lines[0].split(' ');
  for (var i = 3; i < mline.length; i++) { // find all codecs from mline[3..]
    var pt = mline[i];
    var rtpmapline = SDPUtils.matchPrefix(
        mediaSection, 'a=rtpmap:' + pt + ' ')[0];
    if (rtpmapline) {
      var codec = SDPUtils.parseRtpMap(rtpmapline);
      var fmtps = SDPUtils.matchPrefix(
          mediaSection, 'a=fmtp:' + pt + ' ');
      // Only the first a=fmtp:<pt> is considered.
      codec.parameters = fmtps.length ? SDPUtils.parseFmtp(fmtps[0]) : {};
      codec.rtcpFeedback = SDPUtils.matchPrefix(
          mediaSection, 'a=rtcp-fb:' + pt + ' ')
        .map(SDPUtils.parseRtcpFb);
      description.codecs.push(codec);
      // parse FEC mechanisms from rtpmap lines.
      switch (codec.name.toUpperCase()) {
        case 'RED':
        case 'ULPFEC':
          description.fecMechanisms.push(codec.name.toUpperCase());
          break;
        default: // only RED and ULPFEC are recognized as FEC mechanisms.
          break;
      }
    }
  }
  SDPUtils.matchPrefix(mediaSection, 'a=extmap:').forEach(function(line) {
    description.headerExtensions.push(SDPUtils.parseExtmap(line));
  });
  // FIXME: parse rtcp.
  return description;
};

// Generates parts of the SDP media section describing the capabilities /
// parameters.
SDPUtils.writeRtpDescription = function(kind, caps) {
  var sdp = '';

  // Build the mline.
  sdp += 'm=' + kind + ' ';
  sdp += caps.codecs.length > 0 ? '9' : '0'; // reject if no codecs.
  sdp += ' UDP/TLS/RTP/SAVPF ';
  sdp += caps.codecs.map(function(codec) {
    if (codec.preferredPayloadType !== undefined) {
      return codec.preferredPayloadType;
    }
    return codec.payloadType;
  }).join(' ') + '\r\n';

  sdp += 'c=IN IP4 0.0.0.0\r\n';
  sdp += 'a=rtcp:9 IN IP4 0.0.0.0\r\n';

  // Add a=rtpmap lines for each codec. Also fmtp and rtcp-fb.
  caps.codecs.forEach(function(codec) {
    sdp += SDPUtils.writeRtpMap(codec);
    sdp += SDPUtils.writeFmtp(codec);
    sdp += SDPUtils.writeRtcpFb(codec);
  });
  var maxptime = 0;
  caps.codecs.forEach(function(codec) {
    if (codec.maxptime > maxptime) {
      maxptime = codec.maxptime;
    }
  });
  if (maxptime > 0) {
    sdp += 'a=maxptime:' + maxptime + '\r\n';
  }
  sdp += 'a=rtcp-mux\r\n';

  caps.headerExtensions.forEach(function(extension) {
    sdp += SDPUtils.writeExtmap(extension);
  });
  // FIXME: write fecMechanisms.
  return sdp;
};

// Parses the SDP media section and returns an array of
// RTCRtpEncodingParameters.
SDPUtils.parseRtpEncodingParameters = function(mediaSection) {
  var encodingParameters = [];
  var description = SDPUtils.parseRtpParameters(mediaSection);
  var hasRed = description.fecMechanisms.indexOf('RED') !== -1;
  var hasUlpfec = description.fecMechanisms.indexOf('ULPFEC') !== -1;

  // filter a=ssrc:... cname:, ignore PlanB-msid
  var ssrcs = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
  .map(function(line) {
    return SDPUtils.parseSsrcMedia(line);
  })
  .filter(function(parts) {
    return parts.attribute === 'cname';
  });
  var primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;
  var secondarySsrc;

  var flows = SDPUtils.matchPrefix(mediaSection, 'a=ssrc-group:FID')
  .map(function(line) {
    var parts = line.split(' ');
    parts.shift();
    return parts.map(function(part) {
      return parseInt(part, 10);
    });
  });
  if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {
    secondarySsrc = flows[0][1];
  }

  description.codecs.forEach(function(codec) {
    if (codec.name.toUpperCase() === 'RTX' && codec.parameters.apt) {
      var encParam = {
        ssrc: primarySsrc,
        codecPayloadType: parseInt(codec.parameters.apt, 10),
        rtx: {
          ssrc: secondarySsrc
        }
      };
      encodingParameters.push(encParam);
      if (hasRed) {
        encParam = JSON.parse(JSON.stringify(encParam));
        encParam.fec = {
          ssrc: secondarySsrc,
          mechanism: hasUlpfec ? 'red+ulpfec' : 'red'
        };
        encodingParameters.push(encParam);
      }
    }
  });
  if (encodingParameters.length === 0 && primarySsrc) {
    encodingParameters.push({
      ssrc: primarySsrc
    });
  }

  // we support both b=AS and b=TIAS but interpret AS as TIAS.
  var bandwidth = SDPUtils.matchPrefix(mediaSection, 'b=');
  if (bandwidth.length) {
    if (bandwidth[0].indexOf('b=TIAS:') === 0) {
      bandwidth = parseInt(bandwidth[0].substr(7), 10);
    } else if (bandwidth[0].indexOf('b=AS:') === 0) {
      // use formula from JSEP to convert b=AS to TIAS value.
      bandwidth = parseInt(bandwidth[0].substr(5), 10) * 1000 * 0.95
          - (50 * 40 * 8);
    } else {
      bandwidth = undefined;
    }
    encodingParameters.forEach(function(params) {
      params.maxBitrate = bandwidth;
    });
  }
  return encodingParameters;
};

// parses http://draft.ortc.org/#rtcrtcpparameters*
SDPUtils.parseRtcpParameters = function(mediaSection) {
  var rtcpParameters = {};

  var cname;
  // Gets the first SSRC. Note that with RTX there might be multiple
  // SSRCs.
  var remoteSsrc = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
      .map(function(line) {
        return SDPUtils.parseSsrcMedia(line);
      })
      .filter(function(obj) {
        return obj.attribute === 'cname';
      })[0];
  if (remoteSsrc) {
    rtcpParameters.cname = remoteSsrc.value;
    rtcpParameters.ssrc = remoteSsrc.ssrc;
  }

  // Edge uses the compound attribute instead of reducedSize
  // compound is !reducedSize
  var rsize = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-rsize');
  rtcpParameters.reducedSize = rsize.length > 0;
  rtcpParameters.compound = rsize.length === 0;

  // parses the rtcp-mux attrіbute.
  // Note that Edge does not support unmuxed RTCP.
  var mux = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-mux');
  rtcpParameters.mux = mux.length > 0;

  return rtcpParameters;
};

// parses either a=msid: or a=ssrc:... msid lines and returns
// the id of the MediaStream and MediaStreamTrack.
SDPUtils.parseMsid = function(mediaSection) {
  var parts;
  var spec = SDPUtils.matchPrefix(mediaSection, 'a=msid:');
  if (spec.length === 1) {
    parts = spec[0].substr(7).split(' ');
    return {stream: parts[0], track: parts[1]};
  }
  var planB = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
  .map(function(line) {
    return SDPUtils.parseSsrcMedia(line);
  })
  .filter(function(parts) {
    return parts.attribute === 'msid';
  });
  if (planB.length > 0) {
    parts = planB[0].value.split(' ');
    return {stream: parts[0], track: parts[1]};
  }
};

// Generate a session ID for SDP.
// https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-20#section-5.2.1
// recommends using a cryptographically random +ve 64-bit value
// but right now this should be acceptable and within the right range
SDPUtils.generateSessionId = function() {
  return Math.random().toString().substr(2, 21);
};

// Write boilder plate for start of SDP
// sessId argument is optional - if not supplied it will
// be generated randomly
// sessVersion is optional and defaults to 2
SDPUtils.writeSessionBoilerplate = function(sessId, sessVer) {
  var sessionId;
  var version = sessVer !== undefined ? sessVer : 2;
  if (sessId) {
    sessionId = sessId;
  } else {
    sessionId = SDPUtils.generateSessionId();
  }
  // FIXME: sess-id should be an NTP timestamp.
  return 'v=0\r\n' +
      'o=thisisadapterortc ' + sessionId + ' ' + version + ' IN IP4 127.0.0.1\r\n' +
      's=-\r\n' +
      't=0 0\r\n';
};

SDPUtils.writeMediaSection = function(transceiver, caps, type, stream) {
  var sdp = SDPUtils.writeRtpDescription(transceiver.kind, caps);

  // Map ICE parameters (ufrag, pwd) to SDP.
  sdp += SDPUtils.writeIceParameters(
      transceiver.iceGatherer.getLocalParameters());

  // Map DTLS parameters to SDP.
  sdp += SDPUtils.writeDtlsParameters(
      transceiver.dtlsTransport.getLocalParameters(),
      type === 'offer' ? 'actpass' : 'active');

  sdp += 'a=mid:' + transceiver.mid + '\r\n';

  if (transceiver.direction) {
    sdp += 'a=' + transceiver.direction + '\r\n';
  } else if (transceiver.rtpSender && transceiver.rtpReceiver) {
    sdp += 'a=sendrecv\r\n';
  } else if (transceiver.rtpSender) {
    sdp += 'a=sendonly\r\n';
  } else if (transceiver.rtpReceiver) {
    sdp += 'a=recvonly\r\n';
  } else {
    sdp += 'a=inactive\r\n';
  }

  if (transceiver.rtpSender) {
    // spec.
    var msid = 'msid:' + stream.id + ' ' +
        transceiver.rtpSender.track.id + '\r\n';
    sdp += 'a=' + msid;

    // for Chrome.
    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +
        ' ' + msid;
    if (transceiver.sendEncodingParameters[0].rtx) {
      sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +
          ' ' + msid;
      sdp += 'a=ssrc-group:FID ' +
          transceiver.sendEncodingParameters[0].ssrc + ' ' +
          transceiver.sendEncodingParameters[0].rtx.ssrc +
          '\r\n';
    }
  }
  // FIXME: this should be written by writeRtpDescription.
  sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +
      ' cname:' + SDPUtils.localCName + '\r\n';
  if (transceiver.rtpSender && transceiver.sendEncodingParameters[0].rtx) {
    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +
        ' cname:' + SDPUtils.localCName + '\r\n';
  }
  return sdp;
};

// Gets the direction from the mediaSection or the sessionpart.
SDPUtils.getDirection = function(mediaSection, sessionpart) {
  // Look for sendrecv, sendonly, recvonly, inactive, default to sendrecv.
  var lines = SDPUtils.splitLines(mediaSection);
  for (var i = 0; i < lines.length; i++) {
    switch (lines[i]) {
      case 'a=sendrecv':
      case 'a=sendonly':
      case 'a=recvonly':
      case 'a=inactive':
        return lines[i].substr(2);
      default:
        // FIXME: What should happen here?
    }
  }
  if (sessionpart) {
    return SDPUtils.getDirection(sessionpart);
  }
  return 'sendrecv';
};

SDPUtils.getKind = function(mediaSection) {
  var lines = SDPUtils.splitLines(mediaSection);
  var mline = lines[0].split(' ');
  return mline[0].substr(2);
};

SDPUtils.isRejected = function(mediaSection) {
  return mediaSection.split(' ', 2)[1] === '0';
};

SDPUtils.parseMLine = function(mediaSection) {
  var lines = SDPUtils.splitLines(mediaSection);
  var mline = lines[0].split(' ');
  return {
    kind: mline[0].substr(2),
    port: parseInt(mline[1], 10),
    protocol: mline[2],
    fmt: mline.slice(3).join(' ')
  };
};

// Expose public methods.
if (typeof module === 'object') {
  module.exports = SDPUtils;
}

},{}],3:[function(require,module,exports){
(function (global){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */

'use strict';

var adapterFactory = require('./adapter_factory.js');
module.exports = adapterFactory({window: global.window});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./adapter_factory.js":4}],4:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */

'use strict';

var utils = require('./utils');
// Shimming starts here.
module.exports = function(dependencies, opts) {
  var window = dependencies && dependencies.window;

  var options = {
    shimChrome: true,
    shimFirefox: true,
    shimEdge: true,
    shimSafari: true,
  };

  for (var key in opts) {
    if (hasOwnProperty.call(opts, key)) {
      options[key] = opts[key];
    }
  }

  // Utils.
  var logging = utils.log;
  var browserDetails = utils.detectBrowser(window);

  // Export to the adapter global object visible in the browser.
  var adapter = {
    browserDetails: browserDetails,
    extractVersion: utils.extractVersion,
    disableLog: utils.disableLog,
    disableWarnings: utils.disableWarnings
  };

  // Uncomment the line below if you want logging to occur, including logging
  // for the switch statement below. Can also be turned on in the browser via
  // adapter.disableLog(false), but then logging from the switch statement below
  // will not appear.
  // require('./utils').disableLog(false);

  // Browser shims.
  var chromeShim = require('./chrome/chrome_shim') || null;
  var edgeShim = require('./edge/edge_shim') || null;
  var firefoxShim = require('./firefox/firefox_shim') || null;
  var safariShim = require('./safari/safari_shim') || null;
  var commonShim = require('./common_shim') || null;

  // Shim browser if found.
  switch (browserDetails.browser) {
    case 'chrome':
      if (!chromeShim || !chromeShim.shimPeerConnection ||
          !options.shimChrome) {
        logging('Chrome shim is not included in this adapter release.');
        return adapter;
      }
      logging('adapter.js shimming chrome.');
      // Export to the adapter global object visible in the browser.
      adapter.browserShim = chromeShim;
      commonShim.shimCreateObjectURL(window);

      chromeShim.shimGetUserMedia(window);
      chromeShim.shimMediaStream(window);
      chromeShim.shimSourceObject(window);
      chromeShim.shimPeerConnection(window);
      chromeShim.shimOnTrack(window);
      chromeShim.shimAddTrackRemoveTrack(window);
      chromeShim.shimGetSendersWithDtmf(window);

      commonShim.shimRTCIceCandidate(window);
      break;
    case 'firefox':
      if (!firefoxShim || !firefoxShim.shimPeerConnection ||
          !options.shimFirefox) {
        logging('Firefox shim is not included in this adapter release.');
        return adapter;
      }
      logging('adapter.js shimming firefox.');
      // Export to the adapter global object visible in the browser.
      adapter.browserShim = firefoxShim;
      commonShim.shimCreateObjectURL(window);

      firefoxShim.shimGetUserMedia(window);
      firefoxShim.shimSourceObject(window);
      firefoxShim.shimPeerConnection(window);
      firefoxShim.shimOnTrack(window);

      commonShim.shimRTCIceCandidate(window);
      break;
    case 'edge':
      if (!edgeShim || !edgeShim.shimPeerConnection || !options.shimEdge) {
        logging('MS edge shim is not included in this adapter release.');
        return adapter;
      }
      logging('adapter.js shimming edge.');
      // Export to the adapter global object visible in the browser.
      adapter.browserShim = edgeShim;
      commonShim.shimCreateObjectURL(window);

      edgeShim.shimGetUserMedia(window);
      edgeShim.shimPeerConnection(window);
      edgeShim.shimReplaceTrack(window);

      // the edge shim implements the full RTCIceCandidate object.
      break;
    case 'safari':
      if (!safariShim || !options.shimSafari) {
        logging('Safari shim is not included in this adapter release.');
        return adapter;
      }
      logging('adapter.js shimming safari.');
      // Export to the adapter global object visible in the browser.
      adapter.browserShim = safariShim;
      commonShim.shimCreateObjectURL(window);

      safariShim.shimRTCIceServerUrls(window);
      safariShim.shimCallbacksAPI(window);
      safariShim.shimLocalStreamsAPI(window);
      safariShim.shimRemoteStreamsAPI(window);
      safariShim.shimTrackEventTransceiver(window);
      safariShim.shimGetUserMedia(window);
      safariShim.shimCreateOfferLegacy(window);

      commonShim.shimRTCIceCandidate(window);
      break;
    default:
      logging('Unsupported browser!');
      break;
  }

  return adapter;
};

},{"./chrome/chrome_shim":5,"./common_shim":7,"./edge/edge_shim":8,"./firefox/firefox_shim":10,"./safari/safari_shim":12,"./utils":13}],5:[function(require,module,exports){

/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */
'use strict';
var utils = require('../utils.js');
var logging = utils.log;

var chromeShim = {
  shimMediaStream: function(window) {
    window.MediaStream = window.MediaStream || window.webkitMediaStream;
  },

  shimOnTrack: function(window) {
    if (typeof window === 'object' && window.RTCPeerConnection && !('ontrack' in
        window.RTCPeerConnection.prototype)) {
      Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {
        get: function() {
          return this._ontrack;
        },
        set: function(f) {
          if (this._ontrack) {
            this.removeEventListener('track', this._ontrack);
          }
          this.addEventListener('track', this._ontrack = f);
        }
      });
      var origSetRemoteDescription =
          window.RTCPeerConnection.prototype.setRemoteDescription;
      window.RTCPeerConnection.prototype.setRemoteDescription = function() {
        var pc = this;
        if (!pc._ontrackpoly) {
          pc._ontrackpoly = function(e) {
            // onaddstream does not fire when a track is added to an existing
            // stream. But stream.onaddtrack is implemented so we use that.
            e.stream.addEventListener('addtrack', function(te) {
              var receiver;
              if (window.RTCPeerConnection.prototype.getReceivers) {
                receiver = pc.getReceivers().find(function(r) {
                  return r.track && r.track.id === te.track.id;
                });
              } else {
                receiver = {track: te.track};
              }

              var event = new Event('track');
              event.track = te.track;
              event.receiver = receiver;
              event.transceiver = {receiver: receiver};
              event.streams = [e.stream];
              pc.dispatchEvent(event);
            });
            e.stream.getTracks().forEach(function(track) {
              var receiver;
              if (window.RTCPeerConnection.prototype.getReceivers) {
                receiver = pc.getReceivers().find(function(r) {
                  return r.track && r.track.id === track.id;
                });
              } else {
                receiver = {track: track};
              }
              var event = new Event('track');
              event.track = track;
              event.receiver = receiver;
              event.transceiver = {receiver: receiver};
              event.streams = [e.stream];
              pc.dispatchEvent(event);
            });
          };
          pc.addEventListener('addstream', pc._ontrackpoly);
        }
        return origSetRemoteDescription.apply(pc, arguments);
      };
    }
  },

  shimGetSendersWithDtmf: function(window) {
    // Overrides addTrack/removeTrack, depends on shimAddTrackRemoveTrack.
    if (typeof window === 'object' && window.RTCPeerConnection &&
        !('getSenders' in window.RTCPeerConnection.prototype) &&
        'createDTMFSender' in window.RTCPeerConnection.prototype) {
      var shimSenderWithDtmf = function(pc, track) {
        return {
          track: track,
          get dtmf() {
            if (this._dtmf === undefined) {
              if (track.kind === 'audio') {
                this._dtmf = pc.createDTMFSender(track);
              } else {
                this._dtmf = null;
              }
            }
            return this._dtmf;
          },
          _pc: pc
        };
      };

      // augment addTrack when getSenders is not available.
      if (!window.RTCPeerConnection.prototype.getSenders) {
        window.RTCPeerConnection.prototype.getSenders = function() {
          this._senders = this._senders || [];
          return this._senders.slice(); // return a copy of the internal state.
        };
        var origAddTrack = window.RTCPeerConnection.prototype.addTrack;
        window.RTCPeerConnection.prototype.addTrack = function(track, stream) {
          var pc = this;
          var sender = origAddTrack.apply(pc, arguments);
          if (!sender) {
            sender = shimSenderWithDtmf(pc, track);
            pc._senders.push(sender);
          }
          return sender;
        };

        var origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;
        window.RTCPeerConnection.prototype.removeTrack = function(sender) {
          var pc = this;
          origRemoveTrack.apply(pc, arguments);
          var idx = pc._senders.indexOf(sender);
          if (idx !== -1) {
            pc._senders.splice(idx, 1);
          }
        };
      }
      var origAddStream = window.RTCPeerConnection.prototype.addStream;
      window.RTCPeerConnection.prototype.addStream = function(stream) {
        var pc = this;
        pc._senders = pc._senders || [];
        origAddStream.apply(pc, [stream]);
        stream.getTracks().forEach(function(track) {
          pc._senders.push(shimSenderWithDtmf(pc, track));
        });
      };

      var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;
      window.RTCPeerConnection.prototype.removeStream = function(stream) {
        var pc = this;
        pc._senders = pc._senders || [];
        origRemoveStream.apply(pc, [stream]);

        stream.getTracks().forEach(function(track) {
          var sender = pc._senders.find(function(s) {
            return s.track === track;
          });
          if (sender) {
            pc._senders.splice(pc._senders.indexOf(sender), 1); // remove sender
          }
        });
      };
    } else if (typeof window === 'object' && window.RTCPeerConnection &&
               'getSenders' in window.RTCPeerConnection.prototype &&
               'createDTMFSender' in window.RTCPeerConnection.prototype &&
               window.RTCRtpSender &&
               !('dtmf' in window.RTCRtpSender.prototype)) {
      var origGetSenders = window.RTCPeerConnection.prototype.getSenders;
      window.RTCPeerConnection.prototype.getSenders = function() {
        var pc = this;
        var senders = origGetSenders.apply(pc, []);
        senders.forEach(function(sender) {
          sender._pc = pc;
        });
        return senders;
      };

      Object.defineProperty(window.RTCRtpSender.prototype, 'dtmf', {
        get: function() {
          if (this._dtmf === undefined) {
            if (this.track.kind === 'audio') {
              this._dtmf = this._pc.createDTMFSender(this.track);
            } else {
              this._dtmf = null;
            }
          }
          return this._dtmf;
        }
      });
    }
  },

  shimSourceObject: function(window) {
    var URL = window && window.URL;

    if (typeof window === 'object') {
      if (window.HTMLMediaElement &&
        !('srcObject' in window.HTMLMediaElement.prototype)) {
        // Shim the srcObject property, once, when HTMLMediaElement is found.
        Object.defineProperty(window.HTMLMediaElement.prototype, 'srcObject', {
          get: function() {
            return this._srcObject;
          },
          set: function(stream) {
            var self = this;
            // Use _srcObject as a private property for this shim
            this._srcObject = stream;
            if (this.src) {
              URL.revokeObjectURL(this.src);
            }

            if (!stream) {
              this.src = '';
              return undefined;
            }
            this.src = URL.createObjectURL(stream);
            // We need to recreate the blob url when a track is added or
            // removed. Doing it manually since we want to avoid a recursion.
            stream.addEventListener('addtrack', function() {
              if (self.src) {
                URL.revokeObjectURL(self.src);
              }
              self.src = URL.createObjectURL(stream);
            });
            stream.addEventListener('removetrack', function() {
              if (self.src) {
                URL.revokeObjectURL(self.src);
              }
              self.src = URL.createObjectURL(stream);
            });
          }
        });
      }
    }
  },

  shimAddTrackRemoveTrack: function(window) {
    var browserDetails = utils.detectBrowser(window);
    // shim addTrack and removeTrack.
    if (window.RTCPeerConnection.prototype.addTrack &&
        browserDetails.version >= 63) {
      return;
    }

    // also shim pc.getLocalStreams when addTrack is shimmed
    // to return the original streams.
    var origGetLocalStreams = window.RTCPeerConnection.prototype
        .getLocalStreams;
    window.RTCPeerConnection.prototype.getLocalStreams = function() {
      var self = this;
      var nativeStreams = origGetLocalStreams.apply(this);
      self._reverseStreams = self._reverseStreams || {};
      return nativeStreams.map(function(stream) {
        return self._reverseStreams[stream.id];
      });
    };

    var origAddStream = window.RTCPeerConnection.prototype.addStream;
    window.RTCPeerConnection.prototype.addStream = function(stream) {
      var pc = this;
      pc._streams = pc._streams || {};
      pc._reverseStreams = pc._reverseStreams || {};

      stream.getTracks().forEach(function(track) {
        var alreadyExists = pc.getSenders().find(function(s) {
          return s.track === track;
        });
        if (alreadyExists) {
          throw new DOMException('Track already exists.',
              'InvalidAccessError');
        }
      });
      // Add identity mapping for consistency with addTrack.
      // Unless this is being used with a stream from addTrack.
      if (!pc._reverseStreams[stream.id]) {
        var newStream = new window.MediaStream(stream.getTracks());
        pc._streams[stream.id] = newStream;
        pc._reverseStreams[newStream.id] = stream;
        stream = newStream;
      }
      origAddStream.apply(pc, [stream]);
    };

    var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;
    window.RTCPeerConnection.prototype.removeStream = function(stream) {
      var pc = this;
      pc._streams = pc._streams || {};
      pc._reverseStreams = pc._reverseStreams || {};

      origRemoveStream.apply(pc, [(pc._streams[stream.id] || stream)]);
      delete pc._reverseStreams[(pc._streams[stream.id] ?
          pc._streams[stream.id].id : stream.id)];
      delete pc._streams[stream.id];
    };

    window.RTCPeerConnection.prototype.addTrack = function(track, stream) {
      var pc = this;
      if (pc.signalingState === 'closed') {
        throw new DOMException(
          'The RTCPeerConnection\'s signalingState is \'closed\'.',
          'InvalidStateError');
      }
      var streams = [].slice.call(arguments, 1);
      if (streams.length !== 1 ||
          !streams[0].getTracks().find(function(t) {
            return t === track;
          })) {
        // this is not fully correct but all we can manage without
        // [[associated MediaStreams]] internal slot.
        throw new DOMException(
          'The adapter.js addTrack polyfill only supports a single ' +
          ' stream which is associated with the specified track.',
          'NotSupportedError');
      }

      var alreadyExists = pc.getSenders().find(function(s) {
        return s.track === track;
      });
      if (alreadyExists) {
        throw new DOMException('Track already exists.',
            'InvalidAccessError');
      }

      pc._streams = pc._streams || {};
      pc._reverseStreams = pc._reverseStreams || {};
      var oldStream = pc._streams[stream.id];
      if (oldStream) {
        // this is using odd Chrome behaviour, use with caution:
        // https://bugs.chromium.org/p/webrtc/issues/detail?id=7815
        // Note: we rely on the high-level addTrack/dtmf shim to
        // create the sender with a dtmf sender.
        oldStream.addTrack(track);

        // Trigger ONN async.
        Promise.resolve().then(function() {
          pc.dispatchEvent(new Event('negotiationneeded'));
        });
      } else {
        var newStream = new window.MediaStream([track]);
        pc._streams[stream.id] = newStream;
        pc._reverseStreams[newStream.id] = stream;
        pc.addStream(newStream);
      }
      return pc.getSenders().find(function(s) {
        return s.track === track;
      });
    };

    // replace the internal stream id with the external one and
    // vice versa.
    function replaceInternalStreamId(pc, description) {
      var sdp = description.sdp;
      Object.keys(pc._reverseStreams || []).forEach(function(internalId) {
        var externalStream = pc._reverseStreams[internalId];
        var internalStream = pc._streams[externalStream.id];
        sdp = sdp.replace(new RegExp(internalStream.id, 'g'),
            externalStream.id);
      });
      return new RTCSessionDescription({
        type: description.type,
        sdp: sdp
      });
    }
    function replaceExternalStreamId(pc, description) {
      var sdp = description.sdp;
      Object.keys(pc._reverseStreams || []).forEach(function(internalId) {
        var externalStream = pc._reverseStreams[internalId];
        var internalStream = pc._streams[externalStream.id];
        sdp = sdp.replace(new RegExp(externalStream.id, 'g'),
            internalStream.id);
      });
      return new RTCSessionDescription({
        type: description.type,
        sdp: sdp
      });
    }
    ['createOffer', 'createAnswer'].forEach(function(method) {
      var nativeMethod = window.RTCPeerConnection.prototype[method];
      window.RTCPeerConnection.prototype[method] = function() {
        var pc = this;
        var args = arguments;
        var isLegacyCall = arguments.length &&
            typeof arguments[0] === 'function';
        if (isLegacyCall) {
          return nativeMethod.apply(pc, [
            function(description) {
              var desc = replaceInternalStreamId(pc, description);
              args[0].apply(null, [desc]);
            },
            function(err) {
              if (args[1]) {
                args[1].apply(null, err);
              }
            }, arguments[2]
          ]);
        }
        return nativeMethod.apply(pc, arguments)
        .then(function(description) {
          return replaceInternalStreamId(pc, description);
        });
      };
    });

    var origSetLocalDescription =
        window.RTCPeerConnection.prototype.setLocalDescription;
    window.RTCPeerConnection.prototype.setLocalDescription = function() {
      var pc = this;
      if (!arguments.length || !arguments[0].type) {
        return origSetLocalDescription.apply(pc, arguments);
      }
      arguments[0] = replaceExternalStreamId(pc, arguments[0]);
      return origSetLocalDescription.apply(pc, arguments);
    };

    // TODO: mangle getStats: https://w3c.github.io/webrtc-stats/#dom-rtcmediastreamstats-streamidentifier

    var origLocalDescription = Object.getOwnPropertyDescriptor(
        window.RTCPeerConnection.prototype, 'localDescription');
    Object.defineProperty(window.RTCPeerConnection.prototype,
        'localDescription', {
          get: function() {
            var pc = this;
            var description = origLocalDescription.get.apply(this);
            if (description.type === '') {
              return description;
            }
            return replaceInternalStreamId(pc, description);
          }
        });

    window.RTCPeerConnection.prototype.removeTrack = function(sender) {
      var pc = this;
      if (pc.signalingState === 'closed') {
        throw new DOMException(
          'The RTCPeerConnection\'s signalingState is \'closed\'.',
          'InvalidStateError');
      }
      // We can not yet check for sender instanceof RTCRtpSender
      // since we shim RTPSender. So we check if sender._pc is set.
      if (!sender._pc) {
        throw new DOMException('Argument 1 of RTCPeerConnection.removeTrack ' +
            'does not implement interface RTCRtpSender.', 'TypeError');
      }
      var isLocal = sender._pc === pc;
      if (!isLocal) {
        throw new DOMException('Sender was not created by this connection.',
            'InvalidAccessError');
      }

      // Search for the native stream the senders track belongs to.
      pc._streams = pc._streams || {};
      var stream;
      Object.keys(pc._streams).forEach(function(streamid) {
        var hasTrack = pc._streams[streamid].getTracks().find(function(track) {
          return sender.track === track;
        });
        if (hasTrack) {
          stream = pc._streams[streamid];
        }
      });

      if (stream) {
        if (stream.getTracks().length === 1) {
          // if this is the last track of the stream, remove the stream. This
          // takes care of any shimmed _senders.
          pc.removeStream(pc._reverseStreams[stream.id]);
        } else {
          // relying on the same odd chrome behaviour as above.
          stream.removeTrack(sender.track);
        }
        pc.dispatchEvent(new Event('negotiationneeded'));
      }
    };
  },

  shimPeerConnection: function(window) {
    var browserDetails = utils.detectBrowser(window);

    // The RTCPeerConnection object.
    if (!window.RTCPeerConnection) {
      window.RTCPeerConnection = function(pcConfig, pcConstraints) {
        // Translate iceTransportPolicy to iceTransports,
        // see https://code.google.com/p/webrtc/issues/detail?id=4869
        // this was fixed in M56 along with unprefixing RTCPeerConnection.
        logging('PeerConnection');
        if (pcConfig && pcConfig.iceTransportPolicy) {
          pcConfig.iceTransports = pcConfig.iceTransportPolicy;
        }

        return new window.webkitRTCPeerConnection(pcConfig, pcConstraints);
      };
      window.RTCPeerConnection.prototype =
          window.webkitRTCPeerConnection.prototype;
      // wrap static methods. Currently just generateCertificate.
      if (window.webkitRTCPeerConnection.generateCertificate) {
        Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {
          get: function() {
            return window.webkitRTCPeerConnection.generateCertificate;
          }
        });
      }
    } else {
      // migrate from non-spec RTCIceServer.url to RTCIceServer.urls
      var OrigPeerConnection = window.RTCPeerConnection;
      window.RTCPeerConnection = function(pcConfig, pcConstraints) {
        if (pcConfig && pcConfig.iceServers) {
          var newIceServers = [];
          for (var i = 0; i < pcConfig.iceServers.length; i++) {
            var server = pcConfig.iceServers[i];
            if (!server.hasOwnProperty('urls') &&
                server.hasOwnProperty('url')) {
              utils.deprecated('RTCIceServer.url', 'RTCIceServer.urls');
              server = JSON.parse(JSON.stringify(server));
              server.urls = server.url;
              newIceServers.push(server);
            } else {
              newIceServers.push(pcConfig.iceServers[i]);
            }
          }
          pcConfig.iceServers = newIceServers;
        }
        return new OrigPeerConnection(pcConfig, pcConstraints);
      };
      window.RTCPeerConnection.prototype = OrigPeerConnection.prototype;
      // wrap static methods. Currently just generateCertificate.
      Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {
        get: function() {
          return OrigPeerConnection.generateCertificate;
        }
      });
    }

    var origGetStats = window.RTCPeerConnection.prototype.getStats;
    window.RTCPeerConnection.prototype.getStats = function(selector,
        successCallback, errorCallback) {
      var self = this;
      var args = arguments;

      // If selector is a function then we are in the old style stats so just
      // pass back the original getStats format to avoid breaking old users.
      if (arguments.length > 0 && typeof selector === 'function') {
        return origGetStats.apply(this, arguments);
      }

      // When spec-style getStats is supported, return those when called with
      // either no arguments or the selector argument is null.
      if (origGetStats.length === 0 && (arguments.length === 0 ||
          typeof arguments[0] !== 'function')) {
        return origGetStats.apply(this, []);
      }

      var fixChromeStats_ = function(response) {
        var standardReport = {};
        var reports = response.result();
        reports.forEach(function(report) {
          var standardStats = {
            id: report.id,
            timestamp: report.timestamp,
            type: {
              localcandidate: 'local-candidate',
              remotecandidate: 'remote-candidate'
            }[report.type] || report.type
          };
          report.names().forEach(function(name) {
            standardStats[name] = report.stat(name);
          });
          standardReport[standardStats.id] = standardStats;
        });

        return standardReport;
      };

      // shim getStats with maplike support
      var makeMapStats = function(stats) {
        return new Map(Object.keys(stats).map(function(key) {
          return [key, stats[key]];
        }));
      };

      if (arguments.length >= 2) {
        var successCallbackWrapper_ = function(response) {
          args[1](makeMapStats(fixChromeStats_(response)));
        };

        return origGetStats.apply(this, [successCallbackWrapper_,
          arguments[0]]);
      }

      // promise-support
      return new Promise(function(resolve, reject) {
        origGetStats.apply(self, [
          function(response) {
            resolve(makeMapStats(fixChromeStats_(response)));
          }, reject]);
      }).then(successCallback, errorCallback);
    };

    // add promise support -- natively available in Chrome 51
    if (browserDetails.version < 51) {
      ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']
          .forEach(function(method) {
            var nativeMethod = window.RTCPeerConnection.prototype[method];
            window.RTCPeerConnection.prototype[method] = function() {
              var args = arguments;
              var self = this;
              var promise = new Promise(function(resolve, reject) {
                nativeMethod.apply(self, [args[0], resolve, reject]);
              });
              if (args.length < 2) {
                return promise;
              }
              return promise.then(function() {
                args[1].apply(null, []);
              },
              function(err) {
                if (args.length >= 3) {
                  args[2].apply(null, [err]);
                }
              });
            };
          });
    }

    // promise support for createOffer and createAnswer. Available (without
    // bugs) since M52: crbug/619289
    if (browserDetails.version < 52) {
      ['createOffer', 'createAnswer'].forEach(function(method) {
        var nativeMethod = window.RTCPeerConnection.prototype[method];
        window.RTCPeerConnection.prototype[method] = function() {
          var self = this;
          if (arguments.length < 1 || (arguments.length === 1 &&
              typeof arguments[0] === 'object')) {
            var opts = arguments.length === 1 ? arguments[0] : undefined;
            return new Promise(function(resolve, reject) {
              nativeMethod.apply(self, [resolve, reject, opts]);
            });
          }
          return nativeMethod.apply(this, arguments);
        };
      });
    }

    // shim implicit creation of RTCSessionDescription/RTCIceCandidate
    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']
        .forEach(function(method) {
          var nativeMethod = window.RTCPeerConnection.prototype[method];
          window.RTCPeerConnection.prototype[method] = function() {
            arguments[0] = new ((method === 'addIceCandidate') ?
                window.RTCIceCandidate :
                window.RTCSessionDescription)(arguments[0]);
            return nativeMethod.apply(this, arguments);
          };
        });

    // support for addIceCandidate(null or undefined)
    var nativeAddIceCandidate =
        window.RTCPeerConnection.prototype.addIceCandidate;
    window.RTCPeerConnection.prototype.addIceCandidate = function() {
      if (!arguments[0]) {
        if (arguments[1]) {
          arguments[1].apply(null);
        }
        return Promise.resolve();
      }
      return nativeAddIceCandidate.apply(this, arguments);
    };
  }
};


// Expose public methods.
module.exports = {
  shimMediaStream: chromeShim.shimMediaStream,
  shimOnTrack: chromeShim.shimOnTrack,
  shimAddTrackRemoveTrack: chromeShim.shimAddTrackRemoveTrack,
  shimGetSendersWithDtmf: chromeShim.shimGetSendersWithDtmf,
  shimSourceObject: chromeShim.shimSourceObject,
  shimPeerConnection: chromeShim.shimPeerConnection,
  shimGetUserMedia: require('./getusermedia')
};

},{"../utils.js":13,"./getusermedia":6}],6:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */
'use strict';
var utils = require('../utils.js');
var logging = utils.log;

// Expose public methods.
module.exports = function(window) {
  var browserDetails = utils.detectBrowser(window);
  var navigator = window && window.navigator;

  window.__navigator = window.navigator;

  var constraintsToChrome_ = function(c) {
    if (typeof c !== 'object' || c.mandatory || c.optional) {
      return c;
    }
    var cc = {};
    Object.keys(c).forEach(function(key) {
      if (key === 'require' || key === 'advanced' || key === 'mediaSource') {
        return;
      }
      var r = (typeof c[key] === 'object') ? c[key] : {ideal: c[key]};
      if (r.exact !== undefined && typeof r.exact === 'number') {
        r.min = r.max = r.exact;
      }
      var oldname_ = function(prefix, name) {
        if (prefix) {
          return prefix + name.charAt(0).toUpperCase() + name.slice(1);
        }
        return (name === 'deviceId') ? 'sourceId' : name;
      };
      if (r.ideal !== undefined) {
        cc.optional = cc.optional || [];
        var oc = {};
        if (typeof r.ideal === 'number') {
          oc[oldname_('min', key)] = r.ideal;
          cc.optional.push(oc);
          oc = {};
          oc[oldname_('max', key)] = r.ideal;
          cc.optional.push(oc);
        } else {
          oc[oldname_('', key)] = r.ideal;
          cc.optional.push(oc);
        }
      }
      if (r.exact !== undefined && typeof r.exact !== 'number') {
        cc.mandatory = cc.mandatory || {};
        cc.mandatory[oldname_('', key)] = r.exact;
      } else {
        ['min', 'max'].forEach(function(mix) {
          if (r[mix] !== undefined) {
            cc.mandatory = cc.mandatory || {};
            cc.mandatory[oldname_(mix, key)] = r[mix];
          }
        });
      }
    });
    if (c.advanced) {
      cc.optional = (cc.optional || []).concat(c.advanced);
    }
    return cc;
  };

  var shimConstraints_ = function(constraints, func) {
    constraints = JSON.parse(JSON.stringify(constraints));
    if (constraints && typeof constraints.audio === 'object') {
      var remap = function(obj, a, b) {
        if (a in obj && !(b in obj)) {
          obj[b] = obj[a];
          delete obj[a];
        }
      };
      constraints = JSON.parse(JSON.stringify(constraints));
      remap(constraints.audio, 'autoGainControl', 'googAutoGainControl');
      remap(constraints.audio, 'noiseSuppression', 'googNoiseSuppression');
      constraints.audio = constraintsToChrome_(constraints.audio);
    }
    if (constraints && typeof constraints.video === 'object') {
      // Shim facingMode for mobile & surface pro.
      var face = constraints.video.facingMode;
      face = face && ((typeof face === 'object') ? face : {ideal: face});
      var getSupportedFacingModeLies = browserDetails.version < 66;

      if ((face && (face.exact === 'user' || face.exact === 'environment' ||
                    face.ideal === 'user' || face.ideal === 'environment')) &&
          !(navigator.mediaDevices.getSupportedConstraints &&
            navigator.mediaDevices.getSupportedConstraints().facingMode &&
            !getSupportedFacingModeLies)) {
        delete constraints.video.facingMode;
        var matches;
        if (face.exact === 'environment' || face.ideal === 'environment') {
          matches = ['back', 'rear'];
        } else if (face.exact === 'user' || face.ideal === 'user') {
          matches = ['front'];
        }
        if (matches) {
          // Look for matches in label, or use last cam for back (typical).
          return navigator.mediaDevices.enumerateDevices()
          .then(function(devices) {
            devices = devices.filter(function(d) {
              return d.kind === 'videoinput';
            });
            var dev = devices.find(function(d) {
              return matches.some(function(match) {
                return d.label.toLowerCase().indexOf(match) !== -1;
              });
            });
            if (!dev && devices.length && matches.indexOf('back') !== -1) {
              dev = devices[devices.length - 1]; // more likely the back cam
            }
            if (dev) {
              constraints.video.deviceId = face.exact ? {exact: dev.deviceId} :
                                                        {ideal: dev.deviceId};
            }
            constraints.video = constraintsToChrome_(constraints.video);
            logging('chrome: ' + JSON.stringify(constraints));
            return func(constraints);
          });
        }
      }
      constraints.video = constraintsToChrome_(constraints.video);
    }
    logging('chrome: ' + JSON.stringify(constraints));
    return func(constraints);
  };

  var shimError_ = function(e) {
    return {
      name: {
        PermissionDeniedError: 'NotAllowedError',
        InvalidStateError: 'NotReadableError',
        DevicesNotFoundError: 'NotFoundError',
        ConstraintNotSatisfiedError: 'OverconstrainedError',
        TrackStartError: 'NotReadableError',
        MediaDeviceFailedDueToShutdown: 'NotReadableError',
        MediaDeviceKillSwitchOn: 'NotReadableError'
      }[e.name] || e.name,
      message: e.message,
      constraint: e.constraintName,
      toString: function() {
        return this.name + (this.message && ': ') + this.message;
      }
    };
  };

  var getUserMedia_ = function(constraints, onSuccess, onError) {
    shimConstraints_(constraints, function(c) {
      navigator.webkitGetUserMedia(c, onSuccess, function(e) {
        if (onError) {
          onError(shimError_(e));
        }
      });
    });
  };

  navigator.getUserMedia = getUserMedia_;

  // Returns the result of getUserMedia as a Promise.
  var getUserMediaPromise_ = function(constraints) {
    return new Promise(function(resolve, reject) {
      navigator.getUserMedia(constraints, resolve, reject);
    });
  };

  if (!navigator.mediaDevices) {
    navigator.mediaDevices = {
      getUserMedia: getUserMediaPromise_,
      enumerateDevices: function() {
        return new Promise(function(resolve) {
          var kinds = {audio: 'audioinput', video: 'videoinput'};
          return window.MediaStreamTrack.getSources(function(devices) {
            resolve(devices.map(function(device) {
              return {label: device.label,
                kind: kinds[device.kind],
                deviceId: device.id,
                groupId: ''};
            }));
          });
        });
      },
      getSupportedConstraints: function() {
        return {
          deviceId: true, echoCancellation: true, facingMode: true,
          frameRate: true, height: true, width: true
        };
      }
    };
  }

  // A shim for getUserMedia method on the mediaDevices object.
  // TODO(KaptenJansson) remove once implemented in Chrome stable.
  if (!navigator.mediaDevices.getUserMedia) {
    navigator.mediaDevices.getUserMedia = function(constraints) {
      return getUserMediaPromise_(constraints);
    };
  } else {
    // Even though Chrome 45 has navigator.mediaDevices and a getUserMedia
    // function which returns a Promise, it does not accept spec-style
    // constraints.
    var origGetUserMedia = navigator.mediaDevices.getUserMedia.
        bind(navigator.mediaDevices);
    navigator.mediaDevices.getUserMedia = function(cs) {
      return shimConstraints_(cs, function(c) {
        return origGetUserMedia(c).then(function(stream) {
          if (c.audio && !stream.getAudioTracks().length ||
              c.video && !stream.getVideoTracks().length) {
            stream.getTracks().forEach(function(track) {
              track.stop();
            });
            throw new DOMException('', 'NotFoundError');
          }
          return stream;
        }, function(e) {
          return Promise.reject(shimError_(e));
        });
      });
    };
  }

  // Dummy devicechange event methods.
  // TODO(KaptenJansson) remove once implemented in Chrome stable.
  if (typeof navigator.mediaDevices.addEventListener === 'undefined') {
    navigator.mediaDevices.addEventListener = function() {
      logging('Dummy mediaDevices.addEventListener called.');
    };
  }
  if (typeof navigator.mediaDevices.removeEventListener === 'undefined') {
    navigator.mediaDevices.removeEventListener = function() {
      logging('Dummy mediaDevices.removeEventListener called.');
    };
  }
};

},{"../utils.js":13}],7:[function(require,module,exports){
/*
 *  Copyright (c) 2017 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */
'use strict';

var SDPUtils = require('sdp');
var utils = require('./utils');

// Wraps the peerconnection event eventNameToWrap in a function
// which returns the modified event object.
function wrapPeerConnectionEvent(window, eventNameToWrap, wrapper) {
  if (!window.RTCPeerConnection) {
    return;
  }
  var proto = window.RTCPeerConnection.prototype;
  var nativeAddEventListener = proto.addEventListener;
  proto.addEventListener = function(nativeEventName, cb) {
    if (nativeEventName !== eventNameToWrap) {
      return nativeAddEventListener.apply(this, arguments);
    }
    var wrappedCallback = function(e) {
      cb(wrapper(e));
    };
    this._eventMap = this._eventMap || {};
    this._eventMap[cb] = wrappedCallback;
    return nativeAddEventListener.apply(this, [nativeEventName,
      wrappedCallback]);
  };

  var nativeRemoveEventListener = proto.removeEventListener;
  proto.removeEventListener = function(nativeEventName, cb) {
    if (nativeEventName !== eventNameToWrap || !this._eventMap
        || !this._eventMap[cb]) {
      return nativeRemoveEventListener.apply(this, arguments);
    }
    var unwrappedCb = this._eventMap[cb];
    delete this._eventMap[cb];
    return nativeRemoveEventListener.apply(this, [nativeEventName,
      unwrappedCb]);
  };

  Object.defineProperty(proto, 'on' + eventNameToWrap, {
    get: function() {
      return this['_on' + eventNameToWrap];
    },
    set: function(cb) {
      if (this['_on' + eventNameToWrap]) {
        this.removeEventListener(eventNameToWrap,
            this['_on' + eventNameToWrap]);
        delete this['_on' + eventNameToWrap];
      }
      if (cb) {
        this.addEventListener(eventNameToWrap,
            this['_on' + eventNameToWrap] = cb);
      }
    }
  });
}

module.exports = {
  shimRTCIceCandidate: function(window) {
    // foundation is arbitrarily chosen as an indicator for full support for
    // https://w3c.github.io/webrtc-pc/#rtcicecandidate-interface
    if (window.RTCIceCandidate && 'foundation' in
        window.RTCIceCandidate.prototype) {
      return;
    }

    var NativeRTCIceCandidate = window.RTCIceCandidate;
    window.RTCIceCandidate = function(args) {
      // Remove the a= which shouldn't be part of the candidate string.
      if (typeof args === 'object' && args.candidate &&
          args.candidate.indexOf('a=') === 0) {
        args = JSON.parse(JSON.stringify(args));
        args.candidate = args.candidate.substr(2);
      }

      // Augment the native candidate with the parsed fields.
      var nativeCandidate = new NativeRTCIceCandidate(args);
      var parsedCandidate = SDPUtils.parseCandidate(args.candidate);
      var augmentedCandidate = Object.assign(nativeCandidate,
          parsedCandidate);

      // Add a serializer that does not serialize the extra attributes.
      augmentedCandidate.toJSON = function() {
        return {
          candidate: augmentedCandidate.candidate,
          sdpMid: augmentedCandidate.sdpMid,
          sdpMLineIndex: augmentedCandidate.sdpMLineIndex,
          usernameFragment: augmentedCandidate.usernameFragment,
        };
      };
      return augmentedCandidate;
    };

    // Hook up the augmented candidate in onicecandidate and
    // addEventListener('icecandidate', ...)
    wrapPeerConnectionEvent(window, 'icecandidate', function(e) {
      if (e.candidate) {
        Object.defineProperty(e, 'candidate', {
          value: new window.RTCIceCandidate(e.candidate),
          writable: 'false'
        });
      }
      return e;
    });
  },

  // shimCreateObjectURL must be called before shimSourceObject to avoid loop.

  shimCreateObjectURL: function(window) {
    var URL = window && window.URL;

    if (!(typeof window === 'object' && window.HTMLMediaElement &&
          'srcObject' in window.HTMLMediaElement.prototype &&
        URL.createObjectURL && URL.revokeObjectURL)) {
      // Only shim CreateObjectURL using srcObject if srcObject exists.
      return undefined;
    }

    var nativeCreateObjectURL = URL.createObjectURL.bind(URL);
    var nativeRevokeObjectURL = URL.revokeObjectURL.bind(URL);
    var streams = new Map(), newId = 0;

    URL.createObjectURL = function(stream) {
      if ('getTracks' in stream) {
        var url = 'polyblob:' + (++newId);
        streams.set(url, stream);
        utils.deprecated('URL.createObjectURL(stream)',
            'elem.srcObject = stream');
        return url;
      }
      return nativeCreateObjectURL(stream);
    };
    URL.revokeObjectURL = function(url) {
      nativeRevokeObjectURL(url);
      streams.delete(url);
    };

    var dsc = Object.getOwnPropertyDescriptor(window.HTMLMediaElement.prototype,
                                              'src');
    Object.defineProperty(window.HTMLMediaElement.prototype, 'src', {
      get: function() {
        return dsc.get.apply(this);
      },
      set: function(url) {
        this.srcObject = streams.get(url) || null;
        return dsc.set.apply(this, [url]);
      }
    });

    var nativeSetAttribute = window.HTMLMediaElement.prototype.setAttribute;
    window.HTMLMediaElement.prototype.setAttribute = function() {
      if (arguments.length === 2 &&
          ('' + arguments[0]).toLowerCase() === 'src') {
        this.srcObject = streams.get(arguments[1]) || null;
      }
      return nativeSetAttribute.apply(this, arguments);
    };
  }
};

},{"./utils":13,"sdp":2}],8:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */
'use strict';

var utils = require('../utils');
var shimRTCPeerConnection = require('rtcpeerconnection-shim');

module.exports = {
  shimGetUserMedia: require('./getusermedia'),
  shimPeerConnection: function(window) {
    var browserDetails = utils.detectBrowser(window);

    if (window.RTCIceGatherer) {
      // ORTC defines an RTCIceCandidate object but no constructor.
      // Not implemented in Edge.
      if (!window.RTCIceCandidate) {
        window.RTCIceCandidate = function(args) {
          return args;
        };
      }
      // ORTC does not have a session description object but
      // other browsers (i.e. Chrome) that will support both PC and ORTC
      // in the future might have this defined already.
      if (!window.RTCSessionDescription) {
        window.RTCSessionDescription = function(args) {
          return args;
        };
      }
      // this adds an additional event listener to MediaStrackTrack that signals
      // when a tracks enabled property was changed. Workaround for a bug in
      // addStream, see below. No longer required in 15025+
      if (browserDetails.version < 15025) {
        var origMSTEnabled = Object.getOwnPropertyDescriptor(
            window.MediaStreamTrack.prototype, 'enabled');
        Object.defineProperty(window.MediaStreamTrack.prototype, 'enabled', {
          set: function(value) {
            origMSTEnabled.set.call(this, value);
            var ev = new Event('enabled');
            ev.enabled = value;
            this.dispatchEvent(ev);
          }
        });
      }
    }

    // ORTC defines the DTMF sender a bit different.
    // https://github.com/w3c/ortc/issues/714
    if (window.RTCRtpSender && !('dtmf' in window.RTCRtpSender.prototype)) {
      Object.defineProperty(window.RTCRtpSender.prototype, 'dtmf', {
        get: function() {
          if (this._dtmf === undefined) {
            if (this.track.kind === 'audio') {
              this._dtmf = new window.RTCDtmfSender(this);
            } else if (this.track.kind === 'video') {
              this._dtmf = null;
            }
          }
          return this._dtmf;
        }
      });
    }

    window.RTCPeerConnection =
        shimRTCPeerConnection(window, browserDetails.version);
  },
  shimReplaceTrack: function(window) {
    // ORTC has replaceTrack -- https://github.com/w3c/ortc/issues/614
    if (window.RTCRtpSender &&
        !('replaceTrack' in window.RTCRtpSender.prototype)) {
      window.RTCRtpSender.prototype.replaceTrack =
          window.RTCRtpSender.prototype.setTrack;
    }
  }
};

},{"../utils":13,"./getusermedia":9,"rtcpeerconnection-shim":1}],9:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */
'use strict';

// Expose public methods.
module.exports = function(window) {
  var navigator = window && window.navigator;

  var shimError_ = function(e) {
    return {
      name: {PermissionDeniedError: 'NotAllowedError'}[e.name] || e.name,
      message: e.message,
      constraint: e.constraint,
      toString: function() {
        return this.name;
      }
    };
  };

  // getUserMedia error shim.
  var origGetUserMedia = navigator.mediaDevices.getUserMedia.
      bind(navigator.mediaDevices);
  navigator.mediaDevices.getUserMedia = function(c) {
    return origGetUserMedia(c).catch(function(e) {
      return Promise.reject(shimError_(e));
    });
  };
};

},{}],10:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */
'use strict';

var utils = require('../utils');

var firefoxShim = {
  shimOnTrack: function(window) {
    if (typeof window === 'object' && window.RTCPeerConnection && !('ontrack' in
        window.RTCPeerConnection.prototype)) {
      Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {
        get: function() {
          return this._ontrack;
        },
        set: function(f) {
          if (this._ontrack) {
            this.removeEventListener('track', this._ontrack);
            this.removeEventListener('addstream', this._ontrackpoly);
          }
          this.addEventListener('track', this._ontrack = f);
          this.addEventListener('addstream', this._ontrackpoly = function(e) {
            e.stream.getTracks().forEach(function(track) {
              var event = new Event('track');
              event.track = track;
              event.receiver = {track: track};
              event.transceiver = {receiver: event.receiver};
              event.streams = [e.stream];
              this.dispatchEvent(event);
            }.bind(this));
          }.bind(this));
        }
      });
    }
    if (typeof window === 'object' && window.RTCTrackEvent &&
        ('receiver' in window.RTCTrackEvent.prototype) &&
        !('transceiver' in window.RTCTrackEvent.prototype)) {
      Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {
        get: function() {
          return {receiver: this.receiver};
        }
      });
    }
  },

  shimSourceObject: function(window) {
    // Firefox has supported mozSrcObject since FF22, unprefixed in 42.
    if (typeof window === 'object') {
      if (window.HTMLMediaElement &&
        !('srcObject' in window.HTMLMediaElement.prototype)) {
        // Shim the srcObject property, once, when HTMLMediaElement is found.
        Object.defineProperty(window.HTMLMediaElement.prototype, 'srcObject', {
          get: function() {
            return this.mozSrcObject;
          },
          set: function(stream) {
            this.mozSrcObject = stream;
          }
        });
      }
    }
  },

  shimPeerConnection: function(window) {
    var browserDetails = utils.detectBrowser(window);

    if (typeof window !== 'object' || !(window.RTCPeerConnection ||
        window.mozRTCPeerConnection)) {
      return; // probably media.peerconnection.enabled=false in about:config
    }
    // The RTCPeerConnection object.
    if (!window.RTCPeerConnection) {
      window.RTCPeerConnection = function(pcConfig, pcConstraints) {
        if (browserDetails.version < 38) {
          // .urls is not supported in FF < 38.
          // create RTCIceServers with a single url.
          if (pcConfig && pcConfig.iceServers) {
            var newIceServers = [];
            for (var i = 0; i < pcConfig.iceServers.length; i++) {
              var server = pcConfig.iceServers[i];
              if (server.hasOwnProperty('urls')) {
                for (var j = 0; j < server.urls.length; j++) {
                  var newServer = {
                    url: server.urls[j]
                  };
                  if (server.urls[j].indexOf('turn') === 0) {
                    newServer.username = server.username;
                    newServer.credential = server.credential;
                  }
                  newIceServers.push(newServer);
                }
              } else {
                newIceServers.push(pcConfig.iceServers[i]);
              }
            }
            pcConfig.iceServers = newIceServers;
          }
        }
        return new window.mozRTCPeerConnection(pcConfig, pcConstraints);
      };
      window.RTCPeerConnection.prototype =
          window.mozRTCPeerConnection.prototype;

      // wrap static methods. Currently just generateCertificate.
      if (window.mozRTCPeerConnection.generateCertificate) {
        Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {
          get: function() {
            return window.mozRTCPeerConnection.generateCertificate;
          }
        });
      }

      window.RTCSessionDescription = window.mozRTCSessionDescription;
      window.RTCIceCandidate = window.mozRTCIceCandidate;
    }

    // shim away need for obsolete RTCIceCandidate/RTCSessionDescription.
    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']
        .forEach(function(method) {
          var nativeMethod = window.RTCPeerConnection.prototype[method];
          window.RTCPeerConnection.prototype[method] = function() {
            arguments[0] = new ((method === 'addIceCandidate') ?
                window.RTCIceCandidate :
                window.RTCSessionDescription)(arguments[0]);
            return nativeMethod.apply(this, arguments);
          };
        });

    // support for addIceCandidate(null or undefined)
    var nativeAddIceCandidate =
        window.RTCPeerConnection.prototype.addIceCandidate;
    window.RTCPeerConnection.prototype.addIceCandidate = function() {
      if (!arguments[0]) {
        if (arguments[1]) {
          arguments[1].apply(null);
        }
        return Promise.resolve();
      }
      return nativeAddIceCandidate.apply(this, arguments);
    };

    // shim getStats with maplike support
    var makeMapStats = function(stats) {
      var map = new Map();
      Object.keys(stats).forEach(function(key) {
        map.set(key, stats[key]);
        map[key] = stats[key];
      });
      return map;
    };

    var modernStatsTypes = {
      inboundrtp: 'inbound-rtp',
      outboundrtp: 'outbound-rtp',
      candidatepair: 'candidate-pair',
      localcandidate: 'local-candidate',
      remotecandidate: 'remote-candidate'
    };

    var nativeGetStats = window.RTCPeerConnection.prototype.getStats;
    window.RTCPeerConnection.prototype.getStats = function(
      selector,
      onSucc,
      onErr
    ) {
      return nativeGetStats.apply(this, [selector || null])
        .then(function(stats) {
          if (browserDetails.version < 48) {
            stats = makeMapStats(stats);
          }
          if (browserDetails.version < 53 && !onSucc) {
            // Shim only promise getStats with spec-hyphens in type names
            // Leave callback version alone; misc old uses of forEach before Map
            try {
              stats.forEach(function(stat) {
                stat.type = modernStatsTypes[stat.type] || stat.type;
              });
            } catch (e) {
              if (e.name !== 'TypeError') {
                throw e;
              }
              // Avoid TypeError: "type" is read-only, in old versions. 34-43ish
              stats.forEach(function(stat, i) {
                stats.set(i, Object.assign({}, stat, {
                  type: modernStatsTypes[stat.type] || stat.type
                }));
              });
            }
          }
          return stats;
        })
        .then(onSucc, onErr);
    };
  }
};

// Expose public methods.
module.exports = {
  shimOnTrack: firefoxShim.shimOnTrack,
  shimSourceObject: firefoxShim.shimSourceObject,
  shimPeerConnection: firefoxShim.shimPeerConnection,
  shimGetUserMedia: require('./getusermedia')
};

},{"../utils":13,"./getusermedia":11}],11:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */
'use strict';

var utils = require('../utils');
var logging = utils.log;

// Expose public methods.
module.exports = function(window) {
  var browserDetails = utils.detectBrowser(window);
  var navigator = window && window.navigator;
  var MediaStreamTrack = window && window.MediaStreamTrack;

  var shimError_ = function(e) {
    return {
      name: {
        InternalError: 'NotReadableError',
        NotSupportedError: 'TypeError',
        PermissionDeniedError: 'NotAllowedError',
        SecurityError: 'NotAllowedError'
      }[e.name] || e.name,
      message: {
        'The operation is insecure.': 'The request is not allowed by the ' +
        'user agent or the platform in the current context.'
      }[e.message] || e.message,
      constraint: e.constraint,
      toString: function() {
        return this.name + (this.message && ': ') + this.message;
      }
    };
  };

  // getUserMedia constraints shim.
  var getUserMedia_ = function(constraints, onSuccess, onError) {
    var constraintsToFF37_ = function(c) {
      if (typeof c !== 'object' || c.require) {
        return c;
      }
      var require = [];
      Object.keys(c).forEach(function(key) {
        if (key === 'require' || key === 'advanced' || key === 'mediaSource') {
          return;
        }
        var r = c[key] = (typeof c[key] === 'object') ?
            c[key] : {ideal: c[key]};
        if (r.min !== undefined ||
            r.max !== undefined || r.exact !== undefined) {
          require.push(key);
        }
        if (r.exact !== undefined) {
          if (typeof r.exact === 'number') {
            r. min = r.max = r.exact;
          } else {
            c[key] = r.exact;
          }
          delete r.exact;
        }
        if (r.ideal !== undefined) {
          c.advanced = c.advanced || [];
          var oc = {};
          if (typeof r.ideal === 'number') {
            oc[key] = {min: r.ideal, max: r.ideal};
          } else {
            oc[key] = r.ideal;
          }
          c.advanced.push(oc);
          delete r.ideal;
          if (!Object.keys(r).length) {
            delete c[key];
          }
        }
      });
      if (require.length) {
        c.require = require;
      }
      return c;
    };
    constraints = JSON.parse(JSON.stringify(constraints));
    if (browserDetails.version < 38) {
      logging('spec: ' + JSON.stringify(constraints));
      if (constraints.audio) {
        constraints.audio = constraintsToFF37_(constraints.audio);
      }
      if (constraints.video) {
        constraints.video = constraintsToFF37_(constraints.video);
      }
      logging('ff37: ' + JSON.stringify(constraints));
    }
    return navigator.mozGetUserMedia(constraints, onSuccess, function(e) {
      onError(shimError_(e));
    });
  };

  // Returns the result of getUserMedia as a Promise.
  var getUserMediaPromise_ = function(constraints) {
    return new Promise(function(resolve, reject) {
      getUserMedia_(constraints, resolve, reject);
    });
  };

  // Shim for mediaDevices on older versions.
  if (!navigator.mediaDevices) {
    navigator.mediaDevices = {getUserMedia: getUserMediaPromise_,
      addEventListener: function() { },
      removeEventListener: function() { }
    };
  }
  navigator.mediaDevices.enumerateDevices =
      navigator.mediaDevices.enumerateDevices || function() {
        return new Promise(function(resolve) {
          var infos = [
            {kind: 'audioinput', deviceId: 'default', label: '', groupId: ''},
            {kind: 'videoinput', deviceId: 'default', label: '', groupId: ''}
          ];
          resolve(infos);
        });
      };

  if (browserDetails.version < 41) {
    // Work around http://bugzil.la/1169665
    var orgEnumerateDevices =
        navigator.mediaDevices.enumerateDevices.bind(navigator.mediaDevices);
    navigator.mediaDevices.enumerateDevices = function() {
      return orgEnumerateDevices().then(undefined, function(e) {
        if (e.name === 'NotFoundError') {
          return [];
        }
        throw e;
      });
    };
  }
  if (browserDetails.version < 49) {
    var origGetUserMedia = navigator.mediaDevices.getUserMedia.
        bind(navigator.mediaDevices);
    navigator.mediaDevices.getUserMedia = function(c) {
      return origGetUserMedia(c).then(function(stream) {
        // Work around https://bugzil.la/802326
        if (c.audio && !stream.getAudioTracks().length ||
            c.video && !stream.getVideoTracks().length) {
          stream.getTracks().forEach(function(track) {
            track.stop();
          });
          throw new DOMException('The object can not be found here.',
                                 'NotFoundError');
        }
        return stream;
      }, function(e) {
        return Promise.reject(shimError_(e));
      });
    };
  }
  if (!(browserDetails.version > 55 &&
      'autoGainControl' in navigator.mediaDevices.getSupportedConstraints())) {
    var remap = function(obj, a, b) {
      if (a in obj && !(b in obj)) {
        obj[b] = obj[a];
        delete obj[a];
      }
    };

    var nativeGetUserMedia = navigator.mediaDevices.getUserMedia.
        bind(navigator.mediaDevices);
    navigator.mediaDevices.getUserMedia = function(c) {
      if (typeof c === 'object' && typeof c.audio === 'object') {
        c = JSON.parse(JSON.stringify(c));
        remap(c.audio, 'autoGainControl', 'mozAutoGainControl');
        remap(c.audio, 'noiseSuppression', 'mozNoiseSuppression');
      }
      return nativeGetUserMedia(c);
    };

    if (MediaStreamTrack && MediaStreamTrack.prototype.getSettings) {
      var nativeGetSettings = MediaStreamTrack.prototype.getSettings;
      MediaStreamTrack.prototype.getSettings = function() {
        var obj = nativeGetSettings.apply(this, arguments);
        remap(obj, 'mozAutoGainControl', 'autoGainControl');
        remap(obj, 'mozNoiseSuppression', 'noiseSuppression');
        return obj;
      };
    }

    if (MediaStreamTrack && MediaStreamTrack.prototype.applyConstraints) {
      var nativeApplyConstraints = MediaStreamTrack.prototype.applyConstraints;
      MediaStreamTrack.prototype.applyConstraints = function(c) {
        if (this.kind === 'audio' && typeof c === 'object') {
          c = JSON.parse(JSON.stringify(c));
          remap(c, 'autoGainControl', 'mozAutoGainControl');
          remap(c, 'noiseSuppression', 'mozNoiseSuppression');
        }
        return nativeApplyConstraints.apply(this, [c]);
      };
    }
  }
  navigator.getUserMedia = function(constraints, onSuccess, onError) {
    if (browserDetails.version < 44) {
      return getUserMedia_(constraints, onSuccess, onError);
    }
    // Replace Firefox 44+'s deprecation warning with unprefixed version.
    utils.deprecated('navigator.getUserMedia',
        'navigator.mediaDevices.getUserMedia');
    navigator.mediaDevices.getUserMedia(constraints).then(onSuccess, onError);
  };
};

},{"../utils":13}],12:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
'use strict';
var utils = require('../utils');

var safariShim = {
  // TODO: DrAlex, should be here, double check against LayoutTests

  // TODO: once the back-end for the mac port is done, add.
  // TODO: check for webkitGTK+
  // shimPeerConnection: function() { },

  shimLocalStreamsAPI: function(window) {
    if (typeof window !== 'object' || !window.RTCPeerConnection) {
      return;
    }
    if (!('getLocalStreams' in window.RTCPeerConnection.prototype)) {
      window.RTCPeerConnection.prototype.getLocalStreams = function() {
        if (!this._localStreams) {
          this._localStreams = [];
        }
        return this._localStreams;
      };
    }
    if (!('getStreamById' in window.RTCPeerConnection.prototype)) {
      window.RTCPeerConnection.prototype.getStreamById = function(id) {
        var result = null;
        if (this._localStreams) {
          this._localStreams.forEach(function(stream) {
            if (stream.id === id) {
              result = stream;
            }
          });
        }
        if (this._remoteStreams) {
          this._remoteStreams.forEach(function(stream) {
            if (stream.id === id) {
              result = stream;
            }
          });
        }
        return result;
      };
    }
    if (!('addStream' in window.RTCPeerConnection.prototype)) {
      var _addTrack = window.RTCPeerConnection.prototype.addTrack;
      window.RTCPeerConnection.prototype.addStream = function(stream) {
        if (!this._localStreams) {
          this._localStreams = [];
        }
        if (this._localStreams.indexOf(stream) === -1) {
          this._localStreams.push(stream);
        }
        var self = this;
        stream.getTracks().forEach(function(track) {
          _addTrack.call(self, track, stream);
        });
      };

      window.RTCPeerConnection.prototype.addTrack = function(track, stream) {
        if (stream) {
          if (!this._localStreams) {
            this._localStreams = [stream];
          } else if (this._localStreams.indexOf(stream) === -1) {
            this._localStreams.push(stream);
          }
        }
        _addTrack.call(this, track, stream);
      };
    }
    if (!('removeStream' in window.RTCPeerConnection.prototype)) {
      window.RTCPeerConnection.prototype.removeStream = function(stream) {
        if (!this._localStreams) {
          this._localStreams = [];
        }
        var index = this._localStreams.indexOf(stream);
        if (index === -1) {
          return;
        }
        this._localStreams.splice(index, 1);
        var self = this;
        var tracks = stream.getTracks();
        this.getSenders().forEach(function(sender) {
          if (tracks.indexOf(sender.track) !== -1) {
            self.removeTrack(sender);
          }
        });
      };
    }
  },
  shimRemoteStreamsAPI: function(window) {
    if (typeof window !== 'object' || !window.RTCPeerConnection) {
      return;
    }
    if (!('getRemoteStreams' in window.RTCPeerConnection.prototype)) {
      window.RTCPeerConnection.prototype.getRemoteStreams = function() {
        return this._remoteStreams ? this._remoteStreams : [];
      };
    }
    if (!('onaddstream' in window.RTCPeerConnection.prototype)) {
      Object.defineProperty(window.RTCPeerConnection.prototype, 'onaddstream', {
        get: function() {
          return this._onaddstream;
        },
        set: function(f) {
          if (this._onaddstream) {
            this.removeEventListener('addstream', this._onaddstream);
            this.removeEventListener('track', this._onaddstreampoly);
          }
          this.addEventListener('addstream', this._onaddstream = f);
          this.addEventListener('track', this._onaddstreampoly = function(e) {
            var stream = e.streams[0];
            if (!this._remoteStreams) {
              this._remoteStreams = [];
            }
            if (this._remoteStreams.indexOf(stream) >= 0) {
              return;
            }
            this._remoteStreams.push(stream);
            var event = new Event('addstream');
            event.stream = e.streams[0];
            this.dispatchEvent(event);
          }.bind(this));
        }
      });
    }
  },
  shimCallbacksAPI: function(window) {
    if (typeof window !== 'object' || !window.RTCPeerConnection) {
      return;
    }
    var prototype = window.RTCPeerConnection.prototype;
    var createOffer = prototype.createOffer;
    var createAnswer = prototype.createAnswer;
    var setLocalDescription = prototype.setLocalDescription;
    var setRemoteDescription = prototype.setRemoteDescription;
    var addIceCandidate = prototype.addIceCandidate;

    prototype.createOffer = function(successCallback, failureCallback) {
      var options = (arguments.length >= 2) ? arguments[2] : arguments[0];
      var promise = createOffer.apply(this, [options]);
      if (!failureCallback) {
        return promise;
      }
      promise.then(successCallback, failureCallback);
      return Promise.resolve();
    };

    prototype.createAnswer = function(successCallback, failureCallback) {
      var options = (arguments.length >= 2) ? arguments[2] : arguments[0];
      var promise = createAnswer.apply(this, [options]);
      if (!failureCallback) {
        return promise;
      }
      promise.then(successCallback, failureCallback);
      return Promise.resolve();
    };

    var withCallback = function(description, successCallback, failureCallback) {
      var promise = setLocalDescription.apply(this, [description]);
      if (!failureCallback) {
        return promise;
      }
      promise.then(successCallback, failureCallback);
      return Promise.resolve();
    };
    prototype.setLocalDescription = withCallback;

    withCallback = function(description, successCallback, failureCallback) {
      var promise = setRemoteDescription.apply(this, [description]);
      if (!failureCallback) {
        return promise;
      }
      promise.then(successCallback, failureCallback);
      return Promise.resolve();
    };
    prototype.setRemoteDescription = withCallback;

    withCallback = function(candidate, successCallback, failureCallback) {
      var promise = addIceCandidate.apply(this, [candidate]);
      if (!failureCallback) {
        return promise;
      }
      promise.then(successCallback, failureCallback);
      return Promise.resolve();
    };
    prototype.addIceCandidate = withCallback;
  },
  shimGetUserMedia: function(window) {
    var navigator = window && window.navigator;

    if (!navigator.getUserMedia) {
      if (navigator.webkitGetUserMedia) {
        navigator.getUserMedia = navigator.webkitGetUserMedia.bind(navigator);
      } else if (navigator.mediaDevices &&
          navigator.mediaDevices.getUserMedia) {
        navigator.getUserMedia = function(constraints, cb, errcb) {
          navigator.mediaDevices.getUserMedia(constraints)
          .then(cb, errcb);
        }.bind(navigator);
      }
    }
  },
  shimRTCIceServerUrls: function(window) {
    // migrate from non-spec RTCIceServer.url to RTCIceServer.urls
    var OrigPeerConnection = window.RTCPeerConnection;
    window.RTCPeerConnection = function(pcConfig, pcConstraints) {
      if (pcConfig && pcConfig.iceServers) {
        var newIceServers = [];
        for (var i = 0; i < pcConfig.iceServers.length; i++) {
          var server = pcConfig.iceServers[i];
          if (!server.hasOwnProperty('urls') &&
              server.hasOwnProperty('url')) {
            utils.deprecated('RTCIceServer.url', 'RTCIceServer.urls');
            server = JSON.parse(JSON.stringify(server));
            server.urls = server.url;
            delete server.url;
            newIceServers.push(server);
          } else {
            newIceServers.push(pcConfig.iceServers[i]);
          }
        }
        pcConfig.iceServers = newIceServers;
      }
      return new OrigPeerConnection(pcConfig, pcConstraints);
    };
    window.RTCPeerConnection.prototype = OrigPeerConnection.prototype;
    // wrap static methods. Currently just generateCertificate.
    if ('generateCertificate' in window.RTCPeerConnection) {
      Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {
        get: function() {
          return OrigPeerConnection.generateCertificate;
        }
      });
    }
  },
  shimTrackEventTransceiver: function(window) {
    // Add event.transceiver member over deprecated event.receiver
    if (typeof window === 'object' && window.RTCPeerConnection &&
        ('receiver' in window.RTCTrackEvent.prototype) &&
        // can't check 'transceiver' in window.RTCTrackEvent.prototype, as it is
        // defined for some reason even when window.RTCTransceiver is not.
        !window.RTCTransceiver) {
      Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {
        get: function() {
          return {receiver: this.receiver};
        }
      });
    }
  },

  shimCreateOfferLegacy: function(window) {
    var origCreateOffer = window.RTCPeerConnection.prototype.createOffer;
    window.RTCPeerConnection.prototype.createOffer = function(offerOptions) {
      var pc = this;
      if (offerOptions) {
        var audioTransceiver = pc.getTransceivers().find(function(transceiver) {
          return transceiver.sender.track &&
              transceiver.sender.track.kind === 'audio';
        });
        if (offerOptions.offerToReceiveAudio === false && audioTransceiver) {
          if (audioTransceiver.direction === 'sendrecv') {
            audioTransceiver.setDirection('sendonly');
          } else if (audioTransceiver.direction === 'recvonly') {
            audioTransceiver.setDirection('inactive');
          }
        } else if (offerOptions.offerToReceiveAudio === true &&
            !audioTransceiver) {
          pc.addTransceiver('audio');
        }

        var videoTransceiver = pc.getTransceivers().find(function(transceiver) {
          return transceiver.sender.track &&
              transceiver.sender.track.kind === 'video';
        });
        if (offerOptions.offerToReceiveVideo === false && videoTransceiver) {
          if (videoTransceiver.direction === 'sendrecv') {
            videoTransceiver.setDirection('sendonly');
          } else if (videoTransceiver.direction === 'recvonly') {
            videoTransceiver.setDirection('inactive');
          }
        } else if (offerOptions.offerToReceiveVideo === true &&
            !videoTransceiver) {
          pc.addTransceiver('video');
        }
      }
      return origCreateOffer.apply(pc, arguments);
    };
  }
};

// Expose public methods.
module.exports = {
  shimCallbacksAPI: safariShim.shimCallbacksAPI,
  shimLocalStreamsAPI: safariShim.shimLocalStreamsAPI,
  shimRemoteStreamsAPI: safariShim.shimRemoteStreamsAPI,
  shimGetUserMedia: safariShim.shimGetUserMedia,
  shimRTCIceServerUrls: safariShim.shimRTCIceServerUrls,
  shimTrackEventTransceiver: safariShim.shimTrackEventTransceiver,
  shimCreateOfferLegacy: safariShim.shimCreateOfferLegacy
  // TODO
  // shimPeerConnection: safariShim.shimPeerConnection
};

},{"../utils":13}],13:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */
'use strict';

var logDisabled_ = true;
var deprecationWarnings_ = true;

// Utility methods.
var utils = {
  disableLog: function(bool) {
    if (typeof bool !== 'boolean') {
      return new Error('Argument type: ' + typeof bool +
          '. Please use a boolean.');
    }
    logDisabled_ = bool;
    return (bool) ? 'adapter.js logging disabled' :
        'adapter.js logging enabled';
  },

  /**
   * Disable or enable deprecation warnings
   * @param {!boolean} bool set to true to disable warnings.
   */
  disableWarnings: function(bool) {
    if (typeof bool !== 'boolean') {
      return new Error('Argument type: ' + typeof bool +
          '. Please use a boolean.');
    }
    deprecationWarnings_ = !bool;
    return 'adapter.js deprecation warnings ' + (bool ? 'disabled' : 'enabled');
  },

  log: function() {
    if (typeof window === 'object') {
      if (logDisabled_) {
        return;
      }
      if (typeof console !== 'undefined' && typeof console.log === 'function') {
        console.log.apply(console, arguments);
      }
    }
  },

  /**
   * Shows a deprecation warning suggesting the modern and spec-compatible API.
   */
  deprecated: function(oldMethod, newMethod) {
    if (!deprecationWarnings_) {
      return;
    }
    console.warn(oldMethod + ' is deprecated, please use ' + newMethod +
        ' instead.');
  },

  /**
   * Extract browser version out of the provided user agent string.
   *
   * @param {!string} uastring userAgent string.
   * @param {!string} expr Regular expression used as match criteria.
   * @param {!number} pos position in the version string to be returned.
   * @return {!number} browser version.
   */
  extractVersion: function(uastring, expr, pos) {
    var match = uastring.match(expr);
    return match && match.length >= pos && parseInt(match[pos], 10);
  },

  /**
   * Browser detector.
   *
   * @return {object} result containing browser and version
   *     properties.
   */
  detectBrowser: function(window) {
    var navigator = window && window.navigator;

    // Returned result object.
    var result = {};
    result.browser = null;
    result.version = null;

    // Fail early if it's not a browser
    if (typeof window === 'undefined' || !window.navigator) {
      result.browser = 'Not a browser.';
      return result;
    }

    // Firefox.
    if (navigator.mozGetUserMedia) {
      result.browser = 'firefox';
      result.version = this.extractVersion(navigator.userAgent,
          /Firefox\/(\d+)\./, 1);
    } else if (navigator.webkitGetUserMedia) {
      // Chrome, Chromium, Webview, Opera, all use the chrome shim for now
      if (window.webkitRTCPeerConnection) {
        result.browser = 'chrome';
        result.version = this.extractVersion(navigator.userAgent,
          /Chrom(e|ium)\/(\d+)\./, 2);
      } else { // Safari (in an unpublished version) or unknown webkit-based.
        if (navigator.userAgent.match(/Version\/(\d+).(\d+)/)) {
          result.browser = 'safari';
          result.version = this.extractVersion(navigator.userAgent,
            /AppleWebKit\/(\d+)\./, 1);
        } else { // unknown webkit-based browser.
          result.browser = 'Unsupported webkit-based browser ' +
              'with GUM support but no WebRTC support.';
          return result;
        }
      }
    } else if (navigator.mediaDevices &&
        navigator.userAgent.match(/Edge\/(\d+).(\d+)$/)) { // Edge.
      result.browser = 'edge';
      result.version = this.extractVersion(navigator.userAgent,
          /Edge\/(\d+).(\d+)$/, 2);
    } else if (navigator.mediaDevices &&
        navigator.userAgent.match(/AppleWebKit\/(\d+)\./)) {
        // Safari, with webkitGetUserMedia removed.
      result.browser = 'safari';
      result.version = this.extractVersion(navigator.userAgent,
          /AppleWebKit\/(\d+)\./, 1);
    } else { // Default fallthrough: not supported.
      result.browser = 'Not a supported browser.';
      return result;
    }

    return result;
  },

};

// Export.
module.exports = {
  log: utils.log,
  deprecated: utils.deprecated,
  disableLog: utils.disableLog,
  disableWarnings: utils.disableWarnings,
  extractVersion: utils.extractVersion,
  shimCreateObjectURL: utils.shimCreateObjectURL,
  detectBrowser: utils.detectBrowser.bind(utils)
};

},{}]},{},[3])(3)
}); /**
 * Created by Gifer on 28.01.2016.
 */

 "use strict";

 function MediaCall(){
     var Self      = this;
     var myStream  = null;
     var pcList    = {};
     var pcStreams = {};
     var calleeUIN = null;
     var failTimer = null;
     var pc        = null;
     var mirrorContainer = null;
     var calleeContainer = null;
     var devices   = {

     };
     var iceRestart= false;
     var isWeb     = location.protocol !== "file:";
     var isMyCall  = false;

     var configuration  = {
         iceTransportPolicy : "all",
         iceTransport : "all",
         iceServers : []
     };
     var streamBackup   = null;
     var streamAssigned = false;

     // ===========================================================

     this.onFailedInit  = null;
     this.onError       = null;
     this.sendAnswer    = null;
     this.sendOffer     = null;
     this.sendCandidate = null;
     this.showMedia     = null;
     this.iceClosed     = null;

     this.restoreCall   = false;
     this.useVideo      = false;
     this.MID           = null;
     this.initFailTime  = 95000;
     this.Share         = false;
     this.receiveScreen = false;

     // ===========================================================

     function isArray(obj){
         return Object.prototype.toString.call( obj ) === '[object Array]';
     }

     function isObject(obj) {
         return Object.prototype.toString.call( obj ) === '[object Object]';
     }

     function onIceStateChange(pc) { // event
         if (pc) {
             if ( pc.iceConnectionState === 'connected' || pc.iceConnectionState === 'completed') {
                 pc.getStats(null).then(function(results) {
                     // figure out the peer's ip
                     var activeCandidatePair = null;
                     var remoteCandidate = null;

                     // search for the candidate pair
                     Object.keys(results).forEach(function(result) {
                         var report = results[result];

                         if (report.type === 'candidatepair' && report.selected || report.type === 'googCandidatePair' &&
                             report.googActiveConnection === 'true') {
                             activeCandidatePair = report;
                         }
                     });

                     if (activeCandidatePair && activeCandidatePair.remoteCandidateId) {
                         Object.keys(results).forEach(function(result) {
                             var report = results[result];

                             if (report.type === 'remotecandidate' && report.id === activeCandidatePair.remoteCandidateId) {
                                 remoteCandidate = report;
                             }
                         });
                     }

                     if (remoteCandidate && remoteCandidate.ipAddress && remoteCandidate.portNumber) {
                         console.log('[onIceStateChange]: Remote address changed to ' + remoteCandidate.ipAddress + ":" + remoteCandidate.portNumber);
                     }
                 });
             }
         }
     }
     
     function assignStream(callee) {
         if (streamBackup && streamBackup.stream){
             var videoContainer = calleeContainer || document.createElement('video');

             videoContainer.className = "VideoCaller";
             videoContainer.autoplay  = true;
             videoContainer.srcObject = streamBackup.stream;

             pcStreams[callee] = videoContainer;

             streamAssigned = true;
         }

         console.log('AssignStream iceConnectionState: ' + pc.iceConnectionState);
         console.log(streamBackup);
     }

     function startCall(callee, sdp) {
         var createOffer = !sdp;

         pc = pcList[callee] || new RTCPeerConnection(configuration);

         console.log(JSON.stringify(configuration));

         if (!pcList[callee]) {
             pcList[callee] = pc;

             pc.oniceconnectionstatechange = function(evt) {
                 console.log("ICE connection state change: " + evt.target.iceConnectionState);

                 if (pc.iceConnectionState === 'disconnected') {
                     iceRestart = Self.restoreCall;
                 } else
                 if (pc.iceConnectionState === 'closed' && Self.iceClosed) {
                     Self.iceClosed();
                 } else

                 if (pc.iceConnectionState === 'failed'){
                     iceRestart = Self.restoreCall;

                     if (!Self.restoreCall) {
                         runError('Error: ICE Connection State FAILED!', 1);
                     }
                 } else

                 if ((pc.iceConnectionState === 'connected' || pc.iceConnectionState === 'completed') && Self.showMedia){
                     clearTimeout(failTimer);

                     onIceStateChange(pc, evt);

                     if (!iceRestart) {
                         Self.showMedia.apply(null, [pcStreams[callee]])
                     }

                     iceRestart = false;

                     if (!streamAssigned){
                         assignStream(callee);
                     }
                 }

                 if (iceRestart) {
                     setTimeout(function () {
                         startCall(callee);
                     }, 500);
                 }
             };

             pc.onicecandidateerror = function(err){
                 runError('OnIceCandidateError: ' + JSON.stringify(err), 1);
             };

             pc.onicecandidate = function (evt) { // send any ice candidates to the other peer
                 //console.log("ICE gathering state change: " + evt.target.iceGatheringState);

                 if (evt.candidate) {
                     console.log("OUTGOING ICE: " + evt.candidate.candidate);

                     Self.sendCandidate(callee, Self.MID, JSON.stringify(evt.candidate));
                 }
             };

             pc.onaddstream = function (evt) {
                 streamBackup = evt;

                 console.log('Get Remote Stream complete!');
             };

             // pc.ontrack = function (evt) {
             //     console.log(evt);
             // };

             if (Self.useVideo){
                 if (Object.prototype.toString.call( mirrorContainer ) === '[object String]'){
                     mirrorContainer = document.getElementById(mirrorContainer);
                 }

                 if (['[object HTMLVideoElement]', '[object HTMLAudioElement]'].indexOf(Object.prototype.toString.call( mirrorContainer )) === -1){
                     // console.error('\"mirrorContainer\" is not a HTML element!');

                     Self.hangUp('\"mirrorContainer\" is not a HTML element!');

                     return false;
                 } else
                 if (myStream){
                     mirrorContainer.srcObject = myStream;
                 }
             }

             if (myStream) pc.addStream(myStream);
         }

         console.log("ICE  GatheringState: " + pc.iceGatheringState);
         console.log("ICE ConnectionState: " + pc.iceConnectionState);

         if (createOffer){
             pc.createOffer({
                 offerToReceiveAudio: 1,
                 offerToReceiveVideo: 1,
                 iceRestart         : iceRestart
             }).then( function (desc) {
                 pc.setLocalDescription(desc);

                 Self.sendOffer(callee, Self.MID, JSON.stringify(desc));
             }, function(err){
                 Self.hangUp('CreateOffer: ' + JSON.stringify(err));
                 // runError('CreateOffer: ' + JSON.stringify(err), 1);
             });

         } else {
             if (!isObject(sdp)){
                 sdp = JSON.parse(sdp);
             }

             pc.setRemoteDescription(new RTCSessionDescription(sdp));

             pc.createAnswer(function (desc) {
                 pc.setLocalDescription(desc);

                 Self.sendAnswer(callee, Self.MID, JSON.stringify(desc));
             }, function(err){
                 Self.hangUp('CreateAnswer: ' + JSON.stringify(err));
                 // runError('CreateAnswer: ' + JSON.stringify(err), 1);
             });
         }

         return pc;
     }

     function runError(){
         clearTimeout(failTimer);

         if (Self.onError){
             Self.onError.apply(null, arguments);
         }
     }

     function getScreen(nextStep) {
         if (!isWeb && !Self.useVideo) {
             navigator.getUserMedia({
                 audio : false,
                 video : {
                     mandatory: {
                         chromeMediaSource  : 'desktop',
                         chromeMediaSourceId: "screen:0:0",
                         minWidth           : 160,
                         minHeight          : 120,
                         maxWidth           : 1920,
                         maxHeight          : 1080,
                         minFrameRate       : 5,
                         maxFrameRate       : 15
                     }
                 }
             }, function successGetMedia(screenStream) {
                 var shareStream = screenStream.getVideoTracks()[0];

                 if (!myStream) {
                     myStream = screenStream;
                 } else {
                     myStream.addTrack(shareStream);
                 }

                 shareStream.enabled = Self.Share;

                 nextStep();
             }, function errorGetMedia(err){
                 console.warn('Error getting screen stream: ' + JSON.stringify(err));

                 if (myStream){
                     nextStep();
                 } else {
                     Self.hangUp("No media devices");
                 }
             });
         } else {
             if (myStream){
                 nextStep();
             } else {
                 Self.hangUp("No media devices");
             }
         }
     }

     function GetMedia(cb){
         if (!myStream){
             var opt = {
                 "audio": {
                     optional: [].concat(devices && devices.microphone ? {sourceId: devices.microphone} : [])
                 },
                 "video": Self.useVideo ? {
                     mandatory: {
                         minWidth: 160,
                         maxWidth: 1280,
                         minHeight: 120,
                         maxHeight: 720,
                         minAspectRatio: 4/3,
                         maxAspectRatio: 16/9,
                         minFrameRate: 10,
                         maxFrameRate: 50
                     },
                     optional: [].concat(Self.useVideo && devices.camera ? { sourceId: devices.camera } : [])
                 } : false
             };

             console.log('GetMedia config: ' + JSON.stringify(opt));

             failTimer = setTimeout(function () {
                 if (Self.onFailedInit){
                     Self.onFailedInit();
                 }

                 failTimer = null;

                 GetMedia(cb);
             }, Self.initFailTime);

             navigator.getUserMedia(opt, function successGetMedia(stream) {
                 console.log('getUserMedia: Media stream get successfully');

                 myStream = stream;

                 if (!myStream){
                     console.warn('Getting empty stream!');
                 }

                 getScreen(cb);
             }, function errorGetMedia(err){
                 myStream = null;

                 if (err.name === "NotFoundError" && Self.Share){
                     getScreen(cb);
                 } else
                 if (isMyCall){
                     Self.hangUp('Error getting media stream: ' + JSON.stringify(err));
                 } else {
                     cb();
                 }
             })
         } else {
             cb();
         }
     }

     // ===========================================================

     this.addIceServers = function (srv, iceTransportPolicy){
         configuration.iceServers         = srv || [];
         configuration.iceTransportPolicy = iceTransportPolicy || "all";
         configuration.iceTransport       = iceTransportPolicy || "all";
     };

     this.setDevices = function (microphome, camera, sound) {
         if (isObject(microphome)){
             devices = {
                 microphone : microphome.microphome,
                 camera     : microphome.camera,
                 sound      : microphome.sound
             };
         } else {
             devices = {
                 microphone : microphome,
                 camera     : camera,
                 sound      : sound
             };
         }

         console.log("DEVICES:" + JSON.stringify(devices));
     };

     this.setMirror     = function (target){
         mirrorContainer = target;
     };

     this.setCallee     = function (target){
         if (Object.prototype.toString.call( target ) === '[object String]'){
             calleeContainer = document.getElementById(target);
         } else {
             calleeContainer = target;
         }

         if (['[object HTMLVideoElement]', '[object HTMLAudioElement]'].indexOf(Object.prototype.toString.call( calleeContainer )) === -1){
             // console.error('\"calleeContainer\" is not a HTML element!'); // todo: fucking shit error

             Self.hangUp('\"calleeContainer\" is not a HTML element!');
         }
     };

     this.recvAnswer    = function (data){
         console.log('RECEIVE ANSWER');

         if (!isObject(data.SDP)){
             data.SDP = JSON.parse(data.SDP);
         }

         if (pcList[data.UIN] && pcList[data.UIN].setRemoteDescription){
             pcList[data.UIN].setRemoteDescription(new RTCSessionDescription(data.SDP));
         } else {
             Self.hangUp('error in "RECEIVE ANSWER"');
         }
     };

     this.recvOffer     = function (data){
         console.log('RECEIVE OFFER');

         isMyCall = false;

         GetMedia(function(){
             startCall(data.UIN, data.SDP);
         });
     };

     this.recvCandidate = function (data){
         console.log('RECEIVE CANDIDATE');

         if (pcList[data.UIN] && pcList[data.UIN].addIceCandidate) {
             if (!isObject(data.CANDIDATE)){
                 data.CANDIDATE = JSON.parse(data.CANDIDATE);
             }

             pcList[data.UIN].addIceCandidate(new RTCIceCandidate(data.CANDIDATE));
         }

         console.log("INCOMING ICE:" + JSON.stringify(data.CANDIDATE));
     };

     this.recvReady     = function (list){
         console.log('RECEIVE READY');

         pc = null;

         calleeUIN = list || calleeUIN;

         if (calleeUIN){
             isMyCall = true;

             GetMedia(function(){
                 if (calleeUIN){
                     if (!isArray(calleeUIN)){
                         calleeUIN = calleeUIN.toString().split(',');
                     }

                     calleeUIN.forEach(function(uin){
                         startCall(uin);
                     });
                 }
             });
         }
     };

     this.restartIceNow = function () {
         iceRestart = true;

         startCall(isArray(calleeUIN) ? calleeUIN[0] : calleeUIN);
     };

     this.CallToUser    = function (uin){
         calleeUIN = uin;
     };

     this.switchCamera  = function () {
         var stream = myStream ? myStream.getVideoTracks() : [];

         if (stream.length) {
             stream[0].enabled = !stream[0].enabled;
         }

         return stream && stream[0] ? stream[0].enabled : false;
     };

     this.switchMicrophone = function () {
         var stream = myStream ? myStream.getAudioTracks() : [];

         if (stream.length) {
             stream[0].enabled = !stream[0].enabled;
         }

         return stream && stream[0] ? stream[0].enabled : false;
     };

     this.hangUp        = function (error){
         console.log('Hang Up Call');

         if (myStream) {
             try {
                 mirrorContainer.pause();
                 mirrorContainer.srcObject = null;
             } catch (e){}

             if (myStream.getTracks) myStream.getTracks().forEach(function(track){
                 track.stop();
             });
         } else {
             if (Self.iceClosed) {
                 Self.iceClosed();
             }
         }

         for (var i in pcStreams){
         }

         try {
             pcStreams[i].pause();
             pcStreams[i].srcObject.getTracks().forEach(function(track){
                 track.stop();
             });
         } catch (e){}

         for (var i in pcList){
             pcList[i].close();
             pcList[i] = null;
         }

         pcList    = {};
         pcStreams = {};
         myStream  = null;
         calleeUIN = null;
         Self.MID  = null;

         streamBackup   = null;
         streamAssigned = false;


         clearTimeout(failTimer);
         failTimer = null;

         if (error){
             runError(error);
         }

         isMyCall = false;
     };
 }
 /**
 * Created by Gifer on 03.02.2016.
 */

 "use strict";

 function CallStates(){
     var current_state       = 0;   // текущее состояние
     var universalStateEvent = null;
     var Self = this;

     function isArray(obj){
         return Object.prototype.toString.call( obj ) === '[object Array]';
     }

     this.list = {
         free                               : 0,   // свободен

         outgoing_call_try                  : 1,   // попытка исходящего звонка
         outgoing_call_busy                 : 2,   // исходящий звонок, абонент занят
         outgoing_call_rejected             : 3,   // абонент отказался принять ваш звонок
         outgoing_call_accepted             : 4,   // абонент принял ваш звонок
         outgoing_call_cancelled            : 5,   // отбой исходящего звонка мной, я передумал
         outgoing_call_cancelled_by_timeout : 6,   // исходящий звонок не состоялся, абонент не ответил по тайм-ауту
         outgoing_call_remote_error         : 7,   // какая-то ошибка при исходящем звонке, на удалённой стороне
         outgoing_call_my_error             : 8,   // какая-то ошибка при исходящем звонке, на моей стороне
         outgoing_call_started              : 9,   // исходящий звонок успешно начался
         outgoing_call_my_close             : 10,  // я завершил исходящий звонок
         outgoing_call_remote_close         : 11,  // мой исходящий звонок был завершен удалённой стороной

         incoming_call_try                  : 101, //+ попытка входящего звонка
         incoming_call_busy                 : 102, // входящий звонок невозможен, у меня занято
         incoming_call_rejected             : 103, // я отказался от входящего звонка
         incoming_call_accepted             : 104, // я согласился принять входящий звонок
         incoming_call_cancelled            : 105, // удалённая сторона досрочно отказалась от звонка, я не спел согласиться или отказаться
         incoming_call_cancelled_by_timeout : 106, // входящий звонок не состоялся, я не ответил по тайм-ауту
         incoming_call_remote_error         : 107, // какая-то ошибка при входящем звонке, на удалённой стороне
         incoming_call_my_error             : 108, // какая-то ошибка при входящем звонке, на моей стороне
         incoming_call_started              : 109, // входящий звонок успешно начался
         incoming_call_my_close             : 110, // я завершил входящий звонок
         incoming_call_remote_close         : 111  // вхолящий звонок завершил удалённый пользователь
     };

     this.setStateEvent = function(state, args){
         current_state = state;

         console.log('State changed to: ' + state);

         if (universalStateEvent){
             universalStateEvent.apply(current_state, isArray(args) ? args : [args]);
         }
     };

     this.setUniversalStateEvent = function(event){
         universalStateEvent = event;
     };

     this.currentState = function(){
         return current_state;
     };

     this.setCustomCallEvent = function(state/*, event*/){
         current_state = state;

         console.log('State changed to: ' + state);
     };

     this.clearState = function(){
         current_state   = Self.list.free;
         Self.isMyCall   = false;

         console.log('Clear State: ' + current_state);
     };

     this.isMyCall = false;
 }
"use strict";

function mcPlaySound($rootScope){
    var isBrowser = location.protocol !== 'file:';

    var Sounds    = {
        Call      : 1,
        Receive   : 2,
        Reject    : 3,
        Busy      : 4,
        End       : 5,
        Private   : 6,
        ConfMsg   : 7,
        JoinConf  : 8,
        LeaveConf : 9,
        EnterBtn  : 10,
        Typing    : 11,
        DeleteAct : 12,
        BBS       : 13
    };

    var SoundList = {};

    var self = this;

    var nowPlaying = null;

    this.snd = Sounds;
    this.Sounds = Sounds;

    function _play(idx) {
        nowPlaying = idx;

        try {
            SoundList[idx].play().catch(function () {});
            SoundList[idx].onended = SoundList[idx].onended || function () {
                this.onended = null;
                
                if (this.sndIdx === nowPlaying) nowPlaying = null;
            };
            SoundList[nowPlaying].onpause = SoundList[nowPlaying].onpause || function () {
                this.onpause = null;

                if (this.sndIdx === nowPlaying) nowPlaying = null;
            };
        } catch (e){}
    }

    this.Play = function(idx, once){
        if ($rootScope.isWebClient || !mcConst.ClientSettings.SoundsAllSoundsOff)
        if (SoundList[idx]){
            if (once){
                SoundList[idx].currentTime = 0;
            } else

            if (nowPlaying){
                self.Stop(nowPlaying);
            }

            _play(idx);
        } else {
            console.warn("Sound idx: " + idx + " is not defined");
        }
    };

    this.PlaySound = this.Play;

    this.Stop = function(idx){
        if (idx) {
            if (SoundList[idx]){
                try {
                    SoundList[idx].pause();
                    SoundList[idx].currentTime = 0;
                } catch (e){}
            } else {
                console.warn("Sound idx: " + idx + " is not defined");
            }
        } else {
            for (var sound in SoundList) {
                if (SoundList[sound]){
                    try {
                        SoundList[sound].pause();
                        SoundList[sound].currentTime = 0;
                    } catch (e){}
                }
            }
        }
    };

    function init() {
        var html = "";

        if (isBrowser){ // Web Client
            html =
                '<audio id="Sound_Ring"      preload loop><source src="source/media/mediaincomingcall.mp3" type="audio/mpeg"></audio>'+
                '<audio id="Sound_Calling"   preload loop><source src="source/media/mediacall.mp3" type="audio/mpeg"></audio>'+
                '<audio id="Sound_End"       preload><source src="source/media/mediaendcall.mp3" type="audio/mpeg"></audio>'+
                '<audio id="Sound_Reject"    preload><source src="source/media/mediacallreject.mp3" type="audio/mpeg"></audio>'+
                '<audio id="Sound_Busy"      preload><source src="source/media/mediabusy.mp3" type="audio/mpeg"></audio>'+
                '<audio id="Sound_Private"   preload><source src="source/media/private.mp3" type="audio/mpeg"></audio>' +
                '<audio id="Sound_EnterBtn"  preload><source src="source/media/chatret.mp3" type="audio/mpeg"></audio>' +
                '<audio id="Sound_Typing"    preload><source src="source/media/chattype.mp3" type="audio/mpeg"></audio>'+
                '<audio id="Sound_JoinConf"  preload><source src="source/media/join.mp3" type="audio/mpeg"></audio>'+
                '<audio id="Sound_ConfMsg"   preload><source src="source/media/chat.mp3" type="audio/mpeg"></audio>'+
                '<audio id="Sound_DeleteAct" preload><source src="source/media/chatbs.mp3" type="audio/mpeg"></audio>'+
                '<audio id="Sound_LeaveConf" preload><source src="source/media/leave.mp3" type="audio/mpeg"></audio>';
        } else { // Electron Client
            
            var profile = require('../service/profile');
            var pathToSounds = profile.getProfilePath() + '/sounds/';

            html =
                '<audio id="Sound_BBS"       preload><source src="' + pathToSounds + 'newmsg.mp3" type="audio/mpeg"></audio>'+
                '<audio id="Sound_Ring"      preload loop><source src="' + pathToSounds + 'mediaincomingcall.mp3" type="audio/mpeg"></audio>'+
                '<audio id="Sound_Calling"   preload loop><source src="' + pathToSounds + 'mediacall.mp3"  type="audio/mpeg"></audio>'+
                '<audio id="Sound_End"       preload><source src="' + pathToSounds + 'mediaendcall.mp3"    type="audio/mpeg"></audio>'+
                '<audio id="Sound_Reject"    preload><source src="' + pathToSounds + 'mediacallreject.mp3" type="audio/mpeg"></audio>'+
                '<audio id="Sound_Busy"      preload><source src="' + pathToSounds + 'mediabusy.mp3" type="audio/mpeg"></audio>'+
                '<audio id="Sound_ConfMsg"   preload><source src="' + pathToSounds + 'chat.mp3"      type="audio/mpeg"></audio>'+
                '<audio id="Sound_JoinConf"  preload><source src="' + pathToSounds + 'join.mp3"      type="audio/mpeg"></audio>'+
                '<audio id="Sound_LeaveConf" preload><source src="' + pathToSounds + 'leave.mp3"     type="audio/mpeg"></audio>'+
                '<audio id="Sound_EnterBtn"  preload><source src="' + pathToSounds + 'chatret.mp3"   type="audio/mpeg"></audio>'+
                '<audio id="Sound_Typing"    preload><source src="' + pathToSounds + 'chattype.mp3"  type="audio/mpeg"></audio>'+
                '<audio id="Sound_DeleteAct" preload><source src="' + pathToSounds + 'chatbs.mp3"    type="audio/mpeg"></audio>'+
                '<audio id="Sound_Private"   preload><source src="' + pathToSounds + 'private.mp3"   type="audio/mpeg"></audio>';
        }

        document.body.insertAdjacentHTML('beforeEnd', html);

        SoundList[Sounds.Call]      = document.getElementById("Sound_Ring");
        SoundList[Sounds.Receive]   = document.getElementById("Sound_Calling");
        SoundList[Sounds.Reject]    = document.getElementById("Sound_End");
        SoundList[Sounds.Busy]      = document.getElementById("Sound_Reject");
        SoundList[Sounds.End]       = document.getElementById("Sound_Busy");
        SoundList[Sounds.Private]   = document.getElementById("Sound_Private");
        SoundList[Sounds.JoinConf]  = document.getElementById("Sound_JoinConf");
        SoundList[Sounds.LeaveConf] = document.getElementById("Sound_LeaveConf");
        SoundList[Sounds.EnterBtn]  = document.getElementById("Sound_EnterBtn");
        SoundList[Sounds.Typing]    = document.getElementById("Sound_Typing");
        SoundList[Sounds.ConfMsg]   = document.getElementById("Sound_ConfMsg");
        SoundList[Sounds.DeleteAct] = document.getElementById("Sound_DeleteAct");

        SoundList[Sounds.Call].sndIdx      = Sounds.Call;
        SoundList[Sounds.Receive].sndIdx   = Sounds.Receive;
        SoundList[Sounds.Reject].sndIdx    = Sounds.Reject;
        SoundList[Sounds.Busy].sndIdx      = Sounds.Busy;
        SoundList[Sounds.End].sndIdx       = Sounds.End;
        SoundList[Sounds.Private].sndIdx   = Sounds.Private;
        SoundList[Sounds.JoinConf].sndIdx  = Sounds.JoinConf;
        SoundList[Sounds.LeaveConf].sndIdx = Sounds.LeaveConf;
        SoundList[Sounds.EnterBtn].sndIdx  = Sounds.EnterBtn;
        SoundList[Sounds.Typing].sndIdx    = Sounds.Typing;
        SoundList[Sounds.ConfMsg].sndIdx   = Sounds.ConfMsg;
        SoundList[Sounds.DeleteAct].sndIdx = Sounds.DeleteAct;

        if (!isBrowser){
            SoundList[Sounds.BBS]        = document.getElementById("Sound_BBS");
            SoundList[Sounds.BBS].sndIdx = Sounds.BBS;
        }
    }

    init();
}
function Create_cPanel(mediaCall, video, share, videoContainer) {
    function _Timer (_target){
        function getTime(Now) {
            var ss = Now % 60;
            var hh = parseInt(Now / 3600);
            var nn = parseInt(Now / 60) - (hh * 60);

            return ((hh < 10) ? ("0" + hh) : hh) + ":" + ((nn < 10) ? ("0" + nn) : nn) + ":" + ((ss < 10) ? ("0" + ss) : ss);
        }

        var Now = 0;
        var id  = null;

        this.Start = function(){
            id = setInterval(function(){
                _target.innerText = getTime(Now++);
            }, 1000);
        };

        this.Stop = function(){
            clearInterval(id);

            console.log('Stop timer, Now: ' + Now);

            return Now || 0;
        };
    }

    function showPanel() {
        if (panelShowed){
            clearTimeout(hideTimer);

            hideTimer = setTimeout(function () {
                panelShowed = false;
                hideTimer   = null;

                _fade.out();
            }, 4000);
        } else {
            _fade.in();

            panelShowed = true;
        }
    }

    var Self        = this;
    var isFit       = false;
    var isMax       = false;
    var panelShowed = false;
    var hideTimer   = null;
    var _cPanel     = document.createElement("div");
    var mediaTimer  = null;
    var controls    = {
        cameraSwitch     : document.createElement("span"),
        microphoneSwitch : document.createElement("span"),
        cancelCall       : document.createElement("span"),
        fillFitScreen    : document.createElement("span"),
        minMaxScreen     : document.createElement("span"),
        callTime         : document.createElement("div"),
    };
    var _fade       = new mcService.FadeControl(_cPanel);

    _cPanel.id                   = "cPanel";
    controls.cameraSwitch    .id = "cameraSwitch";
    controls.microphoneSwitch.id = "microphoneSwitch";
    controls.cancelCall      .id = "cancelCall";
    controls.fillFitScreen   .id = "fillFitScreen";
    controls.minMaxScreen    .id = "minMaxScreen";
    controls.callTime        .id = "callTime";

    controls.cameraSwitch .style.display = video ? "inline-block" : "none";
    controls.fillFitScreen.style.display = share ? "inline-block" : "none";
    controls.minMaxScreen .style.display = video || share ? "inline-block" : "none";
    controls.callTime     .innerText     = "00:00:00";

    _cPanel.appendChild(controls.cameraSwitch);
    _cPanel.appendChild(controls.microphoneSwitch);
    _cPanel.appendChild(controls.fillFitScreen);
    _cPanel.appendChild(controls.minMaxScreen);
    _cPanel.appendChild(controls.cancelCall);
    _cPanel.appendChild(controls.callTime);


    // ------------------------

    controls.cameraSwitch.addEventListener('click', function(){
        if (mediaCall.switchCamera()){
            controls.cameraSwitch.className = "";
        } else {
            controls.cameraSwitch.className = "cameraSwitchOFF";
        }
    });

    controls.microphoneSwitch.addEventListener('click', function(){
        if (mediaCall.switchMicrophone()) {
            controls.microphoneSwitch.className = "";
        } else {
            controls.microphoneSwitch.className = "microphoneSwitchOFF";
        }
    });

    controls.fillFitScreen.addEventListener('click', function(){
        if (Self.fitFill) Self.fitFill(isFit, videoContainer);

        controls.fillFitScreen.className = isFit ? "" : "fillFitScreenOFF";

        isFit = !isFit;
    });

    controls.minMaxScreen.addEventListener('click', function () {
        if (Self.minMax) Self.minMax(isMax);

        isMax = !isMax;
    });

    controls.cancelCall.addEventListener('click', function () {
        if (Self.closeCall) Self.closeCall();
    });

    // --------------------------------

    this.body      = _cPanel;
    this.closeCall = null;
    this.minMax    = null;
    this.fitFill   = null;

    this.init = function (parent) {
        if (parent){
            parent.appendChild(_cPanel);
        }

        mediaTimer = new _Timer(controls.callTime);
    };

    this.show = function () {
        _cPanel.className    += "whitePanelBG";
        _cPanel.style.opacity = 1;

        panelShowed = true;

        showPanel();

        mediaTimer.Start();
    };

    this.onmousemove = showPanel;

    this.destructor = function () {
        if (_cPanel){
            _cPanel.innerHTML = "";

            if (_cPanel.parentNode) {
                _cPanel.parentNode.removeChild(_cPanel);
            }

            _cPanel = null;
        }

        if (mediaTimer) {
            mediaTimer.Stop();
            mediaTimer = null;
        }
    };
}/*
 * MIT License
 *  You may use this code as long as you retain this notice.  Use at your own risk! :)
 *  https://github.com/danschumann/limby-resize
 *  0.0.4
 */
var canvasResize = function (original, canvas, cb) {

    var
        w1 = original.width,
        h1 = original.height,
        w2 = canvas.width,
        h2 = canvas.height,
        img = original.getContext("2d").getImageData(0, 0, w1, h1),
        img2 = canvas.getContext("2d").getImageData(0, 0, w2, h2);

    if (w2 > w1 || h2 > h1) {
        canvas.getContext('2d').drawImage(original, 0, 0, w2, h2);
        return;
    }


    var data = img.data;
    // we don't use this much, as working with doubles isn't great
    var _data2 = img2.data;

    // We enforce float type for every entity in the array
    // this prevents weird faded lines when things get rounded off
    var data2 = Array(_data2.length);

    for (var i = 0; i < _data2.length; i++) {
        data2[i] = 0.0;
    }

    // We track alphas, since we need to use alphas to correct colors later on
    var alphas = Array(_data2.length >> 2);
    for (var i = 0; i < _data2.length >> 2; i++) {
        alphas[i] = 1;
    }

    // when resizing down, this will be decimal
    var xScale = w2 / w1;
    var yScale = h2 / h1;

    // For every pixel in the original, we tally it up in the new one
    var nextY = function (y1) {
        for (var x1 = 0; x1 < w1; x1++) {
            var

            // the original pixel is split between two pixels in the output, we do an extra step
                extraX = false,
                extraY = false,

            // the output pixel
                targetX = Math.floor(x1 * xScale),
                targetY = Math.floor(y1 * yScale),

            // The percentage of this pixel going to the output pixel
                xFactor = xScale,
                yFactor = yScale,

            // The percentage of this pixel going to the right neighbor or bottom neighbor
                bottomFactor = 0,
                rightFactor = 0,

            // positions of pixels in the array
                offset = (y1 * w1 + x1) * 4,
                targetOffset = (targetY * w2 + targetX) * 4;

            // Right side goes into another pixel
            if (targetX < Math.floor((x1 + 1) * xScale)) {

                rightFactor = (((x1 + 1) * xScale) % 1);
                xFactor -= rightFactor;

                extraX = true;

            }

            // Bottom side goes into another pixel
            if (targetY < Math.floor((y1 + 1) * yScale)) {

                bottomFactor = (((y1 + 1) * yScale) % 1);
                yFactor -= bottomFactor;

                extraY = true;

            }

            var a;

            a = (data[offset + 3] / 255);

            var alphaOffset = targetOffset / 4;

            if (extraX) {

                // Since we're not adding the color of invisible pixels,  we multiply by a
                data2[targetOffset + 4] += data[offset] * rightFactor * yFactor * a;
                data2[targetOffset + 5] += data[offset + 1] * rightFactor * yFactor * a;
                data2[targetOffset + 6] += data[offset + 2] * rightFactor * yFactor * a;

                data2[targetOffset + 7] += data[offset + 3] * rightFactor * yFactor;

                // if we left out the color of invisible pixels(fully or partly)
                // the entire average we end up with will no longer be out of 255
                // so we subtract the percentage from the alpha ( originally 1 )
                // so that we can reverse this effect by dividing by the amount.
                // ( if one pixel is black and invisible, and the other is white and visible,
                // the white pixel will weight itself at 50% because it does not know the other pixel is invisible
                // so the total(color) for the new pixel would be 128(gray), but it should be all white.
                // the alpha will be the correct 128, combinging alphas, but we need to preserve the color
                // of the visible pixels )
                alphas[alphaOffset + 1] -= (1 - a) * rightFactor * yFactor;
            }

            if (extraY) {
                data2[targetOffset + w2 * 4] += data[offset] * xFactor * bottomFactor * a;
                data2[targetOffset + w2 * 4 + 1] += data[offset + 1] * xFactor * bottomFactor * a;
                data2[targetOffset + w2 * 4 + 2] += data[offset + 2] * xFactor * bottomFactor * a;

                data2[targetOffset + w2 * 4 + 3] += data[offset + 3] * xFactor * bottomFactor;

                alphas[alphaOffset + w2] -= (1 - a) * xFactor * bottomFactor;
            }

            if (extraX && extraY) {
                data2[targetOffset + w2 * 4 + 4] += data[offset] * rightFactor * bottomFactor * a;
                data2[targetOffset + w2 * 4 + 5] += data[offset + 1] * rightFactor * bottomFactor * a;
                data2[targetOffset + w2 * 4 + 6] += data[offset + 2] * rightFactor * bottomFactor * a;

                data2[targetOffset + w2 * 4 + 7] += data[offset + 3] * rightFactor * bottomFactor;

                alphas[alphaOffset + w2 + 1] -= (1 - a) * rightFactor * bottomFactor;
            }

            data2[targetOffset] += data[offset] * xFactor * yFactor * a;
            data2[targetOffset + 1] += data[offset + 1] * xFactor * yFactor * a;
            data2[targetOffset + 2] += data[offset + 2] * xFactor * yFactor * a;

            data2[targetOffset + 3] += data[offset + 3] * xFactor * yFactor;

            alphas[alphaOffset] -= (1 - a) * xFactor * yFactor;
        }

        if (y1++ < h1)
            setTimeout(nextY.bind(this, y1), 0); // this allows other processes to tick
        else
            done();

    };

    nextY(0);

    var done = function () {

        // fully distribute the color of pixels that are partially full because their neighbor is transparent
        for (var i = 0; i < (_data2.length >> 2); i++) {
            if (alphas[i] && alphas[i] < 1) {
                data2[(i << 2)] /= alphas[i];     // r
                data2[(i << 2) + 1] /= alphas[i]; // g
                data2[(i << 2) + 2] /= alphas[i]; // b
            }
        }

        // re populate the actual imgData
        for (var i = 0; i < data2.length; i++) {
            _data2[i] = Math.round(data2[i]);
        }

        var context = canvas.getContext("2d");

        context.putImageData(img2, 0, 0);
        //deferred.resolve();

        if (cb) {
            cb();
        }
    };

    //var deferred = when.defer();
    //return deferred.promise

};

// Allow for use with browser or node.js
if ('undefined' !== typeof window) {
    window.canvasResize = canvasResize;
} else {
    module.exports = canvasResize;
}
"use strict";

function mcConnect ($http) {
    var ipc          = require('electron').ipcRenderer;
    var self         = this;

    var _config = {
        CallBackFunctionPull : {},
        idError              : 0,
        AjaxInProgress       : false,
        _Timeout             : 30000,
        CRLF                 : "\r\n",
        CR                   : "\r",
        LF                   : "\n"
    };

    self.asyncType      = true;
    self.NoCMD          = false;
    self.CallBackNoCMD  = null;
    self.LeaveCallBacks = false;

    var __clearError = function(){
        clearTimeout(_config.idError);
        _config.idError = 0;
    };

    ipc.on('scPostParser', function (em, data){
        __clearError();

        _config.AjaxInProgress = false;

        RequestSuccess(data);
    });

    var __SendData = function (_data/*, sync*/){
        ipc.send('csPostParser', _data);
    };

    /**
     * @return {number}
     */
    var ErrorControl = function (timeout){
        return setTimeout(function(){
            if (console) console.error("AHTUNG! Reload page.");

            _config.CallBackFunctionPull = {};

            _config.AjaxInProgress = false;

            if (self.OnError){
                self.OnError('error');
            }
        }, timeout);
    };

    /**
     * @return {number}
     */
    self.SendDataToServer = function(_data){
        var _sendData = '';
        var ___data = {};

        if ((!_data) || (_data.length === 0)) {
            if (console) console.warn('SendDataToServer: _data is empty or undefined');

            if (self.OnWarning) self.OnWarning({
                type : 'noSendData',
                cmd  : (_data) ? _data.CMD : undefined
            });

            return 1;
        } else {
            switch (typeof _data){
                case "string":
                    _sendData = _data;
                break;

                case "object":
                     ___data = mcService.Marge({
                        CMD        : '',
                        Data       : '',
                        OnReceive  : undefined,
                        Terminator : '\r',
                        AfterSend  : undefined
                    }, _data || {});

                    if (___data.Data === ''){
                        console.warn('SendDataToServer: [_data : Object] field "Data" is empty or undefined');

                        return 2;
                    }

                    if (Object.prototype.toString.call( ___data.Data ) === '[object Object]'){
                        ___data.Data = JSON.stringify(___data.Data);
                    }

                    _sendData = ((___data.CMD !== '') ? (___data.CMD + ___data.Terminator) : '') + ___data.Data;

                    if (___data.CMD !== ''){
                        if (___data.OnReceive){
                            self.SetCallBackFunctionByCMD(___data.CMD, ___data.OnReceive);
                        }
                    }
                break;

                case "function":
                break;
            }

            if (___data.immediately){
                __SendData(_sendData, true);
            } else {
                var idSendDataToServer = setInterval(function(){
                    if (_config.AjaxInProgress === false) {
                        _config.AjaxInProgress = true;

                        _config.idError = ErrorControl(_config._Timeout + 2000);

                        __SendData(_sendData);

                        if (self.ExtendedCallBackFunctionAtSandData){
                            self.ExtendedCallBackFunctionAtSandData.apply();
                        }

                        clearInterval(idSendDataToServer);
                    }
                }, 100);
            }
        }
    };

    //=====================================================================
    var RequestSuccess = function(msg){
        var WEB_CR_IDX = msg.indexOf(_config.CR);

        if (WEB_CR_IDX === -1) WEB_CR_IDX = msg.length;

        var request = msg.slice(0, WEB_CR_IDX);
        var _msg    = msg.slice(WEB_CR_IDX + 1, msg.length + 1);

        if (self.NoCMD) {
            self.CallBackNoCMD.apply(msg);
        } else {
            self.RunCallBackFunctionByCMD(request, _msg);
        }
    };
    /*function RequestSuccess(msg){
        var CR_IDX = msg.length ? msg.indexOf(_config.CR) : -1;

        if (CR_IDX !== -1) {
            //CR_IDX = msg.length;

            var cmd  = msg.slice(0, CR_IDX);
            var data = msg.slice(CR_IDX + 1, msg.length + 1);

            if (self.NoCMD) {
                self.CallBackNoCMD.apply(msg);
            } else {
                self.RunCallBackFunctionByCMD(cmd, data);
            }
        } else {
            var cmd  = "ping";

            if (self.NoCMD) {
                self.CallBackNoCMD.apply(msg);
            } else {
                self.RunCallBackFunctionByCMD(cmd, msg);
            }
        }
    }*/
    //=====================================================================
    self.OnError   = undefined;
    self.OnWarning = undefined;

    //=====================================================================
    self.SetCallBackFunctionByCMD = function(CMD, callback){
        if (callback){
            if (!_config.CallBackFunctionPull.hasOwnProperty(CMD)) {
                _config.CallBackFunctionPull[CMD] = [];
            }

            _config.CallBackFunctionPull[CMD].push(callback);
        }
    };

    //=====================================================================
    self.SetCallBackFunctionByCMDOnlyOne = function(CMD, callback){
        if (callback){
            _config.CallBackFunctionPull[CMD]    = [];
            _config.CallBackFunctionPull[CMD][0] = callback;
        }
    };

    //=====================================================================
    self.DelCallBackFunctionByCMD = function(CMD){
        if (_config.CallBackFunctionPull.hasOwnProperty(CMD)) {
            delete _config.CallBackFunctionPull[CMD];
        }
    };

    //=====================================================================
    self.ClearAllCallBackFunctionByCMD = function(){
        for (var i in _config.CallBackFunctionPull){
            if (_config.CallBackFunctionPull.hasOwnProperty(i)) delete _config.CallBackFunctionPull[i];
        }
    };

    //=====================================================================
    self.RunCallBackFunctionByCMD = function(CMD, MSG){
        var _next = (_config.CallBackFunctionPull.hasOwnProperty(CMD)) ? (_config.CallBackFunctionPull[CMD].length > 0) : false;

        if (!_next) {
            if (CMD !== 'OK' && CMD !== 'ping') {
                console.warn("CMD: \"" + CMD + "\" not have request func");
            }

            if (self.OnWarning) {
                self.OnWarning({
                    type : 'NoRunCallback',
                    cmd  : CMD
                });
            }
        }

        while (_next){
            if (_config.CallBackFunctionPull[CMD]){
                _config.CallBackFunctionPull[CMD][0].apply(MSG);
            }

            if (!self.LeaveCallBacks){
                _config.CallBackFunctionPull[CMD].shift();

                if (_config.CallBackFunctionPull[CMD].length === 0) {
                    delete _config.CallBackFunctionPull[CMD];
                }

                _next = (_config.CallBackFunctionPull.hasOwnProperty(CMD)) ? (_config.CallBackFunctionPull[CMD].length > 0) : false;
            } else {
                _next = false;
            }
        }
    };

    //=====================================================================
    self.ExtendedCallBackFunctionAtSandData = undefined;
}
"use strict";

function mcCmdLoop (mcConnect, $rootScope){
    window.idMcPingTimer = null;

    function RunCMD(InBuf, debug) {
        var _inBuf = [].concat(InBuf);
        var _inBufLength = _inBuf.length;

        if (debug) console.log("InBuf:\n" + InBuf);

        if (_inBufLength > 0){
            if (debug) {
                console.log("RunCMD, inBuf Length:" + _inBufLength);
                console.log("_inBuf:\n" + _inBuf);
            }

            var CMD_Block = _inBuf.shift();

            if (CMD_Block && CMD_Block.length > 0){
                CMD_Block = mcService.StringToObj(CMD_Block);

                for (var CMD_Numb in CMD_Block){
                    if (debug) console.log("Receive CMD: " + CMD_Numb);

                    (function(aa, bb){
                        if (debug){
                            console.log("Receive CMD: " + aa);
                            console.log(bb);
                        }

                        setTimeout(function () {
                            $rootScope.ProcessCMD([aa, bb]);
                        }, 0);
                    })(CMD_Numb, CMD_Block[CMD_Numb]);
                }

                if (_inBuf.length > 0) {
                    RunCMD(_inBuf);
                }
            }
        }

    }

    function cmdPing (sID){
        $rootScope.SendCMDToServer([mcConst._CMD_.Ping, sID]);
    }

    return function StartPingTimer(_time, sID, opt){ // this.StartPingTimer =
        var self = this;
        var options =  opt || {
            onError : null,
            onStop  : null,
            onWarn  : null
        };

        mcConnect.ClearAllCallBackFunctionByCMD();
        mcConnect.LeaveCallBacks = true;

        mcConnect.SetCallBackFunctionByCMD(mcConst._CMD_.Ping, function(){
            if ((this != "{}") && (this.length > 0)) {
                RunCMD(this.split('\r'));
            }
        });

        window.idMcPingTimer = (function(_sID){
            return setInterval(function(){
                cmdPing(_sID);
            }, _time);
        })(sID);

        self.StopPingTimer = function(){
            if (window.idMcPingTimer !== null){
                clearInterval(window.idMcPingTimer);

                window.idMcPingTimer = null;

                mcConnect.ClearAllCallBackFunctionByCMD();

                if (options.onStop) {
                    options.onStop();
                }
            }
        };

        mcConnect.OnError = function(err){
            if (console) {
                console.warn('An error occurred: Ping-Timer has been Stopped');
            }

            self.StopPingTimer();
            
            if (options.onError){
                options.onError(err);
            }
        };

    }
}
/**
 * Created by Gifer on 10.07.2015.
 */


function mcFileUploading($rootScope){
    "use strict";

    var uploader   = null;
    var errorCallback = null;
    var successCallback = null;
    var uploaderOptions = {};
    var inputFileName = "__fileSender__";
    var abortUploadingID = null;
    var abortPreparingUploading = null;
    var abortUploadingCB = null;
    var abortNow = false;
    var whereWeWork = "";

    function parseFile(file, callback) {
        var fileSize  = file.size;
        var chunkSize = 512 * 1024; // bytes
        var offset    = 0;
        var chunkReaderBlock = null;
        var onePercent     = file.size / 100;
        var currentPercent = 0;

        var readEventHandler = function (evt) {
            if (!abortNow){
                if (evt.target.error == null) {
                    offset += evt.target.result.byteLength;
                    currentPercent = (offset / onePercent).toFixed();

                    callback(null, evt.target.result, currentPercent); // callback for handling read chunk
                } else {
                    callback(evt.target.error);

                    return;
                }

                if (offset >= fileSize) {
                    callback(null, null, 100);

                    return;
                }

                chunkReaderBlock(fileReader, offset, chunkSize, file);
            }
        };

        chunkReaderBlock = function (_reader, _offset, length, _file) {
            var reader = _reader || new FileReader();
            var blob   = _file.slice(_offset, length + _offset);

            if (!_reader) {
                if (uploaderOptions.onBeforeFileAdd) {
                    uploaderOptions.onBeforeFileAdd(file);
                }

                if (!abortPreparingUploading){
                    abortPreparingUploading = function () {
                        reader.abort();
                        reader.onload = null;

                        abortPreparingUploading = null;
                    }
                }

                reader.onload = readEventHandler;
            }

            reader.readAsArrayBuffer(blob);

            return reader;
        };

        var fileReader = chunkReaderBlock(null, offset, chunkSize, file);
    }

    function startUploadAfterCheck(info, file) {
        uploaderOptions.Hash     = info.Hash; // SHA1 хэш файла
        uploaderOptions.Width    = $rootScope.thumbsSize.x; // произвольная ширина уменьшеной копии изображения
        uploaderOptions.Height   = $rootScope.thumbsSize.y; // произвольная высота уменьшенной копии изображения
        uploaderOptions.FileName = info.FileName; // локальное название файла

        if (!info.Present) { // file not exist - uploading
            uploader.define("upload", mcService.getLocalHostPath($rootScope.isWebClient) + "/uploading/?sid=" + mcConst.SessionID + "&hash=" + info.Hash + whereWeWork);
            uploader.addFile(file);
        } else {
            if (successCallback) {
                successCallback.apply(uploaderOptions, arguments);
            } else {
                console.trace('No set success callback on file uploading');
            }
        }
    }

    function electronUploader() {
        $rootScope.$broadcast(window._messages_.clientData.sendCMDToElectron, [
            mcConst._CMD_.ce_file_upload_start,
            uploaderOptions.filePath,
            {
                Where    : uploaderOptions.Where,
                ID       : uploaderOptions.ID,
                Type     : uploaderOptions.Type,
                chatType : uploaderOptions.chatType
            }
        ]);

        abortUploadingCB = function () {
            abortUploadingCB = null;

            $rootScope.$broadcast(window._messages_.clientData.sendCMDToElectron, [
                mcConst._CMD_.ce_file_upload_abort
            ]);
        };
        
        abortPreparingUploading = function () {
            abortPreparingUploading = null;

            $rootScope.$broadcast(window._messages_.clientData.sendCMDToElectron, [
                mcConst._CMD_.ce_file_upload_prepare_abort
            ]);
        };
    }

    function checkFileExist(params, cb) {
        $rootScope.SendCMDToServer(
            [ mcConst._CMD_.cs_is_file_exists, mcConst.SessionID ]
            .concat(params || [])
            .concat(cb)
        );
    }

    function _goUploadClipboardImage() {
        var calcSha1   = mcService.SHA1();
        var Hash       = "";
        var fileReader = new FileReader();

        fileReader.onloadend = function() {
            var screenImg = this.result;
            var imageInfo = uploaderOptions.clipboardImage;

            calcSha1.append(screenImg);

            if (!imageInfo.name || (imageInfo.name && imageInfo.name.indexOf("image.") === 0 && !imageInfo.path) ){
                try{
                    imageInfo["name"] = "Screenshot (" + mcConst.UserInfo.Nick + ") " + mcService.formatDate(new Date(), "dd-mm-yyyy hh-nn-ss") + ".png";
                } catch (e) {}
            }

            Hash = calcSha1.end();

            checkFileExist([
                Hash    ,                     // SHA1 хэш файла
                mcConst._CMD_.msgType.IMAGE,  // тип файла. 2 - изображение, 4 - обычный файл
                imageInfo.name,               // локальное название файла
                uploaderOptions.Where,
                uploaderOptions.ID   ,
                mcService.fileTimeStamp()
            ], function (data) {
                startUploadAfterCheck(data, imageInfo);
            });
        };

        fileReader.readAsArrayBuffer(uploaderOptions.clipboardImage);
    }

    function _goUploadFile() {
        var fileInput= this;
        var calcSha1 = mcService.SHA1();
        var file     = fileInput.files[0];
        var MsgType  = uploaderOptions.Type;

        if (file){
            uploaderOptions.fileSize = file.size;
            uploaderOptions.lastModifiedDate = file.lastModified || file.lastModifiedDate;

            setTimeout(function () {
                parseFile(file, function (err, data, percent) {
                    if (err) {
                        console.error("Read error: " + err);
                    } else {
                        if (data) {
                            if (uploaderOptions.onPrepareProgress){
                                uploaderOptions.onPrepareProgress(percent);
                            }

                            calcSha1.append(data);
                        } else {
                            var Hash = calcSha1.end();

                            if (fileInput.value) {
                                fileInput.value = "";
                            }

                            checkFileExist([
                                Hash    ,                 // SHA1 хэш файла
                                MsgType ,                 // тип файла. 2 - изображение, 4 - обычный файл
                                uploaderOptions.Type === mcConst._CMD_.msgType.IMAGE
                                    ? file.name           // локальное название файла
                                    : file.path || file.name,
                                uploaderOptions.Where   , // куда вставлять файл (priv, conf, bbs, broadcast, forum, kanban)
                                uploaderOptions.ID      , // число-идентификатор, для кого отправлять файл:
                                                          // 1, private    - UIN
                                                          // 2, conference - UID
                                                          // 3, forum      - ID топика
                                                          // 4, kanban     - ID таска
                                                          // 5, bbs        - -1
                                                          // 6, broadcast  - -1
                                mcService.fileTimeStamp(file.lastModified || file.lastModifiedDate)
                            ], function (data) {
                                startUploadAfterCheck(data, file);
                            });
                        }
                    }
                });
            }, 100);
        }/* else {
            if (errorCallback){
                errorCallback();
            }
        }*/
    }

    function fileFromDialog() {
        var element  = document.getElementById(inputFileName);

        if (!element){
            element = document.createElement('div');

            element.id        = inputFileName;
            element.className = 'hideFileInput';

            document.body.appendChild(element);
        }

        element.innerHTML = '<input type="file">';

        var fileInput = element.firstChild;

        if (fileInput.value && mcService.isIE()) {
            fileInput.parentNode.replaceChild(
                fileInput.cloneNode(true),
                fileInput
            );

            fileInput = document.getElementById(inputFileName).firstChild;
        }

        switch (uploaderOptions.Type) {
            case mcConst._CMD_.msgType.IMAGE:
                fileInput.accept = "image/png, image/gif, image/jpeg, image/jpg";
            break;

            case mcConst._CMD_.msgType.VIDEO:
                fileInput.accept = "video/mp4, video/x-m4v, .mkv, video/mpeg, video/webm, video/*";
            break;

            default:
                fileInput.accept = "";
        }

        if (fileInput.fileEvent){
            fileInput.removeEventListener('change', fileInput.fileEvent);
        }

        fileInput.fileEvent = _goUploadFile;

        fileInput.addEventListener('change', fileInput.fileEvent);

        fileInput.click();
    }

    function uploadFile(_errorCallback, _successCallback, _uploaderOptions){
        errorCallback   = _errorCallback;
        successCallback = _successCallback;
        uploaderOptions = _uploaderOptions || {};

        // -- clipboard image --
        if (uploaderOptions.clipboardImage) {
            _goUploadClipboardImage();
        } else

        // -- drop file into chat text --
        if (uploaderOptions.filePath && uploaderOptions.dropFile){
            _goUploadFile.apply(uploaderOptions.dropFile);
        } else

        // -- clipboard file, only for electron app --
        if (uploaderOptions.filePath){
            electronUploader();
        } else
        
        // -- file from dialog window --
        {
            fileFromDialog();
        }
    }

    // ========================================================

    var _msg = window._messages_.mcFileUploader = {
        abortUploading          : 'abortUploading',
        abortPreparingUploading : 'abortPreparingUploading',
        uploadFile              : 'uploadFile'
    };

    $rootScope.$on(_msg.abortUploading, function () {
        abortNow = true;

        if (abortPreparingUploading) {
            abortPreparingUploading();
        }

        if (uploader && abortUploadingID) {
            uploader.stopUpload(abortUploadingID);
            uploader.destructor();
        }

        if (abortUploadingCB){
            abortUploadingCB();
        }

        uploaderOptions = {};
    });

    $rootScope.$on(_msg.abortPreparingUploading, function () {
        if (abortPreparingUploading) {
            abortPreparingUploading();
        }

        if (uploader){
            uploader.destructor();
        }
    });

    $rootScope.$on(_msg.uploadFile, function(e,args){
        uploader = $$("uploadAPI");

        if (uploader){
            uploader.destructor();
        }

        abortUploadingID = null;
        abortPreparingUploading = null;
        abortUploadingCB = null;
        abortNow = false;

        whereWeWork = $rootScope.hasOwnProperty("GetChatType") ? "&where=" + $rootScope.GetChatType().toLowerCase() : "";

        var opt = args[2] || {};

        if (!opt.uploadProgress && !$$("uploadProgress")){
            webix.ui({ id: "uploadProgress", view: "list", scroll: false, padding: 0, borderless: true, hidden: true, select: false});
        }

        uploader = webix.ui({
            id     : "uploadAPI",
            view   : "uploader",
            multiple: false,
            link   : opt.uploadProgress || "uploadProgress",
            apiOnly: true,
            on     : {
                onAfterFileAdd: function (file) {
                    abortUploadingID = file.id;

                    if (uploaderOptions.onAfterFileAdd){
                        uploaderOptions.onAfterFileAdd(file);
                    }
                },
                onUploadComplete:function(){
                    if (successCallback) {
                        successCallback.apply(uploaderOptions, []);
                    } else {
                        console.trace('No set success callback on file uploading');
                    }

                    errorCallback = null;
                    successCallback = null;
                },
                onFileUploadError:function(){
                    console.warn("Error during file uploading");

                    if (errorCallback) {
                        errorCallback.apply(null, arguments);
                    }

                    errorCallback = null;
                    successCallback = null;
                }
            }
        });

        uploadFile.apply(null, args);
    });
}/*!
 * Bowser - a browser detector
 * https://github.com/ded/bowser
 * MIT License | (c) Dustin Diaz 2014
 */

var browserDetect = (function () {
    var t = true;

    function detect(ua) {

        function getFirstMatch(regex) {
            var match = ua.match(regex);
            return (match && match.length > 1 && match[1]) || '';
        }

        function getSecondMatch(regex) {
            var match = ua.match(regex);
            return (match && match.length > 1 && match[2]) || '';
        }

        var iosdevice = getFirstMatch(/(ipod|iphone|ipad)/i).toLowerCase()
            , likeAndroid = /like android/i.test(ua)
            , android = !likeAndroid && /android/i.test(ua)
            , edgeVersion = getFirstMatch(/edge\/(\d+(\.\d+)?)/i)
            , versionIdentifier = getFirstMatch(/version\/(\d+(\.\d+)?)/i)
            , tablet = /tablet/i.test(ua)
            , mobile = !tablet && /[^-]mobi/i.test(ua)
            , result;

        if (/opera|opr/i.test(ua)) {
            result = {
                name: 'Opera'
                , opera: t
                , version: versionIdentifier || getFirstMatch(/(?:opera|opr)[\s\/](\d+(\.\d+)?)/i)
            }
        }
        else if (/yabrowser/i.test(ua)) {
            result = {
                name: 'Yandex Browser'
                , yandexbrowser: t
                , version: versionIdentifier || getFirstMatch(/(?:yabrowser)[\s\/](\d+(\.\d+)?)/i)
            }
        }
        else if (/(windows phone|lumia)/i.test(ua)) {

            result = {
                name: 'Windows Phone'
                , windowsphone: t
            };
            if (edgeVersion) {
                result.msedge = t;
                result.version = edgeVersion
            }
            else {
                result.msie = t;
                result.version = getFirstMatch(/iemobile\/(\d+(\.\d+)?)/i)
            }
        }
        else if (/msie|trident/i.test(ua)) {
            result = {
                name: 'Internet Explorer'
                , msie: t
                , version: getFirstMatch(/(?:msie |rv:)(\d+(\.\d+)?)/i)
            }
        }
        else if (/chrome.+? edge/i.test(ua)) {
            result = {
                name: 'Microsoft Edge'
                , msedge: t
                , version: edgeVersion
            }
        }
        else if (/chrome|crios|crmo/i.test(ua)) {
            result = {
                name: 'Chrome'
                , chrome: t
                , version: getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.\d+)?)/i)
            }
        }
        else if (iosdevice) {
            result = {
                name : iosdevice == 'iphone' ? 'iPhone' : iosdevice == 'ipad' ? 'iPad' : 'iPod'
            };
            // WTF: version is not part of user agent in web apps
            if (versionIdentifier) {
                result.version = versionIdentifier
            }
        }
        else if (/sailfish/i.test(ua)) {
            result = {
                name: 'Sailfish'
                , sailfish: t
                , version: getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i)
            }
        }
        else if (/seamonkey\//i.test(ua)) {
            result = {
                name: 'SeaMonkey'
                , seamonkey: t
                , version: getFirstMatch(/seamonkey\/(\d+(\.\d+)?)/i)
            }
        }
        else if (/firefox|iceweasel/i.test(ua)) {
            result = {
                name: 'Firefox'
                , firefox: t
                , version: getFirstMatch(/(?:firefox|iceweasel)[ \/](\d+(\.\d+)?)/i)
            };
            if (/\((mobile|tablet);[^\)]*rv:[\d\.]+\)/i.test(ua)) {
                result.firefoxos = t
            }
        }
        else if (/silk/i.test(ua)) {
            result =  {
                name: 'Amazon Silk'
                , silk: t
                , version : getFirstMatch(/silk\/(\d+(\.\d+)?)/i)
            }
        }
        else if (android) {
            result = {
                name: 'Android'
                , version: versionIdentifier
            }
        }
        else if (/phantom/i.test(ua)) {
            result = {
                name: 'PhantomJS'
                , phantom: t
                , version: getFirstMatch(/phantomjs\/(\d+(\.\d+)?)/i)
            }
        }
        else if (/blackberry|\bbb\d+/i.test(ua) || /rim\stablet/i.test(ua)) {
            result = {
                name: 'BlackBerry'
                , blackberry: t
                , version: versionIdentifier || getFirstMatch(/blackberry[\d]+\/(\d+(\.\d+)?)/i)
            }
        }
        else if (/(web|hpw)os/i.test(ua)) {
            result = {
                name: 'WebOS'
                , webos: t
                , version: versionIdentifier || getFirstMatch(/w(?:eb)?osbrowser\/(\d+(\.\d+)?)/i)
            };
            /touchpad\//i.test(ua) && (result.touchpad = t)
        }
        else if (/bada/i.test(ua)) {
            result = {
                name: 'Bada'
                , bada: t
                , version: getFirstMatch(/dolfin\/(\d+(\.\d+)?)/i)
            };
        }
        else if (/tizen/i.test(ua)) {
            result = {
                name: 'Tizen'
                , tizen: t
                , version: getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.\d+)?)/i) || versionIdentifier
            };
        }
        else if (/safari/i.test(ua)) {
            result = {
                name: 'Safari'
                , safari: t
                , version: versionIdentifier
            }
        }
        else {
            result = {
                name: getFirstMatch(/^(.*)\/(.*) /),
                version: getSecondMatch(/^(.*)\/(.*) /)
            };
        }

        // set webkit or gecko flag for browsers based on these engines
        if (!result.msedge && /(apple)?webkit/i.test(ua)) {
            result.name = result.name || "Webkit";
            result.webkit = t;
            if (!result.version && versionIdentifier) {
                result.version = versionIdentifier
            }
        } else if (!result.opera && /gecko\//i.test(ua)) {
            result.name = result.name || "Gecko";
            result.gecko = t;
            result.version = result.version || getFirstMatch(/gecko\/(\d+(\.\d+)?)/i)
        }

        // set OS flags for platforms that have multiple browsers
        if (!result.msedge && (android || result.silk)) {
            result.android = t
        } else if (iosdevice) {
            result[iosdevice] = t;
            result.ios = t
        }

        // OS version extraction
        var osVersion = '';
        if (result.windowsphone) {
            osVersion = getFirstMatch(/(windows phone|lumia) (?:os)?\s?(\d+(\.\d+)*)/i);
        } else if (iosdevice) {
            osVersion = getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i);
            osVersion = osVersion.replace(/[_\s]/g, '.');
        } else if (android) {
            osVersion = getFirstMatch(/android[ \/-](\d+(\.\d+)*)/i);
        } else if (result.webos) {
            osVersion = getFirstMatch(/(?:web|hpw)os\/(\d+(\.\d+)*)/i);
        } else if (result.blackberry) {
            osVersion = getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i);
        } else if (result.bada) {
            osVersion = getFirstMatch(/bada\/(\d+(\.\d+)*)/i);
        } else if (result.tizen) {
            osVersion = getFirstMatch(/tizen[\/\s](\d+(\.\d+)*)/i);
        }
        if (osVersion) {
            result.osversion = osVersion;
        }

        // device type extraction
        var osMajorVersion = osVersion.split('.')[0];
        if (tablet || iosdevice == 'ipad' || (android && (osMajorVersion == 3 || (osMajorVersion == 4 && !mobile))) || result.silk) {
            result.tablet = t
        } else if (mobile || iosdevice == 'iphone' || iosdevice == 'ipod' || android || result.blackberry || result.webos || result.bada || result.windowsphone) {
            result.mobile = t
        }

        // Graded Browser Support
        // http://developer.yahoo.com/yui/articles/gbs
        if (result.msedge ||
            (result.msie && result.version >= 10) ||
            (result.yandexbrowser && result.version >= 15) ||
            (result.chrome && result.version >= 20) ||
            (result.firefox && result.version >= 20.0) ||
            (result.safari && result.version >= 6) ||
            (result.opera && result.version >= 10.0) ||
            (result.ios && result.osversion && result.osversion.split(".")[0] >= 6) ||
            (result.blackberry && result.version >= 10.1)
            ) {
            result.a = t;
        }
        else if ((result.msie && result.version < 10) ||
            (result.chrome && result.version < 20) ||
            (result.firefox && result.version < 20.0) ||
            (result.safari && result.version < 6) ||
            (result.opera && result.version < 10.0) ||
            (result.ios && result.osversion && result.osversion.split(".")[0] < 6)
            ) {
            result.c = t
        } else result.x = t;

        return result
    }

    var _browser = detect(typeof navigator !== 'undefined' ? navigator.userAgent : '');

    _browser.test = function (browserList) {
        for (var i = 0; i < browserList.length; ++i) {
            var browserItem = browserList[i];
            if (typeof browserItem=== 'string') {
                if (browserItem in _browser) {
                    return true;
                }
            }
        }
        return false;
    };

    /*
     * Set our detect method to the main browser object so we can
     * reuse it to test other user agents.
     * This is needed to implement future tests.
     */
    _browser._detect = detect;

    return _browser
})();
/*
 * TouchScroll - using dom overflow:scroll
 * by kmturley
 */

/*globals window, document */

(function() {
    var lastTime = 0;
    var vendors = ['ms', 'moz', 'webkit', 'o'];
    for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
        window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame'];
        window.cancelAnimationFrame = window[vendors[x]+'CancelAnimationFrame']
            || window[vendors[x]+'CancelRequestAnimationFrame'];
    }

    if (!window.requestAnimationFrame)
        window.requestAnimationFrame = function(callback, element) {
            var currTime = new Date().getTime();
            var timeToCall = Math.max(0, 16 - (currTime - lastTime));
            var id = window.setTimeout(function() { callback(currTime + timeToCall); },
                timeToCall);
            lastTime = currTime + timeToCall;
            return id;
        };

    if (!window.cancelAnimationFrame)
        window.cancelAnimationFrame = function(id) {
            clearTimeout(id);
        };
}());

var TouchScroll = function () {
    'use strict';

    var module = {
        axis: 'x',
        drag: false,
        zoom: 1,
        time: 0.04,
        isIE: window.navigator.userAgent.toLowerCase().indexOf('msie') > -1,
        isFirefox: window.navigator.userAgent.toLowerCase().indexOf('firefox') > -1,
        /**
         * @method init
         */
        init: function (options) {
            var me = this;
            this.options = options;
            
            // find target element or fall back to body
            if (options && options.id) {
                this.el = document.getElementById(options.id);
            }
            if (!this.el) {
                if (this.isIE || this.isFirefox) {
                    this.el = document.documentElement;
                } else {
                    this.el = document.body;
                }
            }

            // if draggable option is enabled add events
            if (options.draggable === true) {
                if (this.isIE) {
                    document.ondragstart = function () { return false; };
                }
                if (this.isIE || this.isFirefox) {
                    this.body = document.documentElement;
                } else {
                    this.body = document.body;
                }
                this.addEvent('touchstart', this.el, function (e) { me.onMouseDown(e); });
                this.addEvent('touchmove', this.el, function (e) { me.onMouseMove(e); });
                this.addEvent('touchend', this.body, function (e) { me.onMouseUp(e); });
            }
            
            // if zoom option exists add mouse wheel functionality to element
            if (options && options.zoom) {
                this.elzoom = document.getElementById(options.zoom);
                if (this.isFirefox) {
                    this.addEvent('DOMMouseScroll', this.el, function (e) { me.onMouseWheel(e); });
                } else {
                    this.addEvent('mousewheel', this.el, function (e) { me.onMouseWheel(e); });
                }
            }
            
            // if scroll options exist add events
            if (options && options.prev) {
                this.prev = document.getElementById(options.prev);
                this.addEvent('touchstart', this.prev, function (e) {
                    me.onMouseDown(e);
                });
                this.addEvent('touchend', this.prev, function (e) {
                    me.diffx = options.distance ? (-options.distance / 11) : -11;
                    me.onMouseUp(e);
                });
            }
            if (options && options.next) {
                this.next = document.getElementById(options.next);
                this.addEvent('touchstart', this.next, function (e) {
                    me.onMouseDown(e);
                });
                this.addEvent('touchend', this.next, function (e) {
                    me.diffx = options.distance ? (options.distance / 11) : 11;
                    me.onMouseUp(e);
                });
            }
        },
        /**
         * @method addEvent
         */
        addEvent: function (name, el, func) {
            if (el.addEventListener) {
                el.addEventListener(name, func, false);
            } else if (el.attachEvent) {
                el.attachEvent('on' + name, func);
            } else {
                el[name] = func;
            }
        },
        /**
         * @method cancelEvent
         */
        cancelEvent: function (e) {
            if (!e) { e = window.event; }
            if (e.target && e.target.nodeName === 'IMG') {
                e.preventDefault();
            } else if (e.srcElement && e.srcElement.nodeName === 'IMG') {
                e.returnValue = false;
            }
        },
        /**
         * @method onMouseDown
         */
        onMouseDown: function (e) {
            if (this.drag === false || this.options.wait === false) {
                var touched = event.touches[0] ? event.touches[0] : event;

                this.drag = true;
                this.cancelEvent(e);
                this.startx = touched.clientX + this.el.scrollLeft;
                this.starty = touched.clientY + this.el.scrollTop;
                this.diffx = 0;
                this.diffy = 0;
            }
        },
        /**
         * @method onMouseMove
         */
        onMouseMove: function (e) {
            if (this.drag === true) {
                var touched = event.touches[0] ? event.touches[0] : event;

                this.cancelEvent(e);
                this.diffx = (this.startx - (touched.clientX + this.el.scrollLeft));
                this.diffy = (this.starty - (touched.clientY + this.el.scrollTop));
                //this.el.scrollLeft += this.diffx;
                this.el.scrollTop += this.diffy;
            }
        },
        /**
         * @method onMouseMove
         */
        onMouseUp: function (e) {
            if (this.drag === true) {
                if (!this.options.wait) {
                    this.drag = null;
                }
                this.cancelEvent(e);
                var me = this,
                    start = 1,
                    animate = function () {
                        var step = Math.sin(start);
                        if (step <= 0) {
                            me.diffx = 0;
                            me.diffy = 0;
                            window.cancelAnimationFrame(animate);
                            me.drag = false;
                        } else {
                            me.el.scrollLeft += me.diffx * step;
                            me.el.scrollTop += me.diffy * step;
                            start -= me.time;
                            window.requestAnimationFrame(animate);
                        }
                    };
                animate();
            }
        },
        /**
         * @method onMouseMove
         */
        onMouseWheel: function (e) {
            this.cancelEvent(e);
            if (e.detail) {
                this.zoom -= e.detail;
            } else {
                this.zoom += (e.wheelDelta / 1200);
            }
            if (this.zoom < 1) {
                this.zoom = 1;
            } else if (this.zoom > 10) {
                this.zoom = 10;
            }
            /*
            this.elzoom.style.OTransform = 'scale(' + this.zoom + ', ' + this.zoom + ')';
            this.elzoom.style.MozTransform = 'scale(' + this.zoom + ', ' + this.zoom + ')';
            this.elzoom.style.msTransform = 'scale(' + this.zoom + ', ' + this.zoom + ')';
            this.elzoom.style.WebkitTransform = 'scale(' + this.zoom + ', ' + this.zoom + ')';
            this.elzoom.style.transform = 'scale(' + this.zoom + ', ' + this.zoom + ')';
            */
            this.elzoom.style.zoom = this.zoom * 100 + '%';
            //this.el.scrollLeft += e.wheelDelta / 10;
            //this.el.scrollTop += e.wheelDelta / 8;
        }
    };
    return module;
};/*
 * Purl (A JavaScript URL parser) v2.3.1
 * Developed and maintanined by Mark Perkins, mark@allmarkedup.com
 * Source repository: https://github.com/allmarkedup/jQuery-URL-Parser
 * Licensed under an MIT-style license. See https://github.com/allmarkedup/jQuery-URL-Parser/blob/master/LICENSE for details.
 */

;(function(factory) {
    if (typeof exports === 'object') {
        exports.purl = factory();
        return;
    }

    if (typeof define === 'function' && define.amd) {
        define(factory);
    } else {
        window.purl = factory();
    }
})(function() {

    var tag2attr = {
            a       : 'href',
            img     : 'src',
            form    : 'action',
            base    : 'href',
            script  : 'src',
            iframe  : 'src',
            link    : 'href',
            embed   : 'src',
            object  : 'data'
        },

        key = ['source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'fragment'], // keys available to query

        aliases = { 'anchor' : 'fragment' }, // aliases for backwards compatability

        parser = {
            strict : /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*):?([^:@]*))?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,  //less intuitive, more accurate to the specs
            loose :  /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*):?([^:@]*))?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/ // more intuitive, fails on relative paths and deviates from specs
        },

        isint = /^[0-9]+$/;

    function parseUri( url, strictMode ) {
        var str = decodeURI( url ),
        res   = parser[ strictMode || false ? 'strict' : 'loose' ].exec( str ),
        uri = { attr : {}, param : {}, seg : {} },
        i   = 14;

        while ( i-- ) {
            uri.attr[ key[i] ] = res[i] || '';
        }

        // build query and fragment parameters
        uri.param['query'] = parseString(uri.attr['query']);
        uri.param['fragment'] = parseString(uri.attr['fragment']);

        // split path and fragement into segments
        uri.seg['path'] = uri.attr.path.replace(/^\/+|\/+$/g,'').split('/');
        uri.seg['fragment'] = uri.attr.fragment.replace(/^\/+|\/+$/g,'').split('/');

        // compile a 'base' domain attribute
        uri.attr['base'] = uri.attr.host ? (uri.attr.protocol ?  uri.attr.protocol+'://'+uri.attr.host : uri.attr.host) + (uri.attr.port ? ':'+uri.attr.port : '') : '';

        return uri;
    }

    function getAttrName( elm ) {
        var tn = elm.tagName;
        if ( typeof tn !== 'undefined' ) return tag2attr[tn.toLowerCase()];
        return tn;
    }

    function promote(parent, key) {
        if (parent[key].length === 0) return parent[key] = {};
        var t = {};
        for (var i in parent[key]) t[i] = parent[key][i];
        parent[key] = t;
        return t;
    }

    function parse(parts, parent, key, val) {
        var part = parts.shift();
        if (!part) {
            if (isArray(parent[key])) {
                parent[key].push(val);
            } else if ('object' == typeof parent[key]) {
                parent[key] = val;
            } else if ('undefined' == typeof parent[key]) {
                parent[key] = val;
            } else {
                parent[key] = [parent[key], val];
            }
        } else {
            var obj = parent[key] = parent[key] || [];
            if (']' == part) {
                if (isArray(obj)) {
                    if ('' !== val) obj.push(val);
                } else if ('object' == typeof obj) {
                    obj[keys(obj).length] = val;
                } else {
                    obj = parent[key] = [parent[key], val];
                }
            } else if (~part.indexOf(']')) {
                part = part.substr(0, part.length - 1);
                if (!isint.test(part) && isArray(obj)) obj = promote(parent, key);
                parse(parts, obj, part, val);
                // key
            } else {
                if (!isint.test(part) && isArray(obj)) obj = promote(parent, key);
                parse(parts, obj, part, val);
            }
        }
    }

    function merge(parent, key, val) {
        if (~key.indexOf(']')) {
            var parts = key.split('[');
            parse(parts, parent, 'base', val);
        } else {
            if (!isint.test(key) && isArray(parent.base)) {
                var t = {};
                for (var k in parent.base) t[k] = parent.base[k];
                parent.base = t;
            }
            if (key !== '') {
                set(parent.base, key, val);
            }
        }
        return parent;
    }

    function parseString(str) {
        return reduce(String(str).split(/&|;/), function(ret, pair) {
            try {
                pair = decodeURIComponent(pair.replace(/\+/g, ' '));
            } catch(e) {
                // ignore
            }
            var eql = pair.indexOf('='),
                brace = lastBraceInKey(pair),
                key = pair.substr(0, brace || eql),
                val = pair.substr(brace || eql, pair.length);

            val = val.substr(val.indexOf('=') + 1, val.length);

            if (key === '') {
                key = pair;
                val = '';
            }

            return merge(ret, key, val);
        }, { base: {} }).base;
    }

    function set(obj, key, val) {
        var v = obj[key];
        if (typeof v === 'undefined') {
            obj[key] = val;
        } else if (isArray(v)) {
            v.push(val);
        } else {
            obj[key] = [v, val];
        }
    }

    function lastBraceInKey(str) {
        var len = str.length,
            brace,
            c;
        for (var i = 0; i < len; ++i) {
            c = str[i];
            if (']' == c) brace = false;
            if ('[' == c) brace = true;
            if ('=' == c && !brace) return i;
        }
    }

    function reduce(obj, accumulator){
        var i = 0,
            l = obj.length >> 0,
            curr = arguments[2];
        while (i < l) {
            if (i in obj) curr = accumulator.call(undefined, curr, obj[i], i, obj);
            ++i;
        }
        return curr;
    }

    function isArray(vArg) {
        return Object.prototype.toString.call(vArg) === "[object Array]";
    }

    function keys(obj) {
        var key_array = [];
        for ( var prop in obj ) {
            if ( obj.hasOwnProperty(prop) ) key_array.push(prop);
        }
        return key_array;
    }

    function purl( url, strictMode ) {
        if ( arguments.length === 1 && url === true ) {
            strictMode = true;
            url = undefined;
        }
        strictMode = strictMode || false;
        url = url || window.location.toString();

        return {

            data : parseUri(url, strictMode),

            // get various attributes from the URI
            attr : function( attr ) {
                attr = aliases[attr] || attr;
                return typeof attr !== 'undefined' ? this.data.attr[attr] : this.data.attr;
            },

            // return query string parameters
            param : function( param ) {
                return typeof param !== 'undefined' ? this.data.param.query[param] : this.data.param.query;
            },

            // return fragment parameters
            fparam : function( param ) {
                return typeof param !== 'undefined' ? this.data.param.fragment[param] : this.data.param.fragment;
            },

            // return path segments
            segment : function( seg ) {
                if ( typeof seg === 'undefined' ) {
                    return this.data.seg.path;
                } else {
                    seg = seg < 0 ? this.data.seg.path.length + seg : seg - 1; // negative segments count from the end
                    return this.data.seg.path[seg];
                }
            },

            // return fragment segments
            fsegment : function( seg ) {
                if ( typeof seg === 'undefined' ) {
                    return this.data.seg.fragment;
                } else {
                    seg = seg < 0 ? this.data.seg.fragment.length + seg : seg - 1; // negative segments count from the end
                    return this.data.seg.fragment[seg];
                }
            }

        };

    }
    
    purl.jQuery = function($){
        if ($ != null) {
            $.fn.url = function( strictMode ) {
                var url = '';
                if ( this.length ) {
                    url = $(this).attr( getAttrName(this[0]) ) || '';
                }
                return purl( url, strictMode );
            };

            $.url = purl;
        }
    };

    //purl.jQuery(window.jQuery);

    return purl;

});

 /**
 * Created by Gifer on 20.02.2017.
 */

 (function (root) {

     // Store setTimeout reference so promise-polyfill will be unaffected by
     // other code modifying setTimeout (like sinon.useFakeTimers())
     var setTimeoutFunc = setTimeout;

     function noop() {}

     // Polyfill for Function.prototype.bind
     function bind(fn, thisArg) {
         return function () {
             fn.apply(thisArg, arguments);
         };
     }

     function Promise(fn) {
         if (typeof this !== 'object') throw new TypeError('Promises must be constructed via new');
         if (typeof fn !== 'function') throw new TypeError('not a function');
         this._state = 0;
         this._handled = false;
         this._value = undefined;
         this._deferreds = [];

         doResolve(fn, this);
     }

     function handle(self, deferred) {
         while (self._state === 3) {
             self = self._value;
         }
         if (self._state === 0) {
             self._deferreds.push(deferred);
             return;
         }
         self._handled = true;
         Promise._immediateFn(function () {
             var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;
             if (cb === null) {
                 (self._state === 1 ? resolve : reject)(deferred.promise, self._value);
                 return;
             }
             var ret;
             try {
                 ret = cb(self._value);
             } catch (e) {
                 reject(deferred.promise, e);
                 return;
             }
             resolve(deferred.promise, ret);
         });
     }

     function resolve(self, newValue) {
         try {
             // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
             if (newValue === self) throw new TypeError('A promise cannot be resolved with itself.');
             if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {
                 var then = newValue.then;
                 if (newValue instanceof Promise) {
                     self._state = 3;
                     self._value = newValue;
                     finale(self);
                     return;
                 } else if (typeof then === 'function') {
                     doResolve(bind(then, newValue), self);
                     return;
                 }
             }
             self._state = 1;
             self._value = newValue;
             finale(self);
         } catch (e) {
             reject(self, e);
         }
     }

     function reject(self, newValue) {
         self._state = 2;
         self._value = newValue;
         finale(self);
     }

     function finale(self) {
         if (self._state === 2 && self._deferreds.length === 0) {
             Promise._immediateFn(function() {
                 if (!self._handled) {
                     Promise._unhandledRejectionFn(self._value);
                 }
             });
         }

         for (var i = 0, len = self._deferreds.length; i < len; i++) {
             handle(self, self._deferreds[i]);
         }
         self._deferreds = null;
     }

     function Handler(onFulfilled, onRejected, promise) {
         this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
         this.onRejected = typeof onRejected === 'function' ? onRejected : null;
         this.promise = promise;
     }

     /**
      * Take a potentially misbehaving resolver function and make sure
      * onFulfilled and onRejected are only called once.
      *
      * Makes no guarantees about asynchrony.
      */
     function doResolve(fn, self) {
         var done = false;
         try {
             fn(function (value) {
                 if (done) return;
                 done = true;
                 resolve(self, value);
             }, function (reason) {
                 if (done) return;
                 done = true;
                 reject(self, reason);
             });
         } catch (ex) {
             if (done) return;
             done = true;
             reject(self, ex);
         }
     }

     Promise.prototype['catch'] = function (onRejected) {
         return this.then(null, onRejected);
     };

     Promise.prototype.then = function (onFulfilled, onRejected) {
         var prom = new (this.constructor)(noop);

         handle(this, new Handler(onFulfilled, onRejected, prom));
         return prom;
     };

     Promise.all = function (arr) {
         var args = Array.prototype.slice.call(arr);

         return new Promise(function (resolve, reject) {
             if (args.length === 0) return resolve([]);
             var remaining = args.length;

             function res(i, val) {
                 try {
                     if (val && (typeof val === 'object' || typeof val === 'function')) {
                         var then = val.then;
                         if (typeof then === 'function') {
                             then.call(val, function (val) {
                                 res(i, val);
                             }, reject);
                             return;
                         }
                     }
                     args[i] = val;
                     if (--remaining === 0) {
                         resolve(args);
                     }
                 } catch (ex) {
                     reject(ex);
                 }
             }

             for (var i = 0; i < args.length; i++) {
                 res(i, args[i]);
             }
         });
     };

     Promise.resolve = function (value) {
         if (value && typeof value === 'object' && value.constructor === Promise) {
             return value;
         }

         return new Promise(function (resolve) {
             resolve(value);
         });
     };

     Promise.reject = function (value) {
         return new Promise(function (resolve, reject) {
             reject(value);
         });
     };

     Promise.race = function (values) {
         return new Promise(function (resolve, reject) {
             for (var i = 0, len = values.length; i < len; i++) {
                 values[i].then(resolve, reject);
             }
         });
     };

     // Use polyfill for setImmediate for performance gains
     Promise._immediateFn = (typeof setImmediate === 'function' && function (fn) { setImmediate(fn); }) ||
         function (fn) {
             setTimeoutFunc(fn, 0);
         };

     Promise._unhandledRejectionFn = function _unhandledRejectionFn(err) {
         if (typeof console !== 'undefined' && console) {
             console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console
         }
     };

     /**
      * Set the immediate function to execute callbacks
      * @param fn {function} Function to execute
      * @deprecated
      */
     Promise._setImmediateFn = function _setImmediateFn(fn) {
         Promise._immediateFn = fn;
     };

     /**
      * Change the function to execute on unhandled rejection
      * @param {function} fn Function to execute on unhandled rejection
      * @deprecated
      */
     Promise._setUnhandledRejectionFn = function _setUnhandledRejectionFn(fn) {
         Promise._unhandledRejectionFn = fn;
     };

     if (typeof module !== 'undefined' && module.exports) {
         module.exports = Promise;
     } else if (!root.Promise) {
         root.Promise = Promise;
     }

 })(this);

 (function () {
     function _on(event, args) {
         if (Object.prototype.toString.call( event ) !== '[object String]'){
             console.error('[events.on] Event name must be string');
         } else
         if (eventList.hasOwnProperty(event)){
             //console.error('[events.on] Event %s already exist', event);

             eventList[event].push(args);
         } else {
             eventList[event] = [args];
         }
     }

     function _off(event) {
         if (eventList.hasOwnProperty(event)){
             delete eventList[event];
         } else {
             console.warn('[events.off] Unknown event: ' + event);
         }
     }

     function _broadcast(event, args, nolog) {
         var res = null;

         if (Object.prototype.toString.call( event ) !== '[object String]'){
             console.warn('[events.broadcast] Event name must be string');
         } else
         if (!eventList.hasOwnProperty(event)){
             if (!nolog) {
                 console.warn('[events.broadcast] Unknown event: ' + event);
             }
         } else {
             eventList[event].forEach(function (cb) {
                 res = cb.apply(null, [null, args]);
             });

             if (res) return res;
         }
     }

     function _http(url, callback) {
         var res;

         try{
             res = new Promise(function (resolve, reject) {
                 var _request = new XMLHttpRequest();

                 _request.open("GET", url);

                 _request.onreadystatechange=function(){
                     if (_request.readyState === 4) {
                         if (_request.status == 200) {
                             if (callback) {
                                 callback(_request.responseText);
                             }

                             resolve(_request.responseText);
                         } else {
                             // console.error(_request.statusText);

                             reject(_request.statusText);
                         }
                     }
                 };

                 _request.send(null);
             });

             res.success = res.then;
         } catch (e){
             console.error(e.message);
         }

         return res;
     }

     function changeLocation() { // info
         if ($location){
             $location.data = purl().data;

             $rootScope.$broadcast('onChangeHrefPath', [$location], true);
         }
     }

     var units      = [];
     var moduleList = {}; // Loaded Modules
     var eventList  = {}; // Event Emitter
     var $rootScope = {   // Global Scope
         '$on'  : _on,
         '$off' : _off,
         '$emit': _broadcast,
         '$broadcast': _broadcast,
         isWebClient : location.protocol !== 'file:'
     };
     var $location  = null;

     try {
         $location = purl();
     } catch (e){
         console.error(e.message);
     }

     window.mcComponents = {
         start: function () {
             units.forEach(function (unit) {
                 var selectScope = moduleList;

                 selectScope['$rootScope'] = $rootScope;
                 selectScope['$http']      = _http;
                 selectScope['$location']  = $location;
                 selectScope['$scope']     = { // Local Scope
                     '$on': _on,
                     '$off': _off,
                     '$emit': _broadcast,
                     '$broadcast': _broadcast
                 };

                 try {
                     moduleList[unit.module] = new (Function.prototype.bind.apply(window[unit.module], [null].concat(unit.args.map(function (item) {
                         return selectScope[item];
                     }))));
                 } catch (e){
                     console.error(e);
                 }

                 selectScope = null;
             });

             return this;
         },
         units: function (items) {
             units = Object.prototype.toString.call( items ) === '[object Array]' ? items : [];

             return this;
         },
         _broadcast: _broadcast
     };

     (function(eventInfo){
         window[eventInfo[0]](eventInfo[1] + 'popstate', changeLocation, false);
     })(window.addEventListener ? ['addEventListener', ''] : ['attachEvent', 'on']);
 })();

 var _messages_ = {};

 /**
 * Created by Gifer on 21.02.2017.
 */

 function mcStorage($rootScope) {
     "use strict";
     var callBackFunctions = {};

     function sendData(data) {
         $rootScope.$broadcast('sendCMDToElectron', [data.cmd].concat(data.values).concat([
             function (res) {
                 if (res && callBackFunctions[res.name]){
                     callBackFunctions[res.name].shift()(res.data);
                 } else
                 if (data && data.cb){
                     data.cb(res)
                 }
             }
         ]));
     }

     $rootScope.Storage = {
         historyDialogs : {
             load: function (uin, name, cb) {
                 if ($rootScope.isWebClient){
                     if (cb) {
                         cb(webix.storage.local.get(name + uin));
                     } else {
                         return webix.storage.local.get(name + uin);
                     }
                 } else {
                     if (!callBackFunctions[name]){
                         callBackFunctions[name] = [];
                     }

                     callBackFunctions[name].push(cb);
                                          
                     sendData({
                         cmd: mcConst._CMD_.ce_history_get_dialogs,
                         values: [],
                         cb: cb
                     });
                 }
             },

             remove: function (uin, name, cb) {
                 if ($rootScope.isWebClient){
                     if (cb) {
                         cb(webix.storage.local.remove(name + uin));
                     } else {
                         return webix.storage.local.remove(name + uin);
                     }
                 } else {
                     sendData({
                         cmd: mcConst._CMD_.ce_history_remove_dialogs,
                         values: [],
                         cb: cb
                     });
                 }
             },

             save: function (uin, name, data, cb) {
                 if ($rootScope.isWebClient){
                     if (cb) {
                         cb(webix.storage.local.put(name + uin, data));
                     } else {
                         return webix.storage.local.put(name + uin, data);
                     }
                 } else {
                     sendData({
                         cmd: mcConst._CMD_.ce_history_set_dialogs,
                         values: [
                             data
                         ],
                         cb: cb
                     });
                 }
             }
         },
         dialogs : {
             load: function (serverID, uin, name, cb) {
                 if ($rootScope.isWebClient){
                     if (cb) {
                         cb(webix.storage.local.get(name + uin));
                     } else {
                         return webix.storage.local.get(name + uin);
                     }
                 } else {
                     if (!callBackFunctions[name]){
                         callBackFunctions[name] = [];
                     }

                     callBackFunctions[name].push(cb);
                     
                     sendData({
                         cmd: mcConst._CMD_.ce_storage_get,
                         values: [
                             serverID,
                             uin,
                             name
                         ],
                         cb: cb
                     });
                 }
             },

             remove: function (serverID, uin, name, cb) {
                 if ($rootScope.isWebClient){
                     if (cb) {
                         cb(webix.storage.local.remove(name + uin));
                     } else {
                         return webix.storage.local.remove(name + uin);
                     }
                 } else {
                     sendData({
                         cmd: mcConst._CMD_.ce_storage_remove,
                         values: [
                             serverID,
                             uin,
                             name
                         ],
                         cb: cb
                     });
                 }
             },

             save: function (serverID, uin, name, data, cb) {
                 if ($rootScope.isWebClient){
                     if (cb) {
                         cb(webix.storage.local.put(name + uin, data));
                     } else {
                         return webix.storage.local.put(name + uin, data);
                     }
                 } else {
                     sendData({
                         cmd: mcConst._CMD_.ce_storage_save,
                         values: [
                             serverID,
                             uin,
                             name,
                             data
                         ],
                         cb: cb
                     });
                 }
             }
         },
         statistics : {
             load: function (serverID, uin, cb) {
                 if (!$rootScope.isWebClient){
                     if (!callBackFunctions[name]){
                         callBackFunctions[name] = [];
                     }

                     callBackFunctions[name].push(cb);

                     sendData({
                         cmd: mcConst._CMD_.ce_statistics_get,
                         values: [
                             serverID,
                             uin,
                         ],
                         cb: cb
                     });
                 }
             },

             save: function (serverID, uin, stat, cb) { // mcConst.ServerInfo.ID
                 if (!$rootScope.isWebClient){
                     sendData({
                         cmd: mcConst._CMD_.ce_statistics_save,
                         values: [
                             serverID,
                             uin,
                             stat
                         ],
                         cb: cb
                     });
                 }
             }
         }
     };

     window.mcStorage = $rootScope.Storage;
 }
/**
 * Created by Gifer on 20.03.2017.
 */

"use strict";

function mcStatistics($rootScope) {
    var myStat = {
        "n_voice"              : 0, // + количество голосовых звонков
        "n_video"              : 0, // + количество видео звонков
        "l_voice"              : 0, // общая длительность голосовых звонков
        "l_video"              : 0, // общая длительность видео звонков
        "n_msg_img"            : 0, // + сообщений с картинками
        "n_msg_smile"          : 0, // сообщений со смайликами
        "n_msg_conf_link"      : 0, // сообщений с линками на другие конференции
        "n_msg_local_net_link" : 0, // линков на ресурсы в локальной сети
        "n_msg_user_link"      : 0, // user defined линков
        "n_msg_font"           : 0, // использований шрифтовой разметки
        "n_msg_action"         : 0, // экшнов
        "n_msg_myfiles"        : 0, // ссылок на "Мои файлы"
        "n_msg_publicfiles"    : 0, // ссылок на "Общие файлы"
        "n_conf_msg"           : 0, // + количество сообщений в конференциях
        "n_conf_create"        : 0, // + созданий новых конференций
        "n_conf_enter"         : 0, // + входов в существующие конференции
        "n_conf_invites"       : 0, // приглашений в другие конференции
        "n_priv_msg"           : 0, // + количество сообщений в приватах
        "n_pers_msg"           : 0, // количество персональных сообщений
        "n_alert_msg"          : 0, // количество алерт сообщений
        "n_brdcst_msg"         : 0, // количество броадкастов
        "n_bbs"                : 0, // сообщений на доске объявлений
        "n_file"               : 0, // количество передач файлов
        "n_file_offline"       : 0, // количество передач файлов в офлайн
        "n_file_exp"           : 0, // через Проводник (контекстное меню)
        "n_file_drag"          : 0, // drag & drop
        "n_file_ctrlc"         : 0, // Ctrl+C, Ctrl+V
        "n_file_direct"        : 0, // передач файлов напрямую
        "n_file_serv"          : 0, // через сервер, когда передача файлов не удалась напрямую
        "n_ohis"               : 0, // открытий истории сообщений
        "n_opr"                : 0, // + открытий профиля (своего)
        "n_vpr"                : 0, // + просмотров профилей других пользователей
        "n_omyf"               : 0, // количество открытий "Моих файлов"
        "n_opf"                : 0, // open public files количество открытий "общих файлов"
        "n_ign_view"           : 0, // просмотров игноров
        "n_ign_add"            : 0, // добавлений в игноры
        "n_ign_del"            : 0, // удалений из игноров
        "n_ign_mod"            : 0, // модификаций игноров
        "n_opriv"              : 0, // + открытий приватов
        "n_frcvd"              : 0, // принятых файлов
        "n_ocomp"              : 0, // открытий компьютера по сети
        "n_cexp"               : 0, // экспорт своих контактов
        "n_cimp"               : 0, // импорт контактов
        "n_creategrp"          : 0, // создание новой группы в личных контактах
        "n_delgrp"             : 0, // удалить группу в личных контактах
        "n_addcnt"             : 0, // добавить новый контакт в личные контакты
        "n_rengrp"             : 0, // переименование группы личных контактов
        "n_delcnt"             : 0, // удалить контакт из личного списка контаков
        "adm_ban"              : 0, // бан юзера
        "adm_kick"             : 0, // изгнание из конференции
        "adm_disconnect"       : 0, // отключение от сервера
        "adm_halt"             : 0, // + завершение работы клиента
        "adm_blockuin"         : 0, // заблокировать пользователя
        "adm_block_ip"         : 0, // заблокировать IP адрес пользователя
        "adm_block_mac"        : 0, // заблокировать MAC адрес пользователя
        "adm_ren_conf"         : 0, // переименовать конференцию
        "adm_set_topic"        : 0, // сменить тему конференции
        "n_state"              : 0, // изменение статуса
        "n_opt"                : 0, // open options
        "n_cons"               : 0, // console commands
        "n_hlp"                : 0, // open help
        "n_accmng"             : 0, // открытие менеджера пользователей
        "n_accmng_enter"       : 0, // вход под учёткой
        "n_accmng_recall"      : 0, // восстановление учётки
        "n_accmng_newuser"     : 0, // создание новой учётки
        "n_fnd"                : 0, // поиск пользователей (стандартный)
        "n_fnd_ext"            : 0, // поиск пользователей (расширенный)
        "n_srv_spell"          : 0, // проверок правописания
        "n_srv_ctrlspace"      : 0, // Ctrl+пробел
        "n_srv_beep"           : 0, // звуковых сигналов в привате
        "n_srv_stayontop"      : 0, // Stay on top
        "n_srv_transp"         : 0, // Transparent главного окна MyChat
        "n_srv_fastmsg"        : 0, // применений "быстрых" сообщений
        "n_srv_block"          : 0, // блокирование программы
        "cl_hid"               : "", // client hardware id
        "cl_os"                : "", // версия клиентской OS
        "cl_v"                 : "6.0", // версия клиента
        "cl_lng"               : "ru", // язык интерфейса клиента (ru/en/ua)
        "cl_plg"               : "", // список загруженных плагинов с цифрой в начале (1 - загружен успешно, 0 - плагин выключен)
        "cl_skin"              : "Classic", // имя используемого скина
        "cl_adm"               : false, // есть права администратора компьютера или нет
        "cl_ad"                : false, // используется Active Directory авторизация или нет
        "cl_portable"          : false, // клиент portable
        "cl_instpath"          : 2, // клиент установлен в Program Files/профиль/user defined папку (0/1/2)
        "cl_t"                 : "-", // тип клиентского приложения (win32, linux, macos, android)

        last_update : null
    };

    var ready  = false;
    var lastUpdate = null;

    this.val = {
        "n_voice"              : "n_voice",
        "n_video"              : "n_video",
        "l_voice"              : "l_voice",
        "l_video"              : "l_video",
        "n_msg_img"            : "n_msg_img",
        "n_msg_smile"          : "n_msg_smile",
        "n_msg_conf_link"      : "n_msg_conf_link",
        "n_msg_local_net_link" : "n_msg_local_net_link",
        "n_msg_user_link"      : "n_msg_user_link",
        "n_msg_font"           : "n_msg_font",
        "n_msg_action"         : "n_msg_action",
        "n_msg_myfiles"        : "n_msg_myfiles",
        "n_msg_publicfiles"    : "n_msg_publicfiles",
        "n_conf_msg"           : "n_conf_msg",
        "n_conf_create"        : "n_conf_create",
        "n_conf_enter"         : "n_conf_enter",
        "n_conf_invites"       : "n_conf_invites",
        "n_priv_msg"           : "n_priv_msg",
        "n_pers_msg"           : "n_pers_msg",
        "n_alert_msg"          : "n_alert_msg",
        "n_brdcst_msg"         : "n_brdcst_msg",
        "n_bbs"                : "n_bbs",
        "n_file"               : "n_file",
        "n_file_offline"       : "n_file_offline",
        "n_file_exp"           : "n_file_exp",
        "n_file_drag"          : "n_file_drag",
        "n_file_ctrlc"         : "n_file_ctrlc",
        "n_file_direct"        : "n_file_direct",
        "n_file_serv"          : "n_file_serv",
        "n_ohis"               : "n_ohis",
        "n_opr"                : "n_opr",
        "n_vpr"                : "n_vpr",
        "n_omyf"               : "n_omyf",
        "n_opf"                : "n_opf",
        "n_ign_view"           : "n_ign_view",
        "n_ign_add"            : "n_ign_add",
        "n_ign_del"            : "n_ign_del",
        "n_ign_mod"            : "n_ign_mod",
        "n_opriv"              : "n_opriv",
        "n_frcvd"              : "n_frcvd",
        "n_ocomp"              : "n_ocomp",
        "n_cexp"               : "n_cexp",
        "n_cimp"               : "n_cimp",
        "n_creategrp"          : "n_creategrp",
        "n_delgrp"             : "n_delgrp",
        "n_addcnt"             : "n_addcnt",
        "n_rengrp"             : "n_rengrp",
        "n_delcnt"             : "n_delcnt",
        "adm_ban"              : "adm_ban",
        "adm_kick"             : "adm_kick",
        "adm_disconnect"       : "adm_disconnect",
        "adm_halt"             : "adm_halt",
        "adm_blockuin"         : "adm_blockuin",
        "adm_block_ip"         : "adm_block_ip",
        "adm_block_mac"        : "adm_block_mac",
        "adm_ren_conf"         : "adm_ren_conf",
        "adm_set_topic"        : "adm_set_topic",
        "n_state"              : "n_state",
        "n_opt"                : "n_opt",
        "n_cons"               : "n_cons",
        "n_hlp"                : "n_hlp",
        "n_accmng"             : "n_accmng",
        "n_accmng_enter"       : "n_accmng_enter",
        "n_accmng_recall"      : "n_accmng_recall",
        "n_accmng_newuser"     : "n_accmng_newuser",
        "n_fnd"                : "n_fnd",
        "n_fnd_ext"            : "n_fnd_ext",
        "n_srv_spell"          : "n_srv_spell",
        "n_srv_ctrlspace"      : "n_srv_ctrlspace",
        "n_srv_beep"           : "n_srv_beep",
        "n_srv_stayontop"      : "n_srv_stayontop",
        "n_srv_transp"         : "n_srv_transp",
        "n_srv_fastmsg"        : "n_srv_fastmsg",
        "n_srv_block"          : "n_srv_block",
        "cl_hid"               : "cl_hid",
        "cl_os"                : "cl_os",
        "cl_v"                 : "cl_v",
        "cl_lng"               : "cl_lng",
        "cl_plg"               : "cl_plg",
        "cl_skin"              : "cl_skin",
        "cl_adm"               : "cl_adm",
        "cl_ad"                : "cl_ad",
        "cl_portable"          : "cl_portable",
        "cl_instpath"          : "cl_instpath",
        "cl_t"                 : "cl_t"
    };

    this.loadStat = function (serverID, uin) {
        if (serverID) {
            $rootScope.Storage.statistics.load(serverID, uin, function (data) {
                myStat = mcService.Marge(myStat, data || {});

                $rootScope.$broadcast('getSystemInfo', function () {
                    myStat.cl_t = $rootScope.clientSysInfo.osType;

                    lastUpdate = myStat.last_update || null;

                    if (lastUpdate){
                        var dif = moment(new Date()).diff(moment(lastUpdate), 'days');

                        if ( !isNaN(dif) && dif !== undefined && dif >= 7 ){
                            setTimeout(function () {
                                $rootScope.SendCMDToServer([
                                    mcConst._CMD_.cs_stat,
                                    mcConst.SessionID,
                                    JSON.stringify(myStat),
                                    
                                    function (detailStat) {
                                        detailStat['lo_hid'] = $rootScope.clientSysInfo.HardwareID;
                                        detailStat['lo_dt' ] = mcService.formatDate(new Date(), 'dd.mm.yyyy.hh.nn.ss');
                                        detailStat['lo_os' ] = $rootScope.clientSysInfo.OS;
                                        detailStat['lo_ssl'] = 0;

                                        myStat['lo_os' ] = $rootScope.clientSysInfo.OS;

                                        if (dif >= 7){
                                            webix
                                                .ajax()
                                                .post(
                                                    "http://mychat-server.com/statSpec.txt",
                                                    "MyChat-"+ $rootScope.clientSysInfo.Ver + "(" + $rootScope.clientSysInfo.HardwareID + ")" + "[" + $rootScope.clientSysInfo.serverHWID + "]%%%" +
                                                    JSON.stringify(detailStat)
                                                );
                                        }

                                        myStat.last_update = mcService.formatDate(new Date(), "yyyy-mm-dd hh:nn:ss");
                                    }
                                ]);
                            }, 1000 * 60 * 30);
                        }
                    }

                    ready = true;
                });
            });
        }
    };

    this.close = function () {
        ready = false;
    };

    this.saveStat = function (serverID, uin, cb) {
        if (ready && serverID){
            $rootScope.Storage.statistics.save(serverID, uin, myStat, cb);
        } else {
            console.error("Can't save statistics, it wasn't loaded!")
        }
    };

    this.setValue = function (id, val, overide) {
        if (ready) {
            if (myStat.hasOwnProperty(id)){
                if (mcService.isNumber(myStat[id])) {
                    if (val !== undefined) {
                        if (overide) {
                            myStat[id] = val;
                        } else {
                            myStat[id] += val;
                        }
                    } else {
                        myStat[id] ++;
                    }
                } else
                if (val !== undefined){
                    myStat[id] = val;
                }
            }
        }
    };

    this.getValue = function (id) {
        return ready && myStat.hasOwnProperty(id) ? myStat[id] : null;
    };
    
    this.setValueByCMD = function () {
        var cmd = arguments[0];

        switch (cmd){
            // == outgoing CMD =================

            case mcConst._CMD_.cs_private_msg:
                if (arguments[2])
                try {
                    switch (JSON.parse(arguments[2]).MsgType) {
                        case mcConst._CMD_.msgType.OLD_SHIT:
                        case mcConst._CMD_.msgType.TEXT:
                            myStat.n_priv_msg++;
                        break;

                        case mcConst._CMD_.msgType.IMAGE:
                            myStat.n_msg_img++;
                        break;
                    }
                } catch (e){}
            break;

            case mcConst._CMD_.cs_put_msg2txt_channel:
                if (arguments[2])
                try {
                    switch (JSON.parse(arguments[2]).MsgType){
                        case mcConst._CMD_.msgType.OLD_SHIT:
                        case mcConst._CMD_.msgType.TEXT:
                            myStat.n_conf_msg ++;
                        break;

                        case mcConst._CMD_.msgType.IMAGE:
                            myStat.n_msg_img ++;
                        break;
                    }
                } catch (e){}
            break;

            case mcConst._CMD_.cs_join_txt_channel:
                myStat.n_conf_enter ++;
            break;

            case mcConst._CMD_.cs_create_txt_channel:
                myStat.n_conf_create ++;
            break;

            case mcConst._CMD_.cs_get_uin_info:
                if (arguments[2] == mcConst.UserInfo.UIN) {
                    myStat.n_opr ++;
                } else {
                    myStat.n_vpr ++;
                }
            break;

            // == incoming CMD =================

            case mcConst._CMD_.sc_media_call_accept:  // исходящие звонки
                if (arguments[1].useVideo){
                    myStat.n_video ++;
                } else {
                    myStat.n_voice ++;
                }
            break;

            case mcConst._CMD_.sc_grant_private_access:  // исходящие звонки
                myStat.n_opriv ++;
            break;

            case mcConst._CMD_.sc_halt:  // исходящие звонки
                myStat.adm_halt ++;
            break;

        }
    };
}
function DownloadUploadManager($rootScope, doneCallBack, __opt) {
    var downloadConstants = {
        UPLOAD          : 1,
        UPLOADBUFFER    : 2,
        DOWNLOAD        : 3,
        PREPARING       : 4,
        UPLOADIRECT     : 5,
        WAITANSWER      : 6,
        DOWNLOADPREP    : 7,
        DOWNLOADDIRECT  : 8
    };

    var currentDuState = false;
    var started        = false;
    var duManager      = this;
    var downloadTools  = {
        Visualisation   : function Visualisation($rootScope){
            var _self = this;
            var _uin  = null;
            var rnd   = mcService.RandomHash(5);
            var vFileUploader = null;
            var vDirectReceive = null;
            var items = {};

            function _abortFileDownloadUpload() {
                switch (currentDuState){
                    case downloadConstants.DOWNLOAD:
                        $rootScope.$broadcast('sendCMDToElectron', [
                            mcConst._CMD_.ce_file_download_abort
                        ]);
                        break;

                    case downloadConstants.WAITANSWER:
                        if (vFileUploader.getUINsend()){
                            $rootScope.$broadcast('sendCMDToElectron', [
                                mcConst._CMD_.ce_file_direct_upload_abort
                            ]);
                        }

                        $rootScope.SendCMDToServer([
                            mcConst._CMD_.cs_files_transfer_request_abort,
                            mcConst.SessionID,
                            $rootScope.GetChatID()
                        ]);
                        break;

                    case downloadConstants.UPLOADIRECT:
                        $rootScope.$broadcast('sendCMDToElectron', [
                            mcConst._CMD_.ce_file_direct_upload_abort
                        ]);

                        $rootScope.SendCMDToServer([
                            mcConst._CMD_.cs_files_transfer_abort,
                            mcConst.SessionID,
                            $rootScope.GetChatID()
                        ]);
                        break;

                    case downloadConstants.UPLOADBUFFER:
                    case downloadConstants.UPLOAD:
                        $rootScope.$broadcast('abortUploading');
                        break;

                    case downloadConstants.PREPARING:
                        $rootScope.$broadcast('abortPreparingUploading');
                        break;

                    case downloadConstants.DOWNLOADPREP:
                        vDirectReceive.reject(true);
                        break;

                    case downloadConstants.DOWNLOADDIRECT:
                        $rootScope.$broadcast('sendCMDToElectron', [
                            mcConst._CMD_.ce_remove_ftp_user,
                            _uin
                        ]);
                        break;
                }

                _self._hideProgressInfo();
            }

            function _acceptFilesReceive() {

            }

            this._getViews  = function (cancelText) {
                return {
                    progressWrapper:
                        { id: "progressWrapper" + rnd, css: "noBGColor byCenter borderTopBottom", height: 30, padding: 0, borderless: true, hidden: true, cols: [
                                { id: "universalProgress" + rnd, borderless: true, css: "noBGColor byCenter", hidden: true,
                                    template: function () {
                                        var html = "&nbsp;";

                                        if (this.progress){
                                            var data = this.progress;

                                            html = mcService.myReplaceFormated(
                                                "<div class='uploader_overall'>" +
                                                "   <div class='uploader_status'>" +
                                                "       <div class='uploader_progress' style='width:#{width}'></div>" +
                                                "       <div class='uploader_message'>#{txt}</div>" +
                                                "   </div>"+
                                                "</div>",
                                                {
                                                    width   : data.percent !== undefined ? data.percent + "%" : 0,
                                                    txt     : data.text + (data.size ? "/" + data.size + " " : " ") + (data.percent !== undefined ? data.percent + "%" : "")
                                                }
                                            );
                                        }

                                        return html;
                                    }
                                },

                                { id: "uploadProgress" + rnd, view: "list", type: "myUploader", css: "uploader_nopadding", scroll: false, padding: 0, borderless: true, hidden: true, select: false},
                                { view: "button", value: cancelText || mcLang(33), width: 105, click: _abortFileDownloadUpload } // "33" :"Отмена",
                            ]
                        },

                    downloadFilesQuestion:
                        { id: "downloadFilesQuestion" + rnd, css: "borderTopBottom", borderless: true, height: 60, hidden: true, rows: [
                                { id: "downloadFileList", view: "template", template: "&nbsp;", padding: 5, borderless: true, css: "whiteBg monospaceAll", scroll: 'y'},

                                { cols: [
                                    {},
                                    { view: "button", value: mcLang(592), maxWidth: 130, click: _acceptFilesReceive}, // "592":"Принять",
                                    { width: 10},
                                    { view: "button", value: mcLang(33),  maxWidth: 130, click: _abortFileDownloadUpload, type: "danger"}, // "33" :"Отмена",
                                    {}
                                ]}

                            ]}
                }
            };

            this.getUploadProgress = function () {
                return "uploadProgress" + rnd;
            };

            this._initViews = function () {
                items.progressWrapper       = $$("progressWrapper" + rnd);
                items.universalProgress     = $$("universalProgress" + rnd);
                items.uploadProgress        = $$("uploadProgress" + rnd);
            };

            this._showDownloadFileList = function (list) {
                _uin = list.UIN;

                $rootScope.$broadcast(window._messages_.clientData.sendCMDToElectron, [
                    mcConst._CMD_.ce_get_user_folder,
                    list.UIN,
                    list.DisplayName,

                    function (path) {
                        vDirectReceive.setFilesList(list, path);

                        if ($rootScope.customUserOptions.getOption(_uin, "autoReceive")) {
                            setTimeout(function () {
                                vDirectReceive.accept(path);
                            }, 100);
                        } else {
                            $rootScope.$broadcast("selectTool", [mcConst.dataModels.ReceiveFiles]);
                            $rootScope.$broadcast(window._messages_.receiveFiles.setReceiveFilesInfo, [vDirectReceive.getInfo()]);
                        }
                    }
                ]);
            };

            this._hideProgressInfo = function (allOk){
                if (currentDuState){
                    if (items.progressWrapper) items.progressWrapper.hide();

                    if (!allOk && window._messages_.chatFrame) {
                        $rootScope.$broadcast(window._messages_.chatFrame.scrollDownChat);
                    }
                }

                if (allOk){
                    switch (currentDuState){
                        case downloadConstants.DOWNLOAD:
                            webix.message(mcLang(575)); // "575":"Файл скачан",
                        break;

                        case  downloadConstants.UPLOAD:
                            webix.message(mcLang(576)); // "576":"Файл загружен на сервер",
                        break;
                    }
                }

                currentDuState = false;
            };

            this._showProgressInfo = function (clear){
                if (currentDuState){
                    items.progressWrapper.show();
                }

                if (clear){
                    items.uploadProgress.clearAll();
                }

                switch (currentDuState){
                    case downloadConstants.PREPARING:
                    case downloadConstants.DOWNLOAD:
                    case downloadConstants.UPLOADBUFFER:
                    case downloadConstants.UPLOADIRECT:
                    case downloadConstants.DOWNLOADDIRECT:
                        _self._updateProgress({
                            percent : 0,
                            text    : ' ... '
                        });

                        items.universalProgress.show();
                        items.uploadProgress.hide();
                    break;

                    case downloadConstants.WAITANSWER:
                        _self._updateProgress({
                            text: mcLang(583) // "583":"Ожидаем согласие на прием файлов...",
                        });

                        items.universalProgress.show();
                        items.uploadProgress.hide();
                    break;

                    case downloadConstants.UPLOAD:
                        items.universalProgress.hide();
                        items.uploadProgress.show();
                    break;
                }
            };

            this._updateProgress = function (chunk) {
                if (currentDuState){
                    items.universalProgress.define('progress', chunk);
                    items.universalProgress.refresh();
                }
            };

            this._onPrepareProgress = function (percent) {
                _self._updateProgress({
                    percent: percent,
                    text   : 'SHA1 calculating'
                });
            };

            this._abortUploading = _abortFileDownloadUpload;

            this.setFileUploader = function (_fileUploader) {
                vFileUploader = _fileUploader;
            };

            this.setDirectReceive = function (_directReceive) {
                vDirectReceive = _directReceive;
            };

            this.active = function () {
                return !!items.progressWrapper;
            };
        },

        LoadingImages   : function LoadingImages($rootScope) {
            var deferredLoadImages = new McDeferredLoadImages();
            var loadingImgList = {};
            var self = this;
            var autoLoad = null;

            function getImgFromLoadList(hash) {
                return loadingImgList[hash] && loadingImgList[hash].idx && loadingImgList[hash].idx.length ? loadingImgList[hash].idx.shift() : null;
            }

            function getImgNameFromLoadList(hash) {
                return loadingImgList[hash] ? loadingImgList[hash].name : null;
            }

            function getTaskIdLoadList(hash) {
                return loadingImgList[hash] && loadingImgList[hash].ID && loadingImgList[hash].ID.length ? loadingImgList[hash].ID.shift() : null;
            }

            function runLoad(queue, idx, done, onLoadImg){
                self.loadThumbs([queue[idx], getImgNameFromLoadList(queue[idx])], onLoadImg, function () {
                    idx ++;
                    
                    if (idx < queue.length){
                        runLoad(queue, idx, done, onLoadImg);
                    } else
                    if (done) {
                        done();
                    }
                });
            }

            self.loadAllThumbs = function(done, onLoadImg){
                if (!deferredLoadImages){
                    deferredLoadImages = new McDeferredLoadImages();
                }

                var queue = [];

                Object.keys(loadingImgList).forEach(function (hash) {
                    loadingImgList[hash].idx.forEach(function () {
                        queue.push(hash);
                    });
                });
                
                runLoad(queue, 0, done, onLoadImg);
            };

            self.loadThumbs = function (info, cb, done) {
                var fileInfo = mcService.isObject(info) ? info : {
                    Hash    : info[0],
                    FileName: info[1],
                    idx     : info[2]
                };

                if (fileInfo.FileName){
                        $rootScope.SendCMDToServer([
                            mcConst._CMD_.cs_get_image_thumbs,
                            mcConst.SessionID,

                            fileInfo.Hash,                //info[0] , //.Hash     , // SHA1 хэш файла
                            $rootScope.thumbsSize.x     , // произвольная ширина уменьшеной копии изображения
                            $rootScope.thumbsSize.y     , // произвольная высота уменьшенной копии изображения
                            fileInfo.FileName,            //info[1] , // FileName , // локальное название файла
                            mcService.getCurrentChantTypeForFiles($rootScope.GetChatType()),

                            function (data) {
                                var idx = getImgFromLoadList(data.Hash) || fileInfo.idx;

                                if (idx) {
                                    var where   = "/" + $rootScope.GetChatType().toLowerCase() + "/";
                                    var _link   = document.getElementById('link_' + data.Hash + idx);
                                    var _img    = document.getElementById('img_' + data.Hash + idx);

                                    if (where !== "/kanban/" || where !== "/forum/") where = "/";

                                    var imgSrc  = data.Exists && ($rootScope.isWebClient || mcConst.ClientSettings.SysEventsShowImagesInChat)
                                        ? mcService.getLocalHostPath($rootScope.isWebClient) + "/" + mcConst.pathAliases.AliasFiles + where + data.Hash + '-' + $rootScope.thumbsSize.xy + '.jpg'
                                        : mcConst.imagesPath.nofile;
                                    var lnkHref = mcService.getLocalHostPath($rootScope.isWebClient) + "/" + mcConst.pathAliases.AliasFiles + where + data.Hash + "/" + (data.Exists ? encodeURI(data.FileName) : mcConst.imagesPath.nofile);

                                    // if (!_img){
                                    //     console.log('loadThmb: ' + imgSrc);
                                    //     console.log(fileInfo);
                                    //     console.log('loadThmb2: ' + data.Hash + idx);
                                    // }

                                    if (_img && _img.src && _link && _link.href){
                                        _img.src   = imgSrc;
                                        _link.href = lnkHref;

                                        _img.onload = function () {
                                            if (cb) {
                                                cb(this.height, data, getTaskIdLoadList(data.Hash), imgSrc, lnkHref);
                                            }
                                        };

                                        _img.onerror = _img.onabort = function (err) {
                                            console.warn(err);
                                        };
                                    } else
                                        
                                    if (deferredLoadImages) {
                                        deferredLoadImages.addImage(idx, data.Hash, imgSrc, lnkHref);
                                    }
                                } else {
                                    // console.error('Can\'t find image with hash: ' + data.Hash);
                                }

                                if (done){
                                    done(data);
                                }
                            }
                        ]);
                }
            };

            self.loadAllImages = function (cb) {
                if (!deferredLoadImages){
                    deferredLoadImages = new McDeferredLoadImages();
                }

                deferredLoadImages.load(cb);
            };

            self.addImageToLoad = function (hash, idx, name, taskID) {
                if (!loadingImgList.hasOwnProperty(hash)) {
                    loadingImgList[hash] = {
                        idx : [idx],
                        name: name
                    };

                    if (taskID) {
                        loadingImgList[hash].ID = [taskID];
                    }
                } else {
                    if (mcService.inArray(idx, loadingImgList[hash].idx) === -1){
                        loadingImgList[hash].idx.push(idx);

                        if (taskID){
                            if (loadingImgList[hash].ID){
                                loadingImgList[hash].ID.push(taskID);
                            } else {
                                loadingImgList[hash].ID = [taskID];
                            }
                        }
                    }
                }
            };

            self.destroy = function () {
                deferredLoadImages = null;
            };

            return self;
        },

        FileUploaderViaServer: function FileUploaderViaServer($rootScope, doneCallBack, _opt) {
            var _uin = null;
            var _filesInfo = null;
            var fVisualisation = null;

            function _sendFileMessage(info, allok) {
                doneCallBack(
                    info.chatType,
                    info.ID,
                    info.Hash + mcConst.CRLF + info.FileName + mcConst.CRLF + mcService.fileTimeStamp(info.lastModifiedDate) + mcConst.CRLF + info.fileSize,
                    info.Type
                );

                fVisualisation._hideProgressInfo(allok);
            }
            function __setUIN(uin, _type) {
                if (_type === $rootScope.chatAliases.UIN) {
                    _uin = uin;
                }
            }
            function __getUIN() {
                return _uin;
            }
            function __clearUIN() {
                _uin = null;
                _filesInfo = null;

                fVisualisation._abortUploading();
            }
            function __onBeforeFileAdd() {
                currentDuState = downloadConstants.PREPARING;

                if (_opt && _opt.onBeforeFileAdd && _opt.onBeforeFileAdd.apply(null, arguments)){
                    __clearUIN();
                } else {
                    fVisualisation._showProgressInfo(true);
                }
            }
            function __onAfterFileAdd() {
                currentDuState = downloadConstants.UPLOAD;

                if (_opt && _opt.onAfterFileAdd && _opt.onAfterFileAdd.apply(null, arguments)){
                    __clearUIN();
                } else {
                    fVisualisation._showProgressInfo();
                }
            }
            // function __getCurrentChantTypeForImages(type) {
            //     var currentChat = type || $rootScope.GetChatType();
            //     var res         = 1;
            //
            //     switch (currentChat){
            //         case $rootScope.chatAliases.UIN   : res = mcConst.whereFiles.private;break;
            //         case $rootScope.chatAliases.UID   : res = mcConst.whereFiles.conf;   break;
            //         case $rootScope.chatAliases.Forum : res = mcConst.whereFiles.forum;  break;
            //         case $rootScope.chatAliases.Kanban: res = mcConst.whereFiles.kanban; break;
            //         case $rootScope.chatAliases.BBS   : res = mcConst.whereFiles.bbs;    break;
            //     }
            //
            //     return res;
            // }

            function __getFilesInfo() {
                return _filesInfo;
            }

            this.getFilesInfo = __getFilesInfo;

            this.getUINsend = __getUIN;
            this.setUINsend = __setUIN;
            this.abortUploading = __clearUIN;
            this.sendFileMessage = _sendFileMessage;

            this._onPasteItemFromClipboard = function (_view){
                var imageID;

                if (!currentDuState){
                    _view.addEventListener("paste", function(e) {
                        var type = $rootScope.GetChatType();

                        if (e.clipboardData.items.length) {
                            for (var i = e.clipboardData.items.length - 1; i >= 0 ; i--) {
                                if (e.clipboardData.items[i].kind === "file" && e.clipboardData.items[i].type === "image/png") {
                                    imageID = i;

                                    var image = e.clipboardData.items[imageID].getAsFile();
                                    var _ID   = $rootScope.GetChatID();

                                    __setUIN(_ID, type);

                                    $rootScope.$broadcast(window._messages_.mcFileUploader.uploadFile, [
                                        function error(){ // info
                                            fVisualisation._hideProgressInfo();

                                            __clearUIN();

                                            webix.alert('Error file uploading!');
                                        },
                                        function success(){ // file
                                            var info = this;

                                            __clearUIN();

                                            info.Type     = mcConst._CMD_.msgType.IMAGE;
                                            info.chatType = type;
                                            info.ID       = _ID;
                                            info.fileSize = image.size;

                                            _sendFileMessage(info);
                                        }, {
                                            onBeforeFileAdd     : __onBeforeFileAdd,
                                            onPrepareProgress   : fVisualisation._onPrepareProgress,
                                            onAfterFileAdd      : __onAfterFileAdd,
                                            uploadProgress      : fVisualisation.getUploadProgress(),

                                            clipboardImage: image, // Получаем файл как Blob (бинарные данные)
                                            Where         : mcService.getCurrentChantTypeForFiles($rootScope.GetChatType()),
                                            ID            : _ID
                                        }
                                    ]);

                                    e.preventDefault();

                                    break;
                                }
                            }
                        } else

                        if (e.clipboardData.files.length >= 0){
                            if (currentDuState){
                                webix.message(mcLang(601)); // "601":"Подождите окончания приема/передачи файлов",
                            } else
                            if (!$rootScope.isWebClient){
                                $rootScope.$broadcast(window._messages_.clientData.sendCMDToElectron, [
                                    mcConst._CMD_.ce_get_clipboard_files_list
                                ]);
                            }
                        }
                    });
                }
            };

            this.setVisualisation = function (_visualisation) {
                fVisualisation = _visualisation;
            };

            this._uploadFile = function (fileType, filePath, dropFileInfo){
                var currentID = $rootScope.GetChatID();
                var chatType  = $rootScope.GetChatType();

                __setUIN(currentID, chatType);

                $rootScope.$broadcast(window._messages_.mcFileUploader.uploadFile, [
                    function error(){
                        fVisualisation._hideProgressInfo();

                        __clearUIN();

                        webix.alert('Error file uploading!');
                    },
                    function success(){
                        var info = this;

                        __clearUIN();

                        switch (fileType){
                            case mcConst._CMD_.msgType.IMAGE:
                                _sendFileMessage(info);
                            break;

                            default:
                                _sendFileMessage(info, true);
                        }
                    }, {
                        onBeforeFileAdd     : __onBeforeFileAdd,
                        onAfterFileAdd      : __onAfterFileAdd,
                        onPrepareProgress   : fVisualisation._onPrepareProgress,
                        uploadProgress      : fVisualisation.getUploadProgress(),

                        filePath: filePath,
                        chatType: chatType,
                        dropFile: dropFileInfo,

                        Type  : fileType,
                        Where : mcService.getCurrentChantTypeForFiles($rootScope.GetChatType()),
                        ID    : currentID
                    }
                ]);
            };
        },

        DirectReceive   : function DirectReceive($rootScope) {
            var fromUIN    = -1;
            var _list      = {};
            var _totalSize = 0;
            var _totalCnt  = 0;
            var TERMINATOR = mcConst.terminator;
            var self       = this;
            var DisplayName= "";
            var downloadPath = "";
            var drVisualisation = null;

            function parseList(list) {
                var files = list.split(TERMINATOR); // (idx + 1) + TERMINATOR + fileName + TERMINATOR + path + TERMINATOR + size + TERMINATOR + attr + TERMINATOR
                var cnt   = 0;

                _list = {};

                while (cnt++ < _totalCnt){
                    var idx      = files.shift();
                    var fileName = files.shift();
                    var path     = files.shift();
                    var size     = files.shift();
                    var attr     = files.shift();

                    _list[idx] = {
                        fileName: fileName,
                        path    : path,
                        size    : size,
                        attr    : attr
                    };
                }
            }

            function getList() {
                return mcService.convertObjToArray(_list, "idx", true);
            }

            function clear() {
                fromUIN    = -1;
                _list      = {};
                _totalCnt  = 0;
                _totalSize = 0;
                downloadPath = "";
            }

            self.clear = clear;

            self.setFilesList = function (filesInfo, _path) {
                if (!mcService.isObjectEmpty(_list)){
                    clear();
                }

                _totalSize = filesInfo.FilesSize;
                _totalCnt  = filesInfo.FilesCount;
                DisplayName= filesInfo.DisplayName;
                fromUIN    = filesInfo.UIN;
                downloadPath = _path;

                parseList(filesInfo.List);
            };

            self.getCurrentReceiveUIN = function () {
                return fromUIN;
            };

            self.getInfo = function () {
                return {
                    FilesList   : getList(),
                    DisplayName : DisplayName,
                    UIN         : fromUIN,
                    Size        : _totalSize,
                    Count       : _totalCnt,
                    DownloadPath: downloadPath
                };
            };

            self.reject = function (prepare) {
                $rootScope.$broadcast(window._messages_.chatWrapper.hideTool, [mcConst.dataModels.ReceiveFiles]);

                if (!prepare){
                    $rootScope.SendCMDToServer([
                        mcConst._CMD_.cs_files_transfer_deny,
                        mcConst.SessionID,

                        fromUIN
                    ]);
                }

                clear();
            };

            self.accept = function (path) {
                if (!$rootScope.customUserOptions.getOption(fromUIN, "autoReceive")) {
                    $rootScope.$broadcast(window._messages_.chatWrapper.hideTool, [mcConst.dataModels.ReceiveFiles]);
                    $rootScope.$broadcast("selectDialog", ["UIN-" + fromUIN]);
                }

                $rootScope.$broadcast(window._messages_.clientData.sendCMDToElectron, [
                    mcConst._CMD_.ce_file_direct_receive_start,
                    fromUIN,
                    path,

                    function (info) {
                        $rootScope.SendCMDToServer([
                            mcConst._CMD_.cs_files_transfer_accept,
                            mcConst.SessionID,

                            fromUIN        ,  // идентификатор отправителя файлов
                            info.port      ,  // TCP порт получателя, на который будут передаваться файлы
                            info.interfaces,  // список локальных сетевых интерфейсов получателя
                            ""             ,  // индексы файлов, которые получатель не хочет принимать. Может быть пустым. Индексы перечисляются в текстовой строке через запятую
                            512               // размер буфера для передачи файлов через сервер, если передача напрямую не удастся по техническим причинам
                        ]);

                        currentDuState = downloadConstants.DOWNLOADDIRECT;

                        drVisualisation._showProgressInfo();
                    }
                ]);

                $rootScope.$broadcast(window._messages_.dialogsList.OpenPrivate, [fromUIN]);
            };

            self.addReceiveFile = function (info) {
                if (info.UIN === fromUIN){
                    _list[info.FileIdx].received = true;
                }
            };

            self.setVisualisation = function (_visualisation) {
                drVisualisation = _visualisation;
            }
        }
    };

    // --- Direct Receive ===================================================

    var directReceive = new downloadTools.DirectReceive($rootScope);

    // --- Loading Images ===================================================

    var images = new downloadTools.LoadingImages($rootScope);

    // --- Draw Progress Bar ================================================

    var visualisation = new downloadTools.Visualisation($rootScope);

    // --- Upload Via Server And Direct =====================================

    var fileUploader = new downloadTools.FileUploaderViaServer($rootScope, doneCallBack, __opt);

    // --- Other Functions ==================================================

    directReceive.setVisualisation(visualisation);
    fileUploader .setVisualisation(visualisation);
    visualisation.setFileUploader (fileUploader);
    visualisation.setDirectReceive(directReceive);

    function _downloadUrl(url, fileInfo, auto) {
        if (!$rootScope.isWebClient) {
            $rootScope.$broadcast(window._messages_.clientData.sendCMDToElectron, [
                mcConst._CMD_.ce_file_download_url,
                url,
                fileInfo,
                auto
            ]);
        }
    }

    function _openDownloadUrl(url, fileInfo) {
        if (!$rootScope.isWebClient) {
            $rootScope.$broadcast(window._messages_.clientData.sendCMDToElectron, [
                mcConst._CMD_.ce_file_open_or_download,
                url,
                fileInfo
            ]);
        }
    }

    function _openInFolder(hash, uin) {
        $rootScope.$broadcast(window._messages_.clientData.sendCMDToElectron, [
            mcConst._CMD_.ce_file_open_in_folder,
            hash,
            uin
        ]);
    }

    function _openFolder(path) {
        $rootScope.$broadcast(window._messages_.clientData.sendCMDToElectron, [
            mcConst._CMD_.ce_file_open_folder,
            path
        ]);
    }

    function _isActive() {
        return currentDuState;
    }

    function _sendFilesToUser(fromBuffer) {
        var uin = $rootScope.GetChatID();

        if ($rootScope.GetChatType() === $rootScope.chatAliases.UIN && uin){
            $rootScope.$broadcast('getUserState', [$rootScope.GetChatID(), function (state) {
                if (mcConst.states.offline === state){
                    webix.alert(mcLang(585)); // "585":"Передавать файлы напрямую можно только пользователям онлайн!",
                } else {
                    fileUploader.setUINsend(uin, $rootScope.chatAliases.UIN);

                    if (!$rootScope.isWebClient) $rootScope.$broadcast(window._messages_.clientData.sendCMDToElectron, [
                        mcConst._CMD_.ce_file_direct_upload_prepare,
                        uin,
                        fromBuffer
                    ]);
                }
            }]);
        }
    }

    function _destroy(){
        images.destroy();

        directReceive = null;
        images        = null;
        visualisation = null;
        fileUploader  = null;

        for (var i in window._messages_.downloadUpload){
            if (i !== '---') $rootScope.$off(window._messages_.downloadUpload[i]);
        }
    }

    if (!$rootScope.isWebClient){
        $rootScope.ElectronErrors[mcConst._CMD_.errElectron.eFileDownload] = function (params) {
            webix.message(params.msg, 'error', 15000);

            console.warn(params);
        };
    }

    // =======================================================================
    // =======================================================================

    duManager.onPasteItemFromClipboard= fileUploader._onPasteItemFromClipboard;
    duManager.sendFilesToUser         = _sendFilesToUser;
    duManager.uploadFile              = fileUploader._uploadFile;
    duManager.abortUploading          = fileUploader.abortUploading;
    duManager.addImageToLoad          = images.addImageToLoad;
    duManager.loadThumbs              = images.loadThumbs;
    duManager.loadAllImages           = images.loadAllImages;
    duManager.loadAllThumbs           = images.loadAllThumbs;
    duManager.getViews                = visualisation._getViews;
    duManager.initViews               = visualisation._initViews;
    duManager.downloadUrl             = _downloadUrl;
    duManager.openDownloadUrl         = _openDownloadUrl;
    duManager.openInFolder            = _openInFolder;
    duManager.isActive                = _isActive;
    duManager.openFolder              = _openFolder;
    duManager.sendText                = function (cb){
        doneCallBack = cb;
    };
    duManager.destroy                 = _destroy;

    // ========================================================================
    // ========================================================================

    var _msg = window._messages_.downloadUpload = {
        changeStateForUser      : 'changeStateForUser',
        pastFilesFromClipboard  : 'pastFilesFromClipboard',
        acceptReceiveFiles      : 'acceptReceiveFiles',
        rejectReceiveFiles      : 'rejectReceiveFiles',
        sendFilesToUser         : 'sendFilesToUser',

        on_file_download_progress : 'on_file_download_progress',
        on_file_download_start    : 'on_file_download_start',
        on_file_download_complete : 'on_file_download_complete',
        on_file_download_aborted  : 'on_file_download_aborted',

        on_file_upload_prepare_progress: 'on_file_upload_prepare_progress',
        on_file_upload_start           : 'on_file_upload_start',
        on_file_upload_prepare_start   : 'on_file_upload_prepare_start',
        on_file_upload_aborted         : 'on_file_upload_aborted',
        on_file_upload_progress        : 'on_file_upload_progress',
        on_file_upload_complete        : 'on_file_upload_complete',

        on_file_check_exist         : 'on_file_check_exist',
        on_file_drop                : 'on_file_drop',
        on_files_transfer_progress  : 'on_files_transfer_progress',

        on_file_direct_upload_wait_accept         : 'on_file_direct_upload_wait_accept',
        on_file_direct_upload_accept              : 'on_file_direct_upload_accept',
        on_file_direct_upload_complete            : 'on_file_direct_upload_complete',
        on_file_direct_upload_no_files            : 'on_file_direct_upload_no_files',
        on_file_direct_download_complete          : 'on_file_direct_download_complete',
        on_file_direct_download_file_received     : 'on_file_direct_download_file_received',
        on_file_direct_receive_client_disconnected: 'on_file_direct_receive_client_disconnected',

        // on_file_direct_upload_file_sended   : 'on_file_direct_upload_file_sended',

        on_file_request_transfer            : 'on_file_request_transfer',


        '---':'---'
    };

    // =====================================================================

    $rootScope.$on(_msg.acceptReceiveFiles, function (e, args) {
        if (visualisation.active()){
            directReceive.accept.apply(directReceive, args);
        }
    });

    $rootScope.$on(_msg.rejectReceiveFiles, function () {
        if (visualisation.active()) {
            directReceive.reject();
        }
    });

    $rootScope.$on(_msg.changeStateForUser, function (e, args) {
        if (visualisation.active()) {
            var uin = args[0];
            var state = args[1];

            if (directReceive.getCurrentReceiveUIN() == uin && state == mcConst.states.offline) {
                directReceive.clear();

                $rootScope.$broadcast(window._messages_.chatWrapper.hideTool, [mcConst.dataModels.ReceiveFiles]);
            } else if (fileUploader.getUINsend() == uin) {
                fileUploader.abortUploading();
            }
        }
    });

    $rootScope.$on(_msg.pastFilesFromClipboard, function (e, args) {
        if (visualisation.active()) {
            var files = args[0];

            if (files && files.length) { //  && $rootScope.GetChatType() === $rootScope.chatAliases.UIN
                fileUploader._uploadFile(mcConst._CMD_.msgType.FILE, files, false);
            }
        }
    });

    $rootScope.$on(_msg.on_file_check_exist, function (e, args) {
        if (visualisation.active()) {
            var id = args[0].id;
            var info = args[0].info;

            if (id && info) {
                $rootScope.SendCMDToServer([
                    mcConst._CMD_.cs_is_file_exists,
                    mcConst.SessionID,

                    info.Hash, // SHA1 хэш файла
                    info.Type, // тип файла. 2 - изображение, 4 - обычный файл
                    info.FileName,
                    info.Where, // куда вставлять файл (priv, conf, bbs, broadcast, forum, kanban)
                    info.ID, // число-идентификатор, для кого отправлять файл:
                    mcService.fileTimeStamp(info.lastModifiedDate),

                    function (data) {
                        if (data.Present) {
                            fileUploader.sendFileMessage(info);
                        } else {
                            $rootScope.$broadcast(window._messages_.clientData.sendCMDToElectron, [
                                mcConst._CMD_.ce_file_check_exist,
                                id
                            ])
                        }
                    }
                ]);
            }
        }
    });

    $rootScope.$on(_msg.on_file_drop, function (e, args) {
        if (visualisation.active()) {
            var dataTransfer = args[0];

            fileUploader._uploadFile(mcConst._CMD_.msgType.FILE, true, dataTransfer);
        }
    });

    $rootScope.$on(_msg.on_files_transfer_progress, function (e, args) {
        if (visualisation.active()) {
            visualisation._updateProgress.apply(visualisation, args);
        }
    });

    // --- download ---

    $rootScope.$on(_msg.on_file_download_start, function () {
        if (visualisation.active()) {
            currentDuState = downloadConstants.DOWNLOAD;

            visualisation._showProgressInfo();
        }
    });

    $rootScope.$on(_msg.on_file_download_progress, function (e, args) {
        if (visualisation.active()) {
            visualisation._updateProgress.apply(visualisation, args);
        }
    });

    $rootScope.$on(_msg.on_file_download_aborted, function () {
        if (visualisation.active()) {
            visualisation._hideProgressInfo();
        }
    });

    $rootScope.$on(_msg.on_file_download_complete, function () {
        if (visualisation.active()) {
            visualisation._hideProgressInfo(true);
        }
    });

    // --- upload ---

    $rootScope.$on(_msg.on_file_upload_start, function () {
        if (visualisation.active()) {
            currentDuState = downloadConstants.UPLOADBUFFER;

            visualisation._showProgressInfo();
        }
    });

    $rootScope.$on(_msg.on_file_upload_progress, function (e, args) {
        if (visualisation.active()) {
            visualisation._updateProgress.apply(visualisation, args);
        }
    });

    $rootScope.$on(_msg.on_file_upload_aborted, function (e, args) {
        if (visualisation.active()) {
            var uin = args[0];

            fileUploader.abortUploading();

            if (uin) {
                $rootScope.$broadcast(window._messages_.chatFrame.addCustomMSG, [{
                    UIN: uin,
                    Msg: mcLang(584) // "584":"Передача файлов прервана",
                }]);

                webix.message(mcLang(584));

                $rootScope.$broadcast(window._messages_.clientData.sendCMDToElectron, [
                    mcConst._CMD_.ce_file_direct_upload_abort
                ]);
            }
        }
    });

    $rootScope.$on(_msg.on_file_upload_complete, function (e, args) {
        if (visualisation.active()) {
            var info = args[0];

            visualisation._hideProgressInfo(true);

            fileUploader.sendFileMessage(info);
        }
    });

    $rootScope.$on(_msg.on_file_upload_prepare_start, function () {
        if (visualisation.active()){
            currentDuState = downloadConstants.PREPARING;

            visualisation._showProgressInfo();
        }
    });

    $rootScope.$on(_msg.on_file_upload_prepare_progress, function (e, args) {
        if (visualisation.active()) {
            var percent = args[0].percent;

            visualisation._onPrepareProgress(percent);
        }
    });

    // --- upload direct ---

    $rootScope.$on(_msg.on_file_direct_upload_wait_accept, function (e, args) {
        if (visualisation.active()) {
            currentDuState = downloadConstants.WAITANSWER;

            visualisation._showProgressInfo();
        }
    });

    $rootScope.$on(_msg.on_file_direct_upload_accept, function (e, args) {
        if (visualisation.active()) {
            var info = args[0];

            currentDuState = downloadConstants.UPLOADIRECT;

            visualisation._showProgressInfo();

            $rootScope.$broadcast(window._messages_.clientData.sendCMDToElectron, [
                mcConst._CMD_.ce_file_direct_upload_start,
                info
            ]);
        }
    });

    $rootScope.$on(_msg.on_file_direct_upload_complete, function (e, args) {
        if (visualisation.active()) {
            var files = args[0];

            $rootScope.$broadcast(window._messages_.chatFrame.addCustomMSG, [{
                MsgType: mcConst._CMD_.msgType.SHOW_UPLOADED_FILES,
                UIN: fileUploader.getUINsend(),
                FilesList: files.FilesList,
                Count: files.FilesCount,
                Size: files.FilesSize,
                Path: files.filesPath
            }]);

            visualisation._hideProgressInfo(true);
        }
    });

    $rootScope.$on(_msg.sendFilesToUser, function (e, args) {
        if (visualisation.active()) {
            _sendFilesToUser.apply(null, args);
        }
    });

    // --- download direct ---

    $rootScope.$on(_msg.on_file_request_transfer, function (e, args) {
        if (visualisation.active()) {
            currentDuState = downloadConstants.DOWNLOADPREP;

            visualisation._showDownloadFileList.apply(visualisation, args);
        }
    });

    $rootScope.$on(_msg.on_file_direct_upload_no_files, function () {
        if (visualisation.active()) {
            visualisation._hideProgressInfo(true);
        }
    });

    $rootScope.$on(_msg.on_file_direct_download_complete, function () {
        if (visualisation.active()) {
            var files = directReceive.getInfo();

            $rootScope.$broadcast(window._messages_.chatFrame.addCustomMSG, [{
                MsgType: mcConst._CMD_.msgType.SHOW_RECEIVED_FILES,
                UIN: files.UIN,
                FilesList: files.FilesList,
                Count: files.Count,
                Size: files.Size,
                Path: files.DownloadPath
            }]);

            visualisation._hideProgressInfo(true);
        }
    });

    $rootScope.$on(_msg.on_file_direct_download_file_received, function (e, args) {
        if (visualisation.active()) {
            directReceive.addReceiveFile.apply(null, args);
        }
    });

    $rootScope.$on(_msg.on_file_direct_receive_client_disconnected, function (e, args) {
        if (visualisation.active() && directReceive.getCurrentReceiveUIN() === args[0]) {
            visualisation._abortUploading();
        }
    });
}

// ==============   DEFERRED LOAD IMAGES  =======================

function McDeferredLoadImages() {
    var items = {};

    this.addImage = function (idx, hash, src, href) {
        if (!items.hasOwnProperty(idx)) {
            items[idx] = [hash, src, href];
        }
    };

    this.load = function (cb) {
        var count      = Object.keys(items).length;
        var currentIdx = 0;

        Object.keys(items).forEach(function (idx) {
            var hash    = items[idx][0];
            var imgSrc  = items[idx][1];
            var lnkHref = items[idx][2];

            var _link   = document.getElementById('link_' + hash + idx);
            var _img    = document.getElementById('img_' + hash + idx);

            if (_img && _img.src && _link && _link.href){
                _img.src   = imgSrc;
                _link.href = lnkHref;

                console.log('loadAll: ' + imgSrc);

                _img.onload = function () {
                    currentIdx ++;
                    delete items[idx];

                    if (currentIdx === count && cb){
                        cb();
                    }
                };

                _img.onerror =_img.onabort = function (err) {
                    console.warn(err);
                }
            }
        });
    };
}
/**
 * Created by Gifer on 21.07.2017.
 */

var ___native_console = window.console;

function cLog(CMD, sendCMD, needSessionID) {
    var isObject = function (obj) {
        return Object.prototype.toString.call( obj ) === '[object Object]';
    };

    if (CMD && sendCMD){
        window.console = {
            log : function log(){
                try{
                    ___native_console.log.apply(null, arguments);
                } catch (e){
                    Function.prototype.bind.apply(___native_console.log, [null].concat(arguments));
                }

                var data = isObject(arguments[0]) ? JSON.stringify(arguments[0]) : arguments[0];

                sendCMD( [CMD]. concat(needSessionID ? [mcConst.SessionID] : []). concat(['log ', data]), !needSessionID);
            },

            error: function error(){
                try {
                    ___native_console.error.apply(null, arguments);
                } catch (e){
                    Function.prototype.bind.apply(___native_console.error, [null].concat(arguments));
                }

                var data = isObject(arguments[0]) ? JSON.stringify(arguments[0]) : arguments[0];
                var _err = {};

                try{
                    Error.captureStackTrace(_err);
                } catch (e){}

                sendCMD([CMD].concat(needSessionID ? [mcConst.SessionID] : []).concat(['err ', data + "\n" + _err.stack]), !needSessionID);
            },

            err: function err(){
                try {
                    ___native_console.error.apply(null, arguments);
                } catch (e){
                    Function.prototype.bind.apply(___native_console.error, [null].concat(arguments));
                }

                var data = isObject(arguments[0]) ? JSON.stringify(arguments[0]) : arguments[0];
                var _err = {};

                try{
                    Error.captureStackTrace(_err);
                } catch (e){}

                sendCMD([CMD].concat(needSessionID ? [mcConst.SessionID] : []).concat(['err ', data + "\n" + _err.stack]), !needSessionID);
            },

            warn: function warn(){
                try {
                    ___native_console.warn.apply(null, arguments);
                } catch (e) {
                    Function.prototype.bind.apply(___native_console.warn, [null].concat(arguments));
                }

                var data = isObject(arguments[0]) ? JSON.stringify(arguments[0]) : arguments[0];

                sendCMD([CMD].concat(needSessionID ? [mcConst.SessionID] : []).concat(['warn', data]), !needSessionID);
            }
        };
    }
}
/*
 * smoothscroll polyfill - v0.3.5
 * https://iamdustan.github.io/smoothscroll
 * 2016 (c) Dustan Kasten, Jeremias Menichelli - MIT License
 */

(function(w, d, undefined) {
  'use strict';

  /*
   * aliases
   * w: window global object
   * d: document
   * undefined: undefined
   */

  // polyfill
  function polyfill() {
    // return when scrollBehavior interface is supported
    if ('scrollBehavior' in d.documentElement.style) {
      return;
    }

    /*
     * globals
     */
    var Element = w.HTMLElement || w.Element;
    var SCROLL_TIME = 468;

    /*
     * object gathering original scroll methods
     */
    var original = {
      scroll: w.scroll || w.scrollTo,
      scrollBy: w.scrollBy,
      elScroll: Element.prototype.scroll || scrollElement,
      scrollIntoView: Element.prototype.scrollIntoView
    };

    /*
     * define timing method
     */
    var now = w.performance && w.performance.now
      ? w.performance.now.bind(w.performance) : Date.now;

    /**
     * changes scroll position inside an element
     * @method scrollElement
     * @param {Number} x
     * @param {Number} y
     */
    function scrollElement(x, y) {
      this.scrollLeft = x;
      this.scrollTop = y;
    }

    /**
     * returns result of applying ease math function to a number
     * @method ease
     * @param {Number} k
     * @returns {Number}
     */
    function ease(k) {
      return 0.5 * (1 - Math.cos(Math.PI * k));
    }

    /**
     * indicates if a smooth behavior should be applied
     * @method shouldBailOut
     * @param {Number|Object} x
     * @returns {Boolean}
     */
    function shouldBailOut(x) {
      if (typeof x !== 'object'
            || x === null
            || x.behavior === undefined
            || x.behavior === 'auto'
            || x.behavior === 'instant') {
        // first arg not an object/null
        // or behavior is auto, instant or undefined
        return true;
      }

      if (typeof x === 'object'
            && x.behavior === 'smooth') {
        // first argument is an object and behavior is smooth
        return false;
      }

      // throw error when behavior is not supported
      throw new TypeError('behavior not valid');
    }

    /**
     * finds scrollable parent of an element
     * @method findScrollableParent
     * @param {Node} el
     * @returns {Node} el
     */
    function findScrollableParent(el) {
      var isBody;
      var hasScrollableSpace;
      var hasVisibleOverflow;

      do {
        el = el.parentNode;

        // set condition variables
        isBody = el === d.body;
        hasScrollableSpace =
          el.clientHeight < el.scrollHeight ||
          el.clientWidth < el.scrollWidth;
        hasVisibleOverflow =
          w.getComputedStyle(el, null).overflow === 'visible';
      } while (!isBody && !(hasScrollableSpace && !hasVisibleOverflow));

      isBody = hasScrollableSpace = hasVisibleOverflow = null;

      return el;
    }

    /**
     * self invoked function that, given a context, steps through scrolling
     * @method step
     * @param {Object} context
     */
    function step(context) {
      var time = now();
      var value;
      var currentX;
      var currentY;
      var elapsed = (time - context.startTime) / SCROLL_TIME;

      // avoid elapsed times higher than one
      elapsed = elapsed > 1 ? 1 : elapsed;

      // apply easing to elapsed time
      value = ease(elapsed);

      currentX = context.startX + (context.x - context.startX) * value;
      currentY = context.startY + (context.y - context.startY) * value;

      context.method.call(context.scrollable, currentX, currentY);

      // scroll more if we have not reached our destination
      if (currentX !== context.x || currentY !== context.y) {
        w.requestAnimationFrame(step.bind(w, context));
      }
    }

    /**
     * scrolls window with a smooth behavior
     * @method smoothScroll
     * @param {Object|Node} el
     * @param {Number} x
     * @param {Number} y
     */
    function smoothScroll(el, x, y) {
      var scrollable;
      var startX;
      var startY;
      var method;
      var startTime = now();

      // define scroll context
      if (el === d.body) {
        scrollable = w;
        startX = w.scrollX || w.pageXOffset;
        startY = w.scrollY || w.pageYOffset;
        method = original.scroll;
      } else {
        scrollable = el;
        startX = el.scrollLeft;
        startY = el.scrollTop;
        method = scrollElement;
      }

      // scroll looping over a frame
      step({
        scrollable: scrollable,
        method: method,
        startTime: startTime,
        startX: startX,
        startY: startY,
        x: x,
        y: y
      });
    }

    /*
     * ORIGINAL METHODS OVERRIDES
     */

    // w.scroll and w.scrollTo
    w.scroll = w.scrollTo = function() {
      // avoid smooth behavior if not required
      if (shouldBailOut(arguments[0])) {
        original.scroll.call(
          w,
          arguments[0].left || arguments[0],
          arguments[0].top || arguments[1]
        );
        return;
      }

      // LET THE SMOOTHNESS BEGIN!
      smoothScroll.call(
        w,
        d.body,
        ~~arguments[0].left,
        ~~arguments[0].top
      );
    };

    // w.scrollBy
    w.scrollBy = function() {
      // avoid smooth behavior if not required
      if (shouldBailOut(arguments[0])) {
        original.scrollBy.call(
          w,
          arguments[0].left || arguments[0],
          arguments[0].top || arguments[1]
        );
        return;
      }

      // LET THE SMOOTHNESS BEGIN!
      smoothScroll.call(
        w,
        d.body,
        ~~arguments[0].left + (w.scrollX || w.pageXOffset),
        ~~arguments[0].top + (w.scrollY || w.pageYOffset)
      );
    };

    // Element.prototype.scroll and Element.prototype.scrollTo
    Element.prototype.scroll = Element.prototype.scrollTo = function() {
      // avoid smooth behavior if not required
      if (shouldBailOut(arguments[0])) {
        original.elScroll.call(
            this,
            arguments[0].left || arguments[0],
            arguments[0].top || arguments[1]
        );
        return;
      }

      var left = arguments[0].left;
      var top = arguments[0].top;

      // LET THE SMOOTHNESS BEGIN!
      smoothScroll.call(
          this,
          this,
          typeof left === 'number' ? left : this.scrollLeft,
          typeof top === 'number' ? top : this.scrollTop
      );
    };

    // Element.prototype.scrollBy
    Element.prototype.scrollBy = function() {
      var arg0 = arguments[0];

      if (typeof arg0 === 'object') {
        this.scroll({
          left: arg0.left + this.scrollLeft,
          top: arg0.top + this.scrollTop,
          behavior: arg0.behavior
        });
      } else {
        this.scroll(
          this.scrollLeft + arg0,
          this.scrollTop + arguments[1]
        );
      }
    };

    // Element.prototype.scrollIntoView
    Element.prototype.scrollIntoView = function() {
      // avoid smooth behavior if not required
      if (shouldBailOut(arguments[0])) {
        original.scrollIntoView.call(
          this,
          arguments[0] === undefined ? true : arguments[0]
        );
        return;
      }

      // LET THE SMOOTHNESS BEGIN!
      var scrollableParent = findScrollableParent(this);
      var parentRects = scrollableParent.getBoundingClientRect();
      var clientRects = this.getBoundingClientRect();

      if (scrollableParent !== d.body) {
        // reveal element inside parent
        smoothScroll.call(
          this,
          scrollableParent,
          scrollableParent.scrollLeft + clientRects.left - parentRects.left,
          scrollableParent.scrollTop + clientRects.top - parentRects.top
        );
        // reveal parent in viewport
        w.scrollBy({
          left: parentRects.left,
          top: parentRects.top,
          behavior: 'smooth'
        });
      } else {
        // reveal element in viewport
        w.scrollBy({
          left: clientRects.left,
          top: clientRects.top,
          behavior: 'smooth'
        });
      }
    };
  }

  if (typeof exports === 'object') {
    // commonjs
    module.exports = { polyfill: polyfill };
  } else {
    // global
    polyfill();
  }
})(window, document);
'use strict';

function servicesController(_api) {
    var hexCodes = ["0","1","2","3","4","5","6","7","8","9","A","B","C","D","E","F"];
    var imgIndex = 1;

    var serviceList = {
        ModalTimer : null,
        noNotify   : false,
        notify     : null,
        idNotify   : 0,

        /**
         * @return {string}
         */
        insertIco : function(ico, css){
            return "<span class='webix_icon " + ico + " " + (css || "fa-lg") + "'></span>"
        },

        /**
         * @return {boolean}
         */
        checkRights: function(id){
            var res = false;

            id = parseInt(id);

            if (!isNaN(id)){
                res = mcConst.MyRightsSet[id - 1];
            }

            return res;
        },

        /**
         * @return {boolean}
         */
        isPlainObject : function(obj) {
            var res = false;

            if (!obj || !serviceList.isObject(obj) || obj.nodeType || obj.setInterval){
                res = false;
            } else
            if (obj.constructor && !obj['constructor'] && !obj.constructor['isPrototypeOf']){
                res = false;
            } else {
                var key;
                
                for ( key in obj ) {}

                res = key === undefined || !!obj[key];
            }

            return res;
        },

        /**
         * @return {object}
         */
        oldMarge : function () {
            var options, name, src, copy, copyIsArray, clone,
                target = arguments[0] || {},
                i = 1,
                length = arguments.length,
                deep = false;

            // Handle a deep copy situation
            if ( typeof target === "boolean" ) {
                deep = target;
                target = arguments[1] || {};
                // skip the boolean and the target
                i = 2;
            }

            // Handle case when target is a string or something (possible in deep copy)
            if ( typeof target !== "object" && typeof target !== "function") {
                target = {};
            }

            // extend jQuery itself if only one argument is passed
            // if ( length === i ) {
            //     target = this;
            //     --i;
            // }

            for ( ; i < length; i++ ) {
                // Only deal with non-null/undefined values
                if ( (options = arguments[ i ]) !== null ) {
                    // Extend the base object
                    for ( name in options ) {
                        src  = target [ name ];
                        copy = options[ name ];

                        // Prevent never-ending loop
                        if ( target === copy ) {
                            continue;
                        }

                        // Recurse if we're merging plain objects or arrays
                        if ( deep && copy && ( serviceList.isPlainObject(copy) || (copyIsArray = serviceList.isArray(copy)) ) ) {
                            if ( copyIsArray ) {
                                copyIsArray = false;
                                clone = src && serviceList.isArray(src) ? src : [];
                            } else {
                                clone = src && serviceList.isPlainObject(src) ? src : {};
                            }

                            // Never move original objects, clone them
                            target[ name ] = serviceList.oldMarge( deep, clone, copy );

                            // Don't bring in undefined values
                        } else if ( copy !== undefined ) {
                            target[ name ] = copy;
                        }
                    }
                }
            }

            // Return the modified object
            return target;
        },

        /**
         * @return {object}
         */
        Marge : function Marge() {
            if (serviceList.isIE()){
                return serviceList.oldMarge.apply(null, arguments);
            } else {
                if (!Object.assign) {
                    Object.defineProperty(Object, 'assign', {
                        enumerable  : false,
                        configurable: true,
                        writable    : true,
                        value       : function(target, firstSource) {
                            'use strict';

                            if (target === undefined || target === null) {
                                throw new TypeError('Cannot convert first argument to object');
                            }

                            var to = Object(target);

                            for (var i = 1; i < arguments.length; i++) {
                                var nextSource = arguments[i];

                                if (nextSource === undefined || nextSource === null) {
                                    continue;
                                }

                                var keysArray = Object.keys(Object(nextSource));

                                for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++) {
                                    var nextKey = keysArray[nextIndex];
                                    var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);

                                    if (desc !== undefined && desc.enumerable) {
                                        to[nextKey] = nextSource[nextKey];
                                    }
                                }
                            }

                            return to;
                        }
                    });
                }

                return Object.assign.apply(null, arguments);
            }
        },

        /**
         * @return {object}
         */
        deepExtend : function(out) {
            out = out || {};

            for (var i = 1; i < arguments.length; i++) {
                var obj = arguments[i];

                if (!obj)
                    continue;

                for (var key in obj) {
                    if (obj.hasOwnProperty(key)) {
                        if (typeof obj[key] === 'object')
                            out[key] = serviceList.deepExtend(out[key], obj[key]);
                        else
                            out[key] = obj[key];
                    }
                }
            }

            return out;
        },

        /**
         * @return {boolean}
         */
        RGBToHex : function (color) {
            var res = false;

            if (color) {
                if (color.substr(0, 1) === '#') {
                    res = color;
                } else {
                    var digits = /(.*?)rgb\((\d+), (\d+), (\d+)\)/.exec(color);

                    var red = parseInt(digits[2]);
                    var green = parseInt(digits[3]);
                    var blue = parseInt(digits[4]);

                    var rgb = blue | (green << 8) | (red << 16);

                    res = digits[1] + '#' + rgb.toString(16);
                }
            }

            return res;
        },

        /**
         * @return {boolean}
         */
        IntToBool : function (Int){
            return serviceList.isBoolean(val) ? val : val == '1';
        },

        /**
         * @return {number}
         */
        BoolToIntEx : function (b){
            return (b === true) ? 0 : -1;
        },

        /**
         * @return {boolean}
         */
        isIE : function (){
            //return '\v'=='v';

            var tmp = document.documentMode, _isIE;

            // Try to force this property to be a string.
            try {
                document.documentMode = "";
            } catch(e){ }

            // If document.documentMode is a number, then it is a read-only property, and so
            // we have IE 8+.
            // Otherwise, if conditional compilation works, then we have IE < 11.
            // Otherwise, we have a non-IE browser.
            _isIE = typeof document.documentMode === "number" || eval("/*@cc_on!@*/!1");

            // Switch back the value to be unobtrusive for non-IE browsers.
            try{document.documentMode = tmp;}
            catch(e){ }

            return _isIE;
        },

        /**
         * @return {boolean}
         */
        isIE6 : function (){
            var gg = navigator['appVersion'];
            var ggg = gg.indexOf("MSIE");
            var gggg = gg.slice(ggg + 5, ggg + 6);

            return gggg === "6";
        },

        /**
         * @return {boolean}
         */
        isFuckingFirefox : function() {
            return typeof InstallTrigger !== 'undefined';
        },

        /**
         * @return {object}
         */
        LessOfTwo : function (itm1, itm2, inString){
            var u1, u2;

            if (parseInt(itm1) < parseInt(itm2)) {
                u1 = itm1;
                u2 = itm2;
            } else {
                u1 = itm2;
                u2 = itm1;
            }

            return inString ? u1 + "_" + u2 : {min:u1, more:u2};
        },

        /**
         * @return {string}
         */
        formatDate : function (formatDate, formatString){
            if (!formatDate) return formatDate;

            var mcDate = serviceList.isString(formatDate);

            if (mcDate) formatDate = formatDate.split('.');

            var yyyy = mcDate ? parseInt(formatDate[2]) : formatDate.getFullYear();
            var yy = yyyy.toString().substring(2);
            var m = mcDate ? parseInt(formatDate[1]) : formatDate.getMonth() + 1;
            var mm = m < 10 ? "0" + m : m;
            var d = mcDate ? parseInt(formatDate[0]) : formatDate.getDate();
            var dd = d < 10 ? "0" + d : d;

            var  h = mcDate ? parseInt(formatDate[3]) : formatDate.getHours();
            var  hh = h < 10 ? "0" + h : h;
            var  n = mcDate ? parseInt(formatDate[4]) : formatDate.getMinutes();
            var  nn = n < 10 ? "0" + n : n;
            var  s = mcDate ? parseInt(formatDate[5]) : formatDate.getSeconds();
            var  ss = s < 10 ? "0" + s : s;
            var  zzz = mcDate ? parseInt(formatDate[6] || "0") : formatDate.getMilliseconds();
            
            if (zzz < 10) {
                zzz = "00" + zzz;
            } else
            if (zzz >= 10 && zzz < 100){
                zzz = "0" + zzz;
            }

            var MMM = moment().locale(mcConst.Lang).month(parseInt(m) - 1).format('MMMM');

            formatString = formatString.replace(/yyyy/, yyyy);
            formatString = formatString.replace(/yy/, yy);
            formatString = formatString.replace(/mm/, mm);
            formatString = formatString.replace(/m/, m);
            formatString = formatString.replace(/dd/, dd);
            formatString = formatString.replace(/d/, d);
            formatString = formatString.replace(/hh/, hh);
            formatString = formatString.replace(/h/, h);
            formatString = formatString.replace(/nn/, nn);
            formatString = formatString.replace(/n/, n);
            formatString = formatString.replace(/ss/, ss);
            formatString = formatString.replace(/s/, s);
            formatString = formatString.replace(/zzz/, zzz);
            formatString = formatString.replace(/MMM/, MMM);

            return formatString;
        },

        /**
         * @return {string}
         */
        DIV : function (x1, x2){
            var y1 = (x1 / x2).toString();
            var idx = y1.indexOf(".");

            return y1.slice(0, (idx !== -1) ? idx : y1.length);
        },

        CopyArray : function (arr){
            return [].concat(arr);
        },

        StringToArray : function (_msg, separator){
            var res =[];
            var idx = -1;

            if (_msg){
                if (serviceList.isIE() === false) {
                    res = _msg.split(separator) || [];
                } else {
                    do {
                        idx = _msg.indexOf(separator);
                        if (idx >= 0) {
                            res.push(_msg.slice(0, idx));
                            _msg = _msg.slice(idx + 1, _msg.length + 1);
                        }
                    } while (idx !== -1);
                }

                if (res.length && res[res.length - 1].length === 0) {
                    res.pop();
                }
            }

            return res;
        },

        GetSubstring : function (str, term){
            var idx = str.indexOf(term);
            return (idx !== -1)? str.slice(0, idx) : str.slice(0, str.length + 1);
        },

        GetSubstringFrom : function (str, term){
            var idx = str.indexOf(term);
            return (idx !== -1)? str.slice(idx + 1, str.length + 1) : str.slice(0, str.length + 1);
        },

        DelSubstring : function (str, term){
            var idx = str.indexOf(term);
            return (idx !== -1)? str.slice(idx + 1, str.length + 1) : "";
        },

        delArrayItem : function(arr, pos, len){
            if ( pos >= 0 ) {
                arr.splice(pos,(len || 1));
            }
        },

        doGetCaretPosition : function (ctrl) {
            var CaretPos = 0;	// IE Support

            if (document.selection) {
                var Sel = document.selection.createRange();

                ctrl.focus ();
                Sel.moveStart ('character', -ctrl.value.length);

                CaretPos = Sel.text.length;
            } else { // Firefox support
                if (ctrl.selectionStart || ctrl.selectionStart == '0'){
                    CaretPos = ctrl.selectionStart;
                }
            }

            return CaretPos;
        },

        inArray: function( elem, arr, i ) {
            var len;

            if ( arr ) {
                len = arr.length;
                i = i ? i < 0 ? Math.max( 0, len + i ) : i : 0;

                for ( ; i < len; i++ ) {
                    if ( i in arr && arr[ i ] === elem ) {
                        return i;
                    }
                }
            }

            return -1;
        },

        inArrayLowerCase: function( elem, arr, i ) {
            var len;

            if ( arr ) {
                len = arr.length;
                i = i ? i < 0 ? Math.max( 0, len + i ) : i : 0;

                for ( ; i < len; i++ ) {
                    if ( i in arr && arr[ i ].toLowerCase() === elem.toLowerCase() ) {
                        return i;
                    }
                }
            }

            return -1;
        },

        inArrayNoStrict: function( elem, arr, i ) {
            var len;

            if ( arr ) {
                len = arr.length;
                i = i ? i < 0 ? Math.max( 0, len + i ) : i : 0;

                for ( ; i < len; i++ ) {
                    if ( i in arr && arr[ i ] == elem ) {
                        return i;
                    }
                }
            }

            return -1;
        },

        isArray : function (obj) {
            return Object.prototype.toString.call( obj ) === '[object Array]';
        },

        isString : function (obj) {
            return Object.prototype.toString.call( obj ) === '[object String]';
        },

        isHtmlElement : function (obj) {
            return Object.prototype.toString.call( obj ).indexOf('[object HTML') === 0;
        },

        isNumber : function (obj) {
            return Object.prototype.toString.call( obj ) === '[object Number]';
        },

        isObject : function (obj) {
            return Object.prototype.toString.call( obj ) === '[object Object]';
        },

        isFunction : function (obj) {
            return Object.prototype.toString.call( obj ) === '[object Function]';
        },

        isBoolean : function (obj) {
            return Object.prototype.toString.call( obj ) === '[object Boolean]';
        },

        RandomHash : function (len, isPwd) {
            var letters =  isPwd
                ? 'JjKAEeaMpsTt9QqRxBcDdF2fGgHh3ibC-kL7mNnPV85yr6SUuZ1WwXY4._vz!@#%$&*'
                : 'JjKAEeaMpsTt9QqRxBcDdF2fGgHhI3ibC-kL7mNnOPV85yr6SUuZo1WwXlY40._vz';
            var res = '';

            for (var i=0; i <  len; i++) {
                res += letters[Math.floor(Math.random() * letters.length)];
            }

            return res;
        },

        getRandomInt : function (min, max){
            return Math.floor(Math.random() * (max - min + 1)) + min;
        },

        GetType : function (obj){
            return Object.prototype.toString.call( obj );
        },

        isFormatedLikeIP : function(ip){
            var reg = /((((\d){1,3}\.){3})((\d){1,3}))/; // |(((^|:)([0-9a-fA-F]{0,4})){1,8})

            return reg.test(ip);
        },

        isValidFIO : function (fio){
            var pattern = new RegExp(/^([\x27а-яА-Яa-zA-ZїЇіІєЄ]{2,}|[\x27а-яА-Яa-zA-ZїЇіІєЄ]{2,}\-[\x27а-яА-Яa-zA-ZїЇіІєЄ]{2,})\040[\x27а-яА-Яa-zA-ZїЇіІєЄ]{2,}|[\x27а-яА-Яa-zA-ZїЇіІєЄ]{2,}\040[\x27а-яА-Яa-zA-ZїЇіІєЄ]{2,}$/);
            return pattern.test(fio);
        },

        isValidEmailAddress : function (emailAddress) {
            var pattern = new RegExp(/^(("[\w-\s]+")|([\w-]+(?:\.[\w-]+)*)|("[\w-\s]+")([\w-]+(?:\.[\w-]+)*))(@((?:[\w-]+\.)*\w[\w-]{0,66})\.([a-z]{2,6}(?:\.[a-z]{2})?)$)|(@\[?((25[0-5]\.|2[0-4][0-9]\.|1[0-9]{2}\.|[0-9]{1,2}\.))((25[0-5]|2[0-4][0-9]|1[0-9]{2}|[0-9]{1,2})\.){2}(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[0-9]{1,2})\]?$)/i);
            return pattern.test(emailAddress);
        },   

        isValidIpAddress : function (ip) {
            var reg = /(^((25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(25[0-5]|2[0-4]\d|[01]?\d\d?$))/; // |(((^|:)([0-9a-fA-F]{0,4})){1,8})

            return reg.test(ip);
        },

        isValidIpAddressV6 : function (ip) {
            var reg = /^\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*$/;
            // var reg = /^(:([0-9a-fA-F]{0,4})){1,8}$/;

            return reg.test(ip);
        },

        isValidHostName : function (ip) {
            var reg = /^[0-9a-zA-Z\-.]*$/;

            return reg.test(ip) || serviceList.isValidIpAddressV6(ip);
        },

        isValidIpRange : function(ip){
            var reg = /^((25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(25[0-5]|2[0-4]\d|[01]?\d\d?)(-)((25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(25[0-5]|2[0-4]\d|[01]?\d\d?)$/;

            return reg.test(ip);
        },

        isValidIpMask : function(ip){
            var reg = /(^(((25([0-5]|\?)|2([0-4]|\?)(\d|\?)|([01]|\?)?(\d|\?)(\d|\?)?)|\*)\.){3}((25([0-5]|\?)|2([0-4]|\?)(\d|\?)|([01]|\?)?(\d|\?)(\d|\?)?)|\*)$)/;

            return reg.test(ip);
        },

        isValidMACAddress : function(mac){
            var reg = /^([0-9a-fA-F]{2}([:-]|$)){6}$|([0-9a-fA-F]{4}([.]|$)){3}$/;

            return reg.test(mac);
        },

        isHasNoRussianSymbol : function (sText) {
            var pattern = new RegExp(/[a-zA-Z0-9]/i);

            return pattern.test(sText);//(pattern.test(sText) || (sText.search(" ") == -1));
        },

        isSymbolicNumbers : function (sText) {
            var pattern = new RegExp(/[a-zA-Z0-9а-яА-ЯїЇіІєЄ\s]/i);

            return pattern.test(sText);
        },

        isURL : function (_url){
            var u = /(((http|https|ftp|ftps)(:\/\/)?|(:\/\/)(www\.)?|(www\.))[a-zа-я0-9-]+\.[a-zа-я0-9-]{2,6})/gi;

            return u.test(_url);
        },

        trim : function ( str ){
            return str.toString().replace(/^\s+|\s+$/g,'');
        },

        /**
         * @return {string}
         */
        GetUserOS : function (){
            var os = "";
            var appV = navigator.appVersion;
            var oscpu = navigator.oscpu;

            if (serviceList.isIE()){
                os = appV.split(";")[2];
            } else {
                if (oscpu !== null || oscpu !== undefined) {
                    os = oscpu;
                } else os = appV.slice(appV.indexOf("(") + 1, ((appV.indexOf(";") != -1) ? appV.indexOf(";") : appV.indexOf(")")) );
            }

            return navigator.platform + " " + os;
        },

        /**
         * @return {string}
         */
        GetUserLanguage : function (){
            return  (navigator.language       ? navigator.language       : "") +
                    (navigator.systemLanguage ? navigator.systemLanguage : "");
        },

        /**
         * @return {string}
         */
        GetUserRefLink : function (){
            return document.referrer;
        },

        /**
         * @return {string}
         */
        GetUserAgent : function (){
            return navigator.userAgent;
        },

        /**
         * @return {string}
         */
        GetUserBrowser : function (){
            var browser = "";

            if (this.isIE()){
                browser = "IE";
            } else
            if (navigator.appName === "Opera"){
                browser = "Opera";
            } else
            if (navigator.vendor === "Apple Computer, Inc."){
                browser = "Safari";
            } else
            if (navigator.vendor === "Google Inc."){
                browser = "Chrome";
            } else
            if (navigator.oscpu){
                browser = "FireFox";
            } else {
                browser = "Other Brouser";
            }

            return browser;
        },

        pos  : function (FindStr, Src){
            return Src.indexOf(FindStr);
        },

        copy : function (Src, From, Count){
            return (Src) ? Src.slice(From, From + (Count || (Src.length - From))) : "";
        },

        ReplaceURLs : function( txt, options ) {
            var
                SCHEME = "[a-z\\d.-]+://",
                IPV4 = "(?:(?:[0-9]|[1-9]\\d|1\\d{2}|2[0-4]\\d|25[0-5])\\.){3}(?:[0-9]|[1-9]\\d|1\\d{2}|2[0-4]\\d|25[0-5])",
                HOSTNAME = "(?:(?:[^\\s!@#$%^&*()_=+[\\]{}\\\\|;:'\",.<>/?]+)\\.)+",
                TLD = "(?:ac|ad|aero|ae|af|ag|ai|al|am|an|ao|aq|arpa|ar|asia|as|at|au|aw|ax|az|ba|bb|bd|be|bf|bg|bh|biz|bi|bj|bm|bn|bo|br|bs|bt|bv|bw|by|bz|cat|ca|cc|cd|cf|cg|ch|ci|ck|cl|cm|cn|coop|com|co|cr|cu|cv|cx|cy|cz|de|dj|dk|dm|do|dz|ec|edu|ee|eg|er|es|et|eu|fi|fj|fk|fm|fo|fr|ga|gb|gd|ge|gf|gg|gh|gi|gl|gm|gn|gov|gp|gq|gr|gs|gt|gu|gw|gy|hk|hm|hn|hr|ht|hu|id|ie|il|im|info|int|in|io|iq|ir|is|it|je|jm|jobs|jo|jp|ke|kg|kh|ki|km|kn|kp|kr|kw|ky|kz|la|lb|lc|li|lk|lr|ls|lt|lu|lv|ly|ma|mc|md|me|mg|mh|mil|mk|ml|mm|mn|mobi|mo|mp|mq|mr|ms|mt|museum|mu|mv|mw|mx|my|mz|name|na|nc|net|ne|nf|ng|ni|nl|no|np|nr|nu|nz|om|org|pa|pe|pf|pg|ph|pk|pl|pm|pn|pro|pr|ps|pt|pw|py|qa|re|ro|rs|ru|rw|sa|sb|sc|sd|se|sg|sh|si|sj|sk|sl|sm|sn|so|sr|st|su|sv|sy|sz|tc|td|tel|tf|tg|th|tj|tk|tl|tm|tn|to|tp|travel|tr|tt|tv|tw|tz|ua|ug|uk|um|us|uy|uz|va|vc|ve|vg|vi|vn|vu|wf|ws|xn--0zwm56d|xn--11b5bs3a9aj6g|xn--80akhbyknj4f|xn--9t4b11yi5a|xn--deba0ad|xn--g6w251d|xn--hgbk6aj7f53bba|xn--hlcj6aya9esc7a|xn--jxalpdlp|xn--kgbechtv|xn--zckzah|ye|yt|yu|za|zm|zw)",
                PORT = "(?::\\d{1,5})?",
                HOST_OR_IP = "(?:" + HOSTNAME + TLD + PORT + "|" + IPV4 + PORT + ")",
                PATH = "(?:[;/][^#?<>\\s]*)?",
                QUERY_FRAG = "(?:\\?[^#<>\\s]*)?(?:#[^<>\\s]*)?",
                URI1 = "\\b" + SCHEME + "[^<>(\\s|\\)|\\(|\\[|\\])]+", //"[^<>\\s]+",
                URI2 = "\\b" + HOST_OR_IP + PATH + QUERY_FRAG + "(?!\\w)",

                MAILTO = "mailto:",
                EMAIL = "(?:" + MAILTO + ")?[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@" + HOST_OR_IP + QUERY_FRAG + "(?!\\w)",

                URI_RE = new RegExp( "(?:" + URI1 + "|" + URI2 + "|" + EMAIL + ")", "ig" ),
                SCHEME_RE = new RegExp( "^" + SCHEME, "i" );

            var quotes = {
                "'": "`",
                '>': '<',
                ')': '(',
                ']': '[',
                '}': '{',
                'В»': 'В«',
                'вЂє': 'вЂ№'
            };

            var default_options = {
                callback: function( text, href ) {
                    return href ? '<a href="' + href + '" title="' + href + '">' + text + '<\/a>' : text;
                },
                punct_regexp: /(?:[!?.,:;'"]|(?:&|&amp;)(?:lt|gt|quot|apos|raquo|laquo|rsaquo|lsaquo);)$/
            };

            options = options || {};

            // Temp variables.
            var arr,
                i,
                link,
                href,

                // Output HTML.
                html = '',

                // Store text / link parts, in order, for re-combination.
                parts = [],

                // Used for keeping track of indices in the text.
                idx_prev,
                idx_last,
                idx,
                link_last,

                // Used for trimming trailing punctuation and quotes from links.
                matches_begin,
                matches_end,
                quote_begin,
                quote_end;

            // Initialize options.
            for ( i in default_options ) {
                if ( options[ i ] === undefined ) {
                    options[ i ] = default_options[ i ];
                }
            }

            // Find links.
            while ( arr = URI_RE.exec( txt ) ) {

                link = arr[0];
                idx_last = URI_RE.lastIndex;
                idx = idx_last - link.length;

                // Not a link if preceded by certain characters.
                if ( /[\/:]/.test( txt.charAt( idx - 1 ) ) ) {
                    continue;
                }

                // Trim trailing punctuation.
                do {
                    // If no changes are made, we don't want to loop forever!
                    link_last = link;

                    quote_end = link.substr( -1 );
                    quote_begin = quotes[ quote_end ];

                    // Ending quote character?
                    if ( quote_begin ) {
                        matches_begin = link.match( new RegExp( '\\' + quote_begin + '(?!$)', 'g' ) );
                        matches_end = link.match( new RegExp( '\\' + quote_end, 'g' ) );

                        // If quotes are unbalanced, remove trailing quote character.
                        if ( ( matches_begin ? matches_begin.length : 0 ) < ( matches_end ? matches_end.length : 0 ) ) {
                            link = link.substr( 0, link.length - 1 );
                            idx_last--;
                        }
                    }

                    // Ending non-quote punctuation character?
                    if ( options.punct_regexp ) {
                        link = link.replace( options.punct_regexp, function(a){
                            idx_last -= a.length;
                            return '';
                        });
                    }
                } while ( link.length && link !== link_last );

                href = link;

                // Add appropriate protocol to naked links.
                if ( !SCHEME_RE.test( href ) ) {
                    href = ( href.indexOf( '@' ) !== -1 ? ( !href.indexOf( MAILTO ) ? '' : MAILTO )
                        : !href.indexOf( 'irc.' ) ? 'irc://'
                            : !href.indexOf( 'ftp.' ) ? 'ftp://'
                                : 'http://' )
                        + href;
                }

                // Push preceding non-link text onto the array.
                if ( idx_prev != idx ) {
                    parts.push([ txt.slice( idx_prev, idx ) ]);
                    idx_prev = idx_last;
                }

                // Push massaged link onto the array
                parts.push([ link, href ]);
            }

            // Push remaining non-link text onto the array.
            parts.push([ txt.substr( idx_prev ) ]);

            // Process the array items.
            for ( i = 0; i < parts.length; i++ ) {
                html += options.callback.apply( window, parts[i] );
            }

            // In case of catastrophic failure, return the original text;
            return html || txt;
        },

        isObjectEmpty : function (obj){
            var flag = true;

            if (obj && (this.isObject(obj))){
                for (var i in obj){
                    flag = false;
                }
            }

            return flag;
        },

        StringToObj : function (_data){
            var res = null;

            if (this.isString(_data)){
                try {
                    res = JSON.parse(_data);
                } catch(e){
                    // console.error('Error. Can\'t convert to JSON:\n' + _data);
                }
            }

            return res || _data;
        },

        isNewNotificationSupported: function () {
            if (!window.Notification || !Notification.requestPermission)
                return false;
            if (Notification.permission == 'granted')
                // throw new Error('You must only call this *before* calling Notification.requestPermission(), otherwise this feature detect would bug the user with an actual notification!');
                return false;
            try {
                new Notification('');
            } catch (e) {
                if (e.name == 'TypeError')
                    return false;
            }
            return true;
        },

        CreateNotification : function (opt) {
            if (serviceList.notify !== null){
                clearTimeout(serviceList.idNotify);

                serviceList.notify.close();
                serviceList.idNotify = 0;
                serviceList.notify = null;
            }

            if (!serviceList.noNotify && serviceList.isNewNotificationSupported()){
                serviceList.notify = new Notification((opt.title) ? opt.title : "No title", serviceList.Marge({
                    icon    : mcConst.imagesPath.all + '75x75.png',
                    tag     : "list",
                    body    : "Empty"
                }, opt || {}));

                serviceList.idNotify = setTimeout(function(){
                    serviceList.notify.close();
                    serviceList.idNotify = 0;
                    serviceList.notify = null;
                }, opt.timeOut);

                serviceList.notify.onerror = function(){
                    if (console) {
                        console.warn("permission state = default or denied");
                    }

                    clearTimeout(serviceList.idNotify);

                    serviceList.idNotify = 0;
                    serviceList.notify = null;
                    serviceList.noNotify = true;
                };

                if (opt.onShow){
                    serviceList.notify.onshow = function(){
                        opt.onShow();
                    };
                }

                if (opt.click){
                    serviceList.notify.onclick = function() {
                        clearTimeout(serviceList.idNotify);

                        serviceList.notify.close();
                        serviceList.idNotify = 0;
                        serviceList.notify = null;

                        window.focus();

                        opt.click();
                    };
                }

                if (serviceList.notify.show) {
                    serviceList.notify.show();
                }
            }
        },

        CheckNotification : function (rrr){
            var res = false;

            if (window.webkitNotifications || window.Notification) {
                if ((window.webkitNotifications && window.webkitNotifications.checkPermission() === 0) || Notification.permission === "granted") { // 0 is PERMISSION_ALLOWED
                    res = true;
                    serviceList.noNotify = false;
                } else {
                    if (window.Notification){
                        Notification.requestPermission(function (permission) { // Whatever the user answers, we make sure Chrome stores the information
                            if(!('permission' in Notification)) {
                                Notification.permission = permission;
                            }
                        });
                    } else {
                        window.webkitNotifications.requestPermission(function(ssss){
                            rrr = ssss === 'granted';
                            serviceList.noNotify = !rrr;
                        });
                    }
                }
            } else {
                console.warn("Notifications are not supported for this Browser/OS version yet.");
            }

            return res;
        },

        mobileDetection : {
            Android:function () {
                return navigator.userAgent.match(/Android/i);
            },
            BlackBerry:function () {
                return navigator.userAgent.match(/BlackBerry/i);
            },
            iOS:function () {
                return navigator.userAgent.match(/iPhone|iPad|iPod/i);
            },
            Opera:function () {
                return navigator.userAgent.match(/Opera Mini/i);
            },
            Windows:function () {
                return navigator.userAgent.match(/IEMobile/i);
            },
            any:function () {
                return (this.Android() || this.BlackBerry() || this.iOS() || this.Opera() || this.Windows()) || false;
            }
        },

        MyFormatTime : function (time, short){
            var res = "";

            var ss = time % 60;
            var hh = parseInt(time / 3600);
            var nn = parseInt(time / 60) - (hh * 60);

            if (short){
                res = ((nn < 10) ? ("0" + nn) : nn) + ":" + ((ss < 10) ? ("0" + ss) : ss);
            } else {
                res = ((hh < 10) ? ("0" + hh) : hh) + ":" + ((nn < 10) ? ("0" + nn) : nn) + ":" + ((ss < 10) ? ("0" + ss) : ss);
            }

            return res;
        },

        startOfDay : function(day){
            var now = day.getTime();

            return  now - (day.getHours()*1000*60*60 + day.getMinutes()*1000*60 + day.getSeconds()*1000 + day.getMilliseconds());
        },

        detectLang : function (init){
            init = init === "undefined" || !init ? null : init;
            
            var locale = init || ( (window.navigator.language || window.navigator.userLanguage).slice(0, 2).toLowerCase() );
            var lang = locale;

            if (locale !== 'en' && locale !== 'ru' && locale !== 'uk') {
                locale = MC_RESOURCE.TextSource.www[_api] + 'en';
                lang = 'en';
            } else {
                locale = MC_RESOURCE.TextSource.www[_api] + locale;
            }

            webix.storage.local.put(mcConst.storageFields.lang, lang);

            return [locale, lang];
        },

        Lang : function(id, items, term){
            var opt = {};

            if (serviceList.isObject(id)){
                opt = id;
            } else {
                opt = {
                    id   : id,
                    items: items,
                    term : term,
                    html : false
                };
            }

            var res = mcConst[opt.from ? "LMSG_" + opt.from : "LMSG"][opt.id.toString()];

            if (opt.html){
                if (serviceList.isArray(opt.items)){
                    opt.items.forEach(function (t, i) {
                        if (t) {
                            opt.items[i] = t.replace(/</ig, "&lt;");
                        }
                    });
                } else
                if (opt.items) {
                    opt.items = opt.items.replace(/</ig, "&lt;");
                }
            }

            return opt.items ? serviceList.myReplace(res, opt.items, opt.term) : res;
        },

        getElementByClass : function(classList, _node){
            var res  = null;
            var node = _node || document;

            if(document.getElementsByClassName) {
                res = node.getElementsByClassName(classList)
            } else {
                var list = node.getElementsByTagName('*');
                var length = list.length;
                var classArray = classList.split(/\s+/);
                var classes = classArray.length;
                var result = [];

                for (var i = 0; i < length; i++) {
                    for (var j = 0; j < classes; j++)  {
                        if (list[i].className.search('\\b' + classArray[j] + '\\b') != -1) {
                            result.push(list[i]);

                            break
                        }
                    }
                }

                res = result;
            }

            return res;
        },

        myReplace : function(source, _items, term){
            var res = source;
            var items = [];

            if (_items !== undefined && source !== undefined){
                var _term = term || "%s";

                if (!serviceList.isArray(_items)) {
                    items.push(_items);
                } else {
                    items = _items;
                }

                if (items.length > 0){
                    res = source.toString().replace(_term, items.shift());
                    res = serviceList.myReplace(res, items, _term);
                }
            }

            return res;
        },

        initResize : function(source, Name){
            mcConst.scrResize = source;
            mcConst.isShowed  = Name;
        },

        showView : function(view){
            if (view && view.className.indexOf('hidden') !== -1) {
                view.className = view.className.replace(' hidden', "");
            }
        },

        hideView : function(view){
            if (view && view.className.indexOf('hidden') === -1) {
                view.className += ' hidden';
            }
        },

        showCurrentView : function(Name, $rootScope, view, options){
            options = options || {};

            if (mcConst.isShowed !== Name) {
                $rootScope.$broadcast('hide' + mcConst.isShowed);
                $rootScope.$broadcast('setLocation', ['/' + $rootScope.currentRootPath + '/' + Name + '/', options.callBack, options.title]);

                serviceList.showView(view);

                mcConst.isShowed = Name;
            }
        },

        getLangItemsFromList : function(from, to, correct){
            var res = [];

            correct = correct || 0;

            for (var i = from; i <= to; i++){ // 249 492
                res.push({
                    id    : (i - from + correct).toString(),
                    value : serviceList.Lang(i)
                })
            }

            return res;
        },

        getLanguagesItems : function(from, to, correct){
            var res = [];

            correct = correct || 0;

            for (var i = from; i <= to; i++){ // 249 492
                res.push({
                    id    : (i - from + correct).toString(),
                    value : mcConst.LanguagesList[i]
                })
            }

            return res;
        },

        GetFioFormatList : function(){
            return serviceList.getLangItemsFromList(975, 983);/*.sort(function(a, b){
            return serviceList.sortAB(a.value.toLowerCase(), b.value.toLowerCase());
        });*/
        },

        sortAB : function(a,b,invert){
            return (a > b) ? (invert ? -1 : 1) : ((a < b) ? (invert ? 1 : -1) : 0);
        },

        GetCountriesList : function(){
            var res = serviceList.getLanguagesItems(249, 492, 1).sort(function(a, b){
                return serviceList.sortAB(a.value.toLowerCase(), b.value.toLowerCase());
            });

            res.unshift({
                id: '-1',
                value: serviceList.Lang(140) // "140":"Ничего не выбрано",
            });

            return res;
        },

        GetMaritalStatusList : function(){
            return serviceList.getLangItemsFromList(151, 157, 1);
        },

        GetSpokenLangList : function(){
            var res = serviceList.getLanguagesItems(180, 248, 1).sort(function(a, b){
                return serviceList.sortAB(a.value.toLowerCase(), b.value.toLowerCase());
            });

            res.unshift({
                id: '-1',
                value: serviceList.Lang(140) // "140":"Ничего не выбрано",
            });

            return res;
        },

        GetInterestsList : function(){
            var res = serviceList.getLangItemsFromList(494, 543, 1);

            res.unshift({
                id: '-1',
                value: serviceList.Lang(140) // "140":"Ничего не выбрано",
            });

            return res;
        },

        GetPastList : function(){
            var res = serviceList.getLangItemsFromList(546, 553, 1);

            res.unshift({
                id: '-1',
                value: serviceList.Lang(140) // "140":"Ничего не выбрано",
            });

            return res;
        },

        GetPastOrgList : function(){
            var res = serviceList.getLangItemsFromList(554, 573, 1);

            res.unshift({
                id: '-1',
                value: serviceList.Lang(140) // "140":"Ничего не выбрано",
            });

            return res;
        },

        GetWeekDays : function(){
            return serviceList.getLangItemsFromList(646, 652);
        },

        SaveSessionSettings : function(login, pwd, servPwd, rm, email){
            if (serviceList.isObject(login)){
                pwd     = login.pwd;
                servPwd = login.servPwd;
                rm      = login.rm;
                login   = login.login;
                // email   = login.Email;
            }

            webix.storage.local.put(mcConst.storageFields.Login, login);

            if (rm){
                webix.storage.local.put(mcConst.storageFields.Pwd, pwd);
                webix.storage.local.put(mcConst.storageFields.ServPwd, servPwd);
                webix.storage.local.put(mcConst.storageFields.Rm, true);

                // if (mcConst.storageFields.Email) webix.storage.local.put(mcConst.storageFields.Email, email); // for websupport
            } else {
                webix.storage.local.remove(mcConst.storageFields.Pwd);
                webix.storage.local.remove(mcConst.storageFields.ServPwd);
                webix.storage.local.remove(mcConst.storageFields.Rm);

                // if (mcConst.storageFields.Email) webix.storage.local.remove(mcConst.storageFields.Email); // for websupport
            }
        },

        LoadSessionSettings : function(){
            var res = {};

            res.login   = webix.storage.local.get(mcConst.storageFields.Login);
            res.pwd     = webix.storage.local.get(mcConst.storageFields.Pwd);
            res.servPwd = webix.storage.local.get(mcConst.storageFields.ServPwd);
            res.rm      = webix.storage.local.get(mcConst.storageFields.Rm);
            
            // if (mcConst.storageFields.Email) res.Email = webix.storage.local.get(mcConst.storageFields.Email);

            return res;
        },

        ClearSessionSettings: function(leaveUIN, noAutoconnectOnReload){
            if (!leaveUIN) {
                webix.storage.local.remove(mcConst.storageFields.Login);
            }

            webix.storage.local.remove(mcConst.storageFields.Pwd);
            webix.storage.local.remove(mcConst.storageFields.ServPwd);
            webix.storage.local.remove(mcConst.storageFields.Rm);

            if (noAutoconnectOnReload){
                webix.storage.local.put(mcConst.storageFields.AutoRld, true);
            } else {
                webix.storage.local.remove(mcConst.storageFields.AutoRld);
            }
        },

        toNormalDate : function (value, needTime){
            if (serviceList.isString(value)) {
                value = value.split('.');
            }

            var date = value[0] + '.' + //day
                value[1] + '.' + //month
                value[2];        //year

            var time = value[3] + ':' + //hour
                value[4] + ':' + //minutes
                value[5];        //seconds

            return date + ((needTime)? " " + time : "");
        },

        sortableDate : function(date, noSec){
            var dd = date.split('.');

            return dd[2] + '.' + dd[1] + '.' + dd[0] + ' ' + dd[3] + ':' + dd[4] + (!noSec ? ':' + dd[5] : '');
        },

        secToTime : function(sec){
            var ss = sec % 60;
            var dd = parseInt(sec / 86400);
            sec = sec - 86400*dd;
            var hh = parseInt(sec / 3600);
            var nn = parseInt(sec / 60) - (hh * 60);

            return (dd) + ':' + ((hh < 10) ? ("0" + hh) : hh) + ":" + ((nn < 10) ? ("0" + nn) : nn) + ":" + ((ss < 10) ? ("0" + ss) : ss);
        },

        formatNumber : function(numb){
            var stNumb = numb.toString();
            var res = [];
            var id = 1;

            for (var i = stNumb.length - 1; i >= 0; i --){
                res.unshift(((id === 3) ? " " : "") + stNumb[i]);

                id = (id === 3) ? 1 : (id + 1);
            }

            return res.join('');
        },

        convertBool : function (val) {
            switch (val) {
                case true:  val = '1'; break;
                case false: val = '0'; break;
                default:    val = val + "";
            }

            return val;
        },

        convertIntToBool : function (val) {
            return serviceList.isBoolean(val) ? val : val == 1;
        },

        clearPlaneObj : function(obj){
            for (var i in obj){
                obj[i] = null;
            }
        },

        Queue : function(lookupTime, loop){
            var self      = this;
            var needRun   = [];
            var canNext   = loop || false;
            var paramList = [];
            var nowRunned = false;
            var time      = lookupTime || 1000;

            var lookUp    = null;

            function start(){
                return setInterval(function(){
                    if (!nowRunned && needRun.length > 0){
                        nowRunned = true;

                        var arg = (serviceList.isArray(paramList[0])) ? paramList[0] : [paramList[0]];

                        needRun[0].apply(self, arg);
                    }
                }, time);
            }

            this.next = function(){
                if (needRun.length > 0){
                    needRun.shift();
                    paramList.shift();

                    nowRunned = false;
                } else
                if (!canNext){
                    clearInterval(lookUp);

                    self = null;
                }
            };

            this.addTask = function (qItem, params){
                if (needRun.length === 0 && !nowRunned) {
                    lookUp = start();
                }

                needRun.push(qItem);
                paramList.push(params);

                return needRun.length;
            };
        },

        TaskList : function(_scope){
            var self  = this;
            var list  = [];
            var scope = {};

            this.AddTask = function(task){
                list.push(task);
            };

            this.Next = function(){
                if (list[0]){
                    list.shift().apply(scope, arguments);
                } else {
                    self = null;
                }
            };

            this.Run = function(){
                self.Next();
            };

            scope = serviceList.Marge({
                next : self.Next,
                Next : self.Next
            }, _scope || {});
        },

        transformDataObject : function(source, dependency){
            var res = [];

            if (source && dependency){
                for ( var i = 0; i < source.length; i++){
                    var item = {};

                    for (var j = 0; j < dependency.length; j++){
                        item[dependency[j][1]] = source[i][dependency[j][0]].toString();
                    }

                    res.push(item);
                }
            } else {
                res = source;
            }

            return res;
        },

        networkInterfaces: function(IPVer, IPlist){
            var myType =(IPVer == 0) ? "IPv4" : "IPv6"; // $scope.data.IPVer
            var IPs    = [].concat(IPlist[myType]); // $scope.data.networkInterfaces[myType]

            for (var i = 0; i < IPs.length; i++){
                IPs[i] = {id : IPs[i], value: (( IPs[i] == '0.0.0.0') || (IPs[i] == '::')) ? serviceList.Lang(667) : IPs[i]};// "667": "слушать всё",
            }

            return IPs;
        },

        correctStringWithCRLF : function(val){
            return (serviceList.isString(val)) ? val.replace(/(?!\r)\n/g, '\r\n') : val;
        },

        removeCRFL: function(text){
            return text.toString().replace(/\n/g, '<br>').replace(/\r/g, '');
        },

        initChangesApplyForSettings: function($scope, $rootScope, CMD, applyText, storage){
            var backupItems = {};

            storage = storage || mcConst.dataModels.SettingsNetwork;

            function clearChangedData (){
                $scope.changedData.data.Items    = {};
                $scope.changedData.data.Desc     = "";
                $scope.changedData.data.ShowDesc = false;
            }

            $scope.changedData = {
                data : {
                    Desc   : "",
                    Items  : {},
                    ShowDesc : false,
                    Reopen : false
                },
                clearChangedData: clearChangedData,
                onApply : function() {
                    $scope.data = serviceList.Marge($scope.data, $scope.changedData.data.Items);
                    backupItems = serviceList.Marge({}, $scope.changedData.data.Items);

                    var data = {};

                    if ($scope.changedData.data.Items.hasOwnProperty("TURNPortTCP")){
                        data.turn = $scope.changedData.data.Items["TURNPortTCP"];
                    }
                    if ($scope.changedData.data.Items.hasOwnProperty("WEBTCPPort")){
                        data.web = $scope.changedData.data.Items["WEBTCPPort"];
                    }
                    if ($scope.changedData.data.Items.hasOwnProperty("TCPPort")){
                        data.core = $scope.changedData.data.Items["TCPPort"];
                    }
                    if ($scope.changedData.data.Items.hasOwnProperty("FTPPort")){
                        data.ftp = $scope.changedData.data.Items["FTPPort"];
                    }
                    if ($scope.changedData.data.Items.hasOwnProperty("FTPPortsPool")){
                        data.ftprange = $scope.changedData.data.Items["FTPPortsPool"];
                    }
                    if ($scope.changedData.data.Items.hasOwnProperty("TURNExternalConfig")){
                        data.turnconfig = $scope.changedData.data.Items["TURNExternalConfig"];
                    }

                    if (Object.keys(data).length){
                        $rootScope.$broadcast('SendCMDToServer', [
                            mcConst._CMD_.cs_adm_check_ports,
                            mcConst.SessionID,
                            JSON.stringify(data),
                            function () {
                                $scope.applyChange($scope.data);

                                clearChangedData();
                            }
                        ]);
                    } else {
                        $scope.applyChange($scope.data);

                        clearChangedData();
                    }
                },
                onClose : function(){
                    $scope.$emit("show" + $scope.Name, []);

                    clearChangedData();
                }
            };

            function changeApplyData (id, val){
                $scope.changedData.data.ShowDesc  = true;
                $scope.changedData.data.Items[id] = serviceList.correctStringWithCRLF(val);
                $scope.changedData.data.Desc      = serviceList.Lang(590); // "590": "Список измененных параметров:<br>",

                var item = "";

                for (var i in $scope.changedData.data.Items){
                    item = $scope.changedData.data.Items[i].toString().replace(/\\/g, '\\\\').replace(/</g, "&lt;");

                    $scope.changedData.data.Desc += "<br>" + i + ": <b>" + (
                        (
                            (i.indexOf('PWD') !== -1) ||
                            (i.toLowerCase().indexOf('pass') !== -1) ||
                            (i === "UseConnPass")
                        ) ? "*****" : item ) + "</b>"; // &#092;
                }

                $rootScope.$broadcast('show' + mcConst.dataModels.ApplyPanel, [$scope.changedData]);
            }

            function checkLastSlash(data, where) {
                if (data[where] && ["\\", "/"].indexOf(data[where][data[where].length - 1]) === -1){
                    data[where] += '\\';
                }
                // if (data.BackupsDir && (data.BackupsDir[data.BackupsDir.length - 1] != '\\') && (data.BackupsDir[data.BackupsDir.length - 1] != '/')){
                //     data.BackupsDir += '\\';
                // }
            }

            $scope.change = function(newV, oldV){
                if ($scope.skipChangeNow) return;

                var id = serviceList.copy(this.config.id, 3);
                var valid = true;
                // var restoreValue = false;

                if (newV == undefined){
                    newV = this.getValue();
                }

                if (oldV === undefined){
                    oldV = $rootScope.mcStorage[storage][id];
                }

                if (this.config.pathAlias){
                    newV = serviceList.trim(newV.replace(/\W/ig, ""));

                    this.$setValue(newV);
                } else
                if (this.config.view === "checkbox"){
                    newV = serviceList.convertIntToBool(newV);
                    oldV = serviceList.convertIntToBool(oldV);
                } else
                if (this.config.mcType === "port"){
                    valid = !isNaN(parseInt(newV)) && newV && (newV > 0) && (newV < 65534); //^\d+$/.test(newV);
                } else
                if (this.config.id === "stgRobotAvatarNum"){
                    valid = (/^\d+$/.test(newV)) && (newV >= 0) && (newV <= 239);
                } else
                if (this.config.id === "stgRobotName"){
                    valid = serviceList.trim(newV) !== "";
                } else
                if (this.config.id === "stgExternalIP" || this.config.id === "stwExternalIP"){
                    valid = serviceList.isValidIpAddress(newV) || serviceList.isValidHostName(newV) ? serviceList.trim(newV).indexOf(":") === -1 : false;

                    if (!valid){
                        newV = $rootScope.mcStorage[storage][id];
                    }

                    changeApplyData(id, newV);
                }

                if (valid && (mcConst.isShowed === $scope.Name) && (serviceList.correctStringWithCRLF(newV) !== oldV)){
                    if (this.config.pathAlias && !newV){
                        newV = oldV;
                    }

                    changeApplyData(id, newV);
                } else {
                    if (((this.config.view !== 'text') && (this.config.view !== 'textarea'))) {
                        this.$setValue(oldV);
                    }
                }
            };

            $scope.changeExc = function () {
                if (this.config && this.config.view === 'counter' || this.config.view === 'text') {
                    var newV = this.getValue();
                    var oldV = $scope.data[serviceList.copy(this.config.id, 3)];

                    if (!isNaN(newV)) {
                        $scope.change.apply(this, [newV, oldV]);
                    } else {
                        $scope.change.apply(this, [oldV, 1]);
                        this.$setValue(oldV);
                    }
                }
            };

            $scope.applyChange = function(data){
                // webix.message(applyText($scope.changedData.data.Items));

                if ($scope._onApply){
                    $scope._onApply(data);
                }

                ["BackupsDir", "FTPPublicDir", "FTPPersonalDir", "FilesDir", "LogsDir"].forEach(function (t) {
                    checkLastSlash(data, t);
                });

                var res = JSON.stringify(data, function(key, value){
                    return value;
                });

                $rootScope.$broadcast('SendCMDToServer', [
                    CMD,
                    mcConst.SessionID,
                    res,
                    function () {
                        webix.message(applyText(backupItems));
                        
                        $rootScope.mcStorage[storage] = serviceList.Marge($rootScope.mcStorage[storage], backupItems || {});
                    }
                ]);

                $rootScope.$broadcast('SendCMDToServer', [
                    mcConst._CMD_.cs_adm_get_server_options,
                    mcConst.SessionID
                ]);
            };
        },

        openNewWindow : function(url){
            var newWindow = window.open(url, '', 'menubar=no,resizable=0,directories=no,location=no,toolbar=no,status=no,screenX=0,screenY=0,width=1000,height=600');

            if (newWindow) newWindow.focus();
        },

        onOffToBool : function(val){
            return serviceList.isBoolean(val) ? val : val == 'on';
        },

        InObject : function(item, obj){
            var res = false;

            for(var i in obj) {
                if (item == obj[i]) {
                    res = true;
                    break;
                }
            }

            return res;
        },

        getIdxByIdFromData : function(data, id){
            var res = null;

            for (var i = 0; i < data.length; i ++){
                if (data[i].id == id) {
                    res = i;
                    break;
                }
            }

            return res;
        },

        getIdxByNameFromData : function(data, key, val){
            var res = null;

            for (var i = 0; i < data.length; i ++){
                if ((data[i][key] !== undefined) && (data[i][key] == val)) {
                    res = i;
                    break;
                }
            }

            return res;
        },

        getValueByNameFromData : function(data, key, val){
            var res = "";

            for (var i = 0; i < data.length; i ++){
                if ((data[i][key] !== undefined) && (data[i][key] == val)) {
                    res = data[i][key];
                    break;
                }
            }

            return res;
        },

        oldLicenseKey : function(key){
            var res = false;
            var reg = /^([A-Z0-9]{4}\-){6}[A-Z0-9]{4}$/;

            res = reg.test(serviceList.trim(key));

            if (res) {
                res = serviceList.trim(key);
            }

            return res;
        },

        checkLicenseKey : function(key){
            var res = false;
            var reg = /^([A-F0-9]{4}\-){10}[A-F0-9]{4}$/;

            res = reg.test(serviceList.trim(key));

            if (res) {
                res = serviceList.trim(key);
            }

            return res;
        },

        checkGuestKey : function(key){
            var res = false;
            var reg = /^([A-F0-9]{4}\-){5}[A-F0-9]{4}$/;

            res = reg.test(serviceList.trim(key));

            if (res) {
                res = serviceList.trim(key);
            }

            return res;
        },

        checkQuizKey : function(key){
            var res = false;
            var reg = /^[A-F0-9]{6,8}\-([A-F0-9]{4}\-){3}[A-F0-9]{4}$/;

            res = reg.test(serviceList.trim(key));

            if (res) {
                res = serviceList.trim(key);
            }

            return res;
        },

        renameProperty : function (oldName, newName) {
            if (this.hasOwnProperty(oldName)) {
                this[newName] = serviceList.trim(this[oldName]);

                delete this[oldName];
            }
            return this;
        },

        ListButtonSet: function(opt){
            function add(){
                $$(_idBtn).hide();
                $$(_idBFld).show();

                if ( options.hideSearchField ) $$(options.hideSearchField).hide();

                if (items.fields[0]) {
                    if (options.type != 3 || options.type !== "combo") {
                        items.fields[0].setValue("");
                        if (items.fields[1]) {
                            items.fields[1].setValue("");
                        }
                    }

                    items.fields[0].focus();

                    if (options.actions.preview){
                        options.actions.preview(items.fields[0]);
                    }
                } else {
                    throw new Error('No fields found!');
                }

                if (options.actions.afterShow){
                    options.actions.afterShow(items.fields);
                }
            }

            function save (){
                if (options.actions.save && options.actions.save.apply(null, items.fields)){
                    back();
                }
            }

            function back (){
                if (items.fields[0] && items.fields[0].hasOwnProperty('getPopup')){
                    items.fields[0].getPopup().hide();
                }

                $$(_idBFld).hide();
                $$(_idBtn).show();

                if ( options.hideSearchField ) $$(options.hideSearchField).show();
            }

            function del(){
                var _list        = $$(options.list);
                var selectedItem = _list.getSelectedItem();

                if (selectedItem && options.actions.del){
                    var len     = selectedItem[options.selectedItem] ? selectedItem[options.selectedItem].length : 0;
                    var delText = serviceList.Lang(1078, len > 15 ? serviceList.copy(selectedItem[options.selectedItem], 0, 15) + "..." : selectedItem[options.selectedItem]); // "1078":"Удалить %s из списка?",

                    if (serviceList.isArray(selectedItem)){
                        delText = serviceList.Lang(1142); // "1142":"Удалить отмеченные элементы?",
                    }

                    options.regShowWindow(serviceList.RandomHash(4), webix.confirm({
                        type  : "confirm-warning",
                        text  : delText,
                        ok    : serviceList.Lang(581), // "581": "Удалить",
                        cancel: serviceList.Lang(103), // "103": "Отмена",
                        callback:function(yes){
                            if (yes){
                                options.actions.del(selectedItem, _list);

                                if (serviceList.isArray(selectedItem)){
                                    for (var i = 0; i < selectedItem.length; i ++){
                                        serviceList.remove(selectedItem[i].id);
                                    }

                                    webix.message(serviceList.Lang(1506)); // "1506":"Элементы удалены",
                                } else {
                                    webix.message(serviceList.Lang(1077, selectedItem[options.selectedItem])); // "1077":"%s удален",

                                    _list.remove(selectedItem.id);
                                }

                                if (options.actions.afterDel) options.actions.afterDel(_list);
                            }
                        }
                    }));
                }
            }

            function clear(){
                //if ($$(options.list).serialize().length){
                options.regShowWindow(serviceList.RandomHash(4), webix.confirm({
                    type  : "confirm-warning",
                    text  : serviceList.Lang(1072),// "1072":"Очистить список?",
                    ok    : serviceList.Lang(581), // "619": "Очистить",
                    cancel: serviceList.Lang(103), // "103": "Отмена",
                    callback:function(yes){
                        if (yes){
                            if (options.actions.clear()){
                                $$(options.list).clearAll();
                            }
                        }
                    }
                }));
                //}
            }

            function afterRender(){
                // items.fields[0] = this;

                webix.UIManager.addHotKey("Enter", function() {
                    save();

                    return false;
                }, this);

                webix.UIManager.addHotKey("Esc", function() {
                    back();

                    return false;
                }, this);
            }

            var options = serviceList.Marge({
                type   : '1',
                actions: {
                    del    : null,
                    clear  : null,
                    save   : null,
                    preview: null,
                    enable : null,
                    disable: null
                },
                text : {
                    field1 : "", // "1075":"Введите IP, маску или диапазон",
                    field2 : "", // serviceList.Lang(1032) "1032":"Комментарий:",
                    field3 : ""  // serviceList.Lang(1032) "1032":"Комментарий:",
                },
                visibleBtns: {
                    add: true,
                    del: true,
                    cls: true
                },
                list : null,
                listData : [],
                regShowWindow: null,
                selectedItem: 'value'
            }, opt || {});

            var res     = null;

            if (serviceList.isFunction(options._back)){
                options._back(back);
            }

            if (!options.regShowWindow){
                var errtext = 'Needs \"regShowWindow\" for show popup windows in ' + options.list;

                console.error(errtext);

                webix.message({ type:"error", text: errtext, expire : mcConst.errMessageExpire * 2});
            } else {
                var _idBtn  = serviceList.RandomHash(10);
                var _idBFld = serviceList.RandomHash(10);
                var items   = {
                    fieldBlock: null,
                    fields    : [],
                    list      : null
                };

                res = { rows : [
                    { id: _idBtn, cols: [ // блок с кнопками: добавить удалить очистить
                        { view: "button", value: serviceList.Lang(50), hidden: !options.visibleBtns.add, click: add, css: "applyButton"},// "50" : "Добавить",
                        { view: "button", value: serviceList.Lang(52), hidden: !options.visibleBtns.del, click: del, type: "danger"},    // "52" : "Удалить",
                        { view: "button", value: serviceList.Lang(619), hidden: !options.visibleBtns.cls,click: clear}                   // "619": "Очистить",
                    ]},
                    { id: _idBFld, hidden: true, rows: [{}]} // появляющийся блок
                ]};

                switch (options.type){
                    case 'textComment':
                    case '1':
                        res.rows[1].rows = [
                            { view: "text", placeholder: options.text.field1, on: { onAfterRender: function() { items.fields[0] = this; afterRender.apply(this, arguments); } } },
                            { cols: [
                                { view: "text", placeholder: options.text.field2, // id: "ipfAcceptAddComment",
                                    on: { onAfterRender: function() { items.fields[1] = this; afterRender.apply(this, arguments); } }
                                },
                                { view: "button", value: serviceList.Lang(104), width: 100, click: save}, // "104": "Сохранить",
                                { view: "button", value: serviceList.Lang(103), width: 100, click: back, type: "danger"}  // "103": "Отмена",
                            ]}
                        ];
                    break;

                    case 'text':
                    case '2':
                        res.rows[1].cols = [
                            { view: "text", placeholder: options.text.field1, on: { onAfterRender: function() { items.fields[0] = this; afterRender.apply(this, arguments); } } },// "1075":"Введите IP, маску или диапазон",
                            { view: "button", value: serviceList.Lang(104), width: 100, click: save}, // "104": "Сохранить",
                            { view: "button", value: serviceList.Lang(103), width: 100, click: back, type: "danger"} // "103": "Отмена",
                        ];
                    break;

                    case 'combo':
                    case '3':
                        res.rows[1].cols = [
                            { view: "combo", options: options.listData, on: { onAfterRender: function() { items.fields[0] = this; afterRender.apply(this, arguments); } } },
                            { view: "button", value: serviceList.Lang(13), width: 100, click: save, css: "applyButton"}, // "13" : "Ок",
                            { view: "button", value: serviceList.Lang(103), width: 100, click: back, type: "danger"} // "103": "Отмена",
                        ];
                    break;

                    case 'textRichselectComment':
                    case '4':
                        res.rows[1].rows = [
                            { cols: [
                                { view: "text", placeholder: options.text.field1, on: { onAfterRender: function() { items.fields[0] = this; afterRender.apply(this, arguments); } } },
                                { view: "richselect", placeholder: options.text.field2, options: options.listData, on: { onAfterRender: function() { items.fields[1] = this } } }
                            ]},
                            { cols: [
                                { view: "text", placeholder: options.text.field3, // id: "ipfAcceptAddComment",
                                    on: { onAfterRender: function() { items.fields[2] = this; afterRender.apply(this, arguments); } }
                                },
                                { view: "button", value: serviceList.Lang(104), width: 100, click: save}, // "104": "Сохранить",
                                { view: "button", value: serviceList.Lang(103), width: 100, click: back, type: "danger"}  // "103": "Отмена",
                            ]}
                        ];
                    break;
                }
            }

            return res;
        },

        findItemInArrayOfObj: function( arr, val, id, lowerCase ){
            for (var i = 0; i < arr.length; i++){
                if (!id){
                    for (var j in arr[i]){
                        if (lowerCase){
                            if (arr[i][j].toLowerCase() == val.toLowerCase()){
                                return i;
                            }
                        } else
                        if (arr[i][j] == val){
                            return i;
                        }
                    }
                } else
                if (lowerCase){
                    if (arr[i][id].toLowerCase() == val.toLowerCase()){
                        return i;
                    }
                } else
                if (arr[i][id] == val){
                    return i;
                }
            }

            return -1;
        },

        ContextMenu : function(_master, oldMenu, cb, onShow){
            function selectAll (){
                if (_master.selectAll){
                    _master.selectAll();
                } else {
                    _master.selectRange(_master.getFirstId(), _master.getLastId());
                }
            }

            if (oldMenu) {
                oldMenu.destructor();
            }

            return webix.ui({
                view  : "context",
                width : 220,
                master: _master,
                body  : { rows: [
                    { view: "button", value: serviceList.Lang(1105), click: function(){ // "1105":"Выделить все",
                        selectAll();

                        var context = this.getTopParentView();

                        if (cb) cb.call(context.getContext().obj, 'selectAll');

                        context.hide();
                    }},
                    { view: "button", value: serviceList.Lang(1106), click: function(){ // "1106":"Снять выделение",
                        if (_master.unselectAll){
                            _master.unselectAll()
                        } else {
                            _master.clearSelection();
                        }

                        var context = this.getTopParentView();

                        if (cb) cb.call(context.getContext().obj, 'clear');

                        context.hide();
                    }},
                    { view: "button", value: serviceList.Lang(1107), click: function(){ // "1107":"Инвертировать выделение",
                        var selectedItems = _master.getSelectedItem();

                        if (serviceList.isObject(selectedItems)){
                            selectedItems = [selectedItems];
                        }

                        selectAll();

                        var context = this.getTopParentView();

                        for (var i = 0; selectedItems && i < selectedItems.length; i ++){
                            _master.unselect(selectedItems[i].id);
                        }

                        if (cb) cb.call(context.getContext().obj, 'invert');

                        context.hide();
                    }}
                ]},
                on: { onShow: function() {
                    if (onShow) onShow.apply(this, []);
                }}
            });
        },

        getAllUserForFillList: function(list, cb, $rootScope){
            var usersCash = $rootScope.mcStorage[mcConst.dataModels.UserManager];

            if (usersCash && usersCash.Params === "All" && !list.length){
                cb.apply(usersCash, [usersCash.Users]);
            } else
            if (!usersCash || usersCash.Params !== "All" || (list.length > 0 && usersCash.Users.length !== list.length)){
                $rootScope.$broadcast('getAllUserList', [false, function() {
                    usersCash = $rootScope.mcStorage[mcConst.dataModels.UserManager];

                    cb.apply(usersCash, [usersCash.Users]);
                }]);
            }
        },

        getAllUserWithParams: function(cb, $rootScope, params){
            var usersCash = $rootScope.mcStorage[mcConst.dataModels.UserManager];

            if (usersCash && usersCash.Params === "All" &&  params === "All"){
                cb.apply(usersCash, [usersCash.Users]);
            } else {
                $rootScope.$broadcast('SendCMDToServer', [
                    mcConst.lockInterface,
                    mcConst._CMD_.cs_adm_list_users,
                    mcConst.SessionID,
                    !params ? 'All' : params.Params || 'All',
                    !params ? mcConst.userFields : params.Filters || mcConst.userFields,
                    function (data) {
                        $rootScope.mcStorage.UserManager = data;

                        cb.apply(data, [data.Users]);
                    }
                ]);
            }
        },

        getMcSettings: function($rootScope, show, allways){
            if (!$rootScope.mcStorage.SettingsNetwork || allways){
                $rootScope.$broadcast('SendCMDToServer', [
                    mcConst.lockInterface,
                    mcConst._CMD_.cs_adm_get_server_options,
                    mcConst.SessionID,

                    function (data){
                        $rootScope.mcStorage.SettingsNetwork = data;

                        $rootScope.$broadcast('SendCMDToServer', [
                            mcConst.lockInterface,
                            mcConst._CMD_.cs_adm_get_server_info,
                            mcConst.SessionID,

                            function( data ){
                                $rootScope.mcStorage.ServerInfo = data;

                                if ( show ) show();
                            }
                        ]);
                    }
                ]);
            } else {
                if ( show ) show();
            }
        },

        getTitle: function(path){
            var res = "";

            switch (path){
                case "ServerInfo":      res = serviceList.Lang(10);   break; // "10" : "Информация о сервере",
                case "UserManager":     res = serviceList.Lang(49);   break; // "49" : "Список пользователей",
                case "UserProfile":     res = serviceList.Lang(1484); break; // "1484":"Профиль пользователя",
                case "GroupRights":     res = serviceList.Lang(57);   break; // "57" : "Группы прав"
                case "GroupUsers":      res = serviceList.Lang(916);  break; // "916":"Пользователи групп",
                case "Contacts":        res = serviceList.Lang(587);  break; // "587": "Общий список контактов",
                case "WorkPositions":   res = serviceList.Lang(588);  break; // "588": "Должности компании",
                case "WebSupport":      res = serviceList.Lang(938);  break; // "938":"Web-поддержка",
                case "MyChatGuest":     res = serviceList.Lang(945);  break; // "945":"MyChat Guest",
                case "LicenseMyChat":   res = serviceList.Lang(944);  break; // "944":"MyChat Server",
                case "LicenseGuest":    res = serviceList.Lang(945);  break; // "945":"MyChat Guest",
                case "UsersImports":    res = serviceList.Lang(960);  break; // "960":"Импорт пользователей",
                case "Operators":       res = serviceList.Lang(817);  break; // "817":"Модераторы",
                case "Bans":            res = serviceList.Lang(1029); break; // "1029":"Забаненные пользователи",
                case "AutoChannels":    res = serviceList.Lang(1039); break; // "1039":"Автосоздаваемые конференции",
                case "RemoteSettings":  res = serviceList.Lang(1329); break; // "1329":"Дистанционные настройки клиента",
                case "History":         res = serviceList.Lang(1134); break; // "1134":"Просмотр протоколов",
                case "FilterAntiflood": res = serviceList.Lang(1057); break; // "1057":"Антифлуд",
                case "FilterBadWords":  res = serviceList.Lang(1058); break; // "1058":"Плохие слова",
                case "FilterIP":        res = serviceList.Lang(1059); break; // "1059":"IP фильтры",
                case "FilterMAC":       res = serviceList.Lang(1060); break; // "1060":"MAC фильтры",
                case "FilterNames":     res = serviceList.Lang(1061); break; // "1061":"Блокировки названий",
                case "SettingsNetwork": res = serviceList.Lang(591);  break; // "591": "Сетевые настройки MyChat",
                case "SettingsInfo":    res = serviceList.Lang(596);  break; // "596": "Информация",
                case "SettingsLogs":    res = serviceList.Lang(598);  break; // "598": "Протоколирование",
                case "SettingsFTP":     res = serviceList.Lang(599);  break; // "599": "FTP файловый сервер",
                case "SettingsWEB":     res = serviceList.Lang(600);  break; // "600": "WEB-сервисы",
                case "SettingsBackup":  res = serviceList.Lang(601);  break; // "601": "Резервные копии",
                case "SettingsService": res = serviceList.Lang(602);  break; // "602": "Обслуживание",
                case "SettingsAPI":     res = serviceList.Lang(603);  break; // "603": "Integration API",
                case "SettingsSMTP":    res = serviceList.Lang(921);  break; // "921":"Настройка SMTP",
                case "Others":          res = serviceList.Lang(672);  break; // "672": "Дополнительно",
            }

            return res;
        },

        formatDeptList: function( data ){
            var separator = '';
            var levels = {};
            var i = 0;
            var res = [];
            var normalData = [];
            var idx;
            var deptList = [];

            while (data.length > 0 || i < data.length){
                if (data[i].ParentID == 0) {
                    normalData.push(data[i]);

                    data.splice(i, 1);
                } else {
                    idx = serviceList.findItemInArrayOfObj(normalData, data[i].ParentID, "GroupID");

                    if (idx == -1) {
                        i++;
                    } else {
                        normalData.push(data[i]);

                        data.splice(i, 1);
                    }
                }

                if (data.length > 0 && i == data.length){
                    i = 0;
                }
            }

            for (i = 0; i < normalData.length; i++){
                if (normalData[i].ParentID == 0) {
                    levels[normalData[i].GroupID] = 0;
                } else {
                    levels[normalData[i].GroupID] = levels[normalData[i].ParentID] + 1;
                }

                separator = new Array(levels[normalData[i].GroupID] + 1).join('&#151;');

                res.push({
                    id: normalData[i].GroupID,
                    value: separator + normalData[i].GroupName
                });
            }

            for (i = 0; i < normalData.length; i++){
                if (normalData[i].ParentID == 0){
                    deptList.push(res[i]);
                } else {
                    deptList.splice(serviceList.findItemInArrayOfObj(deptList, normalData[i].ParentID, "id") + 1, 0, res[i]);
                }
            }

            return deptList;
        },

        copyToBuffer: function(){
            setTimeout(function(){
                webix.message(serviceList.Lang(1483)); // "1483":"Лог скопирован в буфер обмена!",
            }, 10);

            return $$("logsContainer").$view.innerText.replace(/\n/g, '\r\n');
        },

        convertDomainToDn : function(dn){
            if (dn.indexOf('=') === -1){
                dn = dn.split('.');

                for (var i = 0; i < dn.length; i++){
                    dn[i] = 'DC=' + dn[i];
                }

                dn = dn.join(',').toUpperCase();
            } else {
                dn = dn.toUpperCase();
            }

            return dn;
        },

        convertDataToTree: function(data, withMe){
            function add(current, parent){
                var item = null;

                if (current.IsGroup){
                    item = {
                        DisplayName: current.GroupName || current.DisplayName,
                        id         : current.ID || current.id,
                        ParentID   : current.ParentID,
                        GroupID    : current.GroupID,
                        IsGroup    : true,
                        folder     : true,
                        data       : current.data || []
                    };
                } else {
                    if (!withMe && current.UIN == mcConst.UserInfo.UIN){
                        return false;
                    }

                    item = {
                        DisplayName: current.DisplayName,
                        id         : current.ID || current.id,
                        ParentID   : current.ParentID,
                        State      : current.State,
                        UIN        : current.UIN,
                        TeamLead   : current.TeamLead
                    };
                }

                parent.push(item);

                return true;
            }

            var res = [];
            var structure = [];
            var _data = [].concat(data);
            var i = 0;
            var needAdd = null;

            while (_data.length > 0){
                if (_data[i].ParentID == 0){
                    needAdd = add(_data[i], res);
                    if (needAdd) add(res[res.length - 1], structure);

                    _data.splice(i, 1);
                } else {
                    var idx = serviceList.findItemInArrayOfObj(structure, _data[i].ParentID, "GroupID");

                    if (idx >= 0){
                        needAdd = add(_data[i], structure);
                        if (needAdd) add(structure[structure.length - 1], structure[idx].data);

                        _data.splice(i, 1);
                    } else {
                        i++;
                    }
                }

                if (i == _data.length) {
                    i = 0;
                }
            }

            return res;
        },

        hideFrame: function(id){
            var view = document.getElementById(id);

            if (view){
                view.style.display = 'none';
            }
        },

        showFrame: function(id){
            var view = document.getElementById(id);

            if (view){
                view.style.display = 'block';
            }
        },

        getFrame: function(id, src){
            var res = src || document.getElementById(id);

            if (res && !res.showFrame && !res.hideFrame) {
                res.showFrame = function() {
                    serviceList.showFrame(id) };
                res.hideFrame = function() {
                    serviceList.hideFrame(id) };
            }

            return res;
        },

        convertObjToArray: function(obj, keyToField, copy){
            var res = [];

            for (var i in obj){
                if (serviceList.isObject(obj[i])){
                    if (keyToField) obj[i][keyToField] = i;

                    res.push(copy ? serviceList.Marge({}, obj[i]) : obj[i] );
                }
            }

            return res;
        },

        getStateStatuses: function(state){
            return {
                Online  : state.Online  ? serviceList.StringToArray(state.Online, ',') : serviceList.StringToArray(state.Users, ','),
                Offline : state.Offline ? serviceList.StringToArray(state.Offline, ',') : [],
                States  : state.States  ? serviceList.StringToArray(state.States, ',') : serviceList.StringToArray(state.Statuses, ',')
            };
        },

        addEvent : function(object, type, callback) {
            if (object == null || typeof(object) == 'undefined') return;
            if (object.addEventListener) {
                object.addEventListener(type, callback, false);
            } else if (object.attachEvent) {
                object.attachEvent("on" + type, callback);
            } else {
                object["on"+type] = callback;
            }
        },

        getWindowSize: function(){
            var wndWidth = 0;
            var wndHeight = 0;

            if (typeof (window.innerWidth) == 'number') {
                wndWidth = window.innerWidth;
                wndHeight = window.innerHeight;
            } else {
                if (document.documentElement && (document.documentElement.clientWidth || document.documentElement.clientHeight)) {
                    wndWidth = document.documentElement.clientWidth;
                    wndHeight = document.documentElement.clientHeight;
                } else {
                    if (document.body && (document.body.clientWidth || document.body.clientHeight)) {
                        wndWidth = document.body.clientWidth;
                        wndHeight = document.body.clientHeight;
                    }
                }
            }

            return {
                width  : wndWidth,
                height : wndHeight
            };
        },

        convertDnArrayToTreeTable: function(dnList, base){
            var res = [];
            var dnStructure = {};
            var dn = "distinguishedName";

            function createStructure(obj, structure, parent){
                function add (arr, item){
                    var link = {
                        value: item
                    };

                    if (structure.length === 0){
                        link = serviceList.Marge(link, obj);
                    } else {
                        link['$row'] = "value";
                        link['open'] = true;
                        link['data'] = [];
                    }

                    arr.push(link);

                    return link;
                }

                if (structure.length){
                    var item = structure.pop().replace('CN=', '');

                    parent = parent || res;

                    var idx = serviceList.findItemInArrayOfObj(parent, item, "value");

                    createStructure(obj, structure, idx === -1 ? add(parent, item).data : parent[idx].data);
                }
            }

            for (var i = 0; i < dnList.length; i++){
                dnList[i][dn] = dnList[i][dn].replace(',' + base, '');

                if (!dnStructure[dnList[i][dn]]){
                    dnStructure[dnList[i][dn]] = dnList[i][dn].split(',');

                    createStructure(dnList[i], [].concat(dnStructure[dnList[i][dn]]), null);
                }
            }

            return res;
        },

        makeIceServers: function (data, isWeb){
            /** @namespace data.IPList*/
            /** @namespace data.TURNPort*/
            /** @namespace data.Credential */
            var res = [];
            var ipList = data.IPList.split(',');

            if (ipList[0] === ""){
                ipList[0] = isWeb ? window.location.host : mcConst.ServerInfo.Host;
            }

            for (var i = 0; i < ipList.length; i++){
                var tcp = 'turn:' + ipList[i] + ':' + data.TURNPort +'?transport=tcp';
                var udp = 'turn:' + ipList[i] + ':' + data.TURNPort +'?transport=udp';

                res.push({
                    urls       : []
                        .concat(isWeb ? tcp : [])
                        .concat(isWeb || (mcConst.ClientSettings && mcConst.ClientSettings.MediaNetworkTransportTCP) ? tcp : [])
                        .concat(isWeb || (mcConst.ClientSettings && mcConst.ClientSettings.MediaNetworkTransportUDP) ? udp : []),

                    credential : data.Credential,
                    username   : data.UserName
                });
            }

            return res;
        },

        checkRightsCollection: function(_ids, equals){
            var res = false;
            var id = null;

            for (var i = 0; i < _ids.length; i ++){
                id = parseInt(_ids[i]) - 1;

                res = equals
                    ? res && (mcConst.MyRightsSet.RightsSet[id] == '1')
                    : res || (mcConst.MyRightsSet.RightsSet[id] == '1');
            }

            return res;
        },

        MyTimer: function (_target){
            var Now = 0;
            var id = null;

            this.Start = function(){
                Now = 0;

                clearInterval(id);

                id = setInterval(function(){
                    Now++;

                    if (_target) {
                        _target.text(serviceList.MyFormatTime(Now, true));
                    }
                }, 1000);
            };

            this.Pause = function(newTime){
                clearInterval(id);

                Now = newTime || Now;
            };

            this.Stop = function(){
                if (_target) _target.text(serviceList.MyFormatTime(0, true));

                clearInterval(id);

                return serviceList.MyFormatTime(Now, true);
            };
        },

        openLink: function(link, param){
            var params = param || "menubar=yes,location=yes,resizable=yes,scrollbars=yes,status=yes";
            window.open(link, "", params);
        },

        showImportResult: function(data, $rootScope){
            var add = [];
            var upd = [];
            var err = [];
            var res = "";

            if (data && data.Results && data.Users){
                for (var i = 0; i < data.Results.length; i++){
                    switch (data.Results[i]){
                        case '0': case 0:
                        add.push(data.Users[i]);
                        break;

                        case '1': case 1:
                        upd.push(data.Users[i]);
                        break;

                        default:
                            err.push(data.Users[i]);
                    }
                }

                if (add.length){
                    res += "<span class='blue _grName'>" + mcLang(1552) + '</span><br>';// "1552":"Добавлены пользователи:",
                    res += add.join('<br>') + '<br><br>';
                }

                if (upd.length){
                    res += "<span class='green _grName'>" + mcLang(1553) + '</span><br>';// "1553":"Обновлены пользователи:",
                    res += upd.join('<br>') + '<br><br>';
                }

                if (err.length){
                    res += "<span class='red _grName'>" + mcLang(1554) + '</span><br>';// "1554":"Не добавленные пользователи:",
                    res += err.join('<br>');
                }

                var wnd = webix.ui({
                    view: "window",
                    position: "center",
                    modal: true,
                    width: 300,
                    height: 500,
                    head: mcLang(971), // "971":"Результат:",
                    body: { rows: [
                        { template: res, borderless: true, scroll: "y" },
                        { view: "button", value: mcLang(12), click: function(){
                            this.getTopParentView().hide();
                            this.getTopParentView().destructor();
                        }} //"12" : "Закрыть",
                    ]}
                });

                $rootScope.regShowWindow(serviceList.RandomHash(4), wnd);

                wnd.show();

                if (add.length || upd.length){
                    $rootScope.$broadcast('refreshUserManagerOnNextShow', []);
                }
            }
        },

        getUserStateText: function(_state, noColor){
            var state = "";

            switch (_state){
                case mcConst.states.offline:
                    state = serviceList.Lang(1641); break; // "1641":"Не в сети",

                case mcConst.states.online:
                    state = (!noColor ? '<span class="green">' : "") + serviceList.Lang(1642) + (!noColor ? '</span>' : ""); break; // "1642":"В сети",

                case mcConst.states.webOnline:
                    state = (!noColor ? '<span class="green">' : "") + serviceList.Lang(1642) + (!noColor ? '</span>' : ""); break; // "1642":"В сети",

                case mcConst.states.away:
                    state = (!noColor ? '<span class="blue">' : "") + serviceList.Lang(1643) + (!noColor ? '</span>' : ""); break; // "1643":"Нет на месте",

                case mcConst.states.dnd:
                    state = (!noColor ? '<span class="red">' : "") + serviceList.Lang(1644) + (!noColor ? '</span>' : ""); break; // "1644":"Не беспокоить",
            }

            return state;
        },

        getColorForStatus: function(status){
            var res = "#545454";

            status = parseInt(status);

            switch (status){
                case mcConst.states.offline: res = '#545454';  break; // "29" : "Не в сети",

                case mcConst.states.online: res = '#24F427'; break; // "30" : "В сети",

                case mcConst.states.webOnline: res = '#24F427'; break; // "30" : "В сети",

                case mcConst.states.away: res = 'blue'; break; // "31" : "Нет на месте",

                case mcConst.states.dnd: res = 'red'; break; // "32" : "Не беспокоить",
            }

            return res;
        },

        smartReplace: function (source, options) {
            for (var item in options){
                source = source.replace(new RegExp('{' + item + '}', 'g'), options[item]);
            }

            return source;
        },

        getIPs: function (callback){
            function handleCandidate(candidate){
                //match just the IP address
                var ip_regex = /([0-9]{1,3}(\.[0-9]{1,3}){3}|[a-f0-9]{1,4}(:[a-f0-9]{1,4}){7})/
                var ip_addr = ip_regex.exec(candidate)[1];

                //remove duplicates
                if(ip_dups[ip_addr] === undefined)
                    callback(ip_addr);

                ip_dups[ip_addr] = true;
            }

            var ip_dups = {};

            //compatibility for firefox and chrome
            var RTCPeerConnection = window.RTCPeerConnection
                || window.mozRTCPeerConnection
                || window.webkitRTCPeerConnection;
            var useWebKit = !!window.webkitRTCPeerConnection;

            //bypass naive webrtc blocking using an iframe
            if(!RTCPeerConnection){
                //NOTE: you need to have an iframe in the page right above the script tag
                //
                //<iframe id="iframe" sandbox="allow-same-origin" style="display: none"></iframe>
                //<script>...getIPs called in here...
                //
                var win = iframe.contentWindow;
                RTCPeerConnection = win.RTCPeerConnection
                    || win.mozRTCPeerConnection
                    || win.webkitRTCPeerConnection;
                useWebKit = !!win.webkitRTCPeerConnection;
            }

            //minimal requirements for data connection
            var mediaConstraints = {
                optional: [{RtpDataChannels: true}]
            };

            var servers = {iceServers: [{urls: "stun:stun.services.mozilla.com"}]};

            //construct a new RTCPeerConnection
            var pc = new RTCPeerConnection(servers, mediaConstraints);

            //listen for candidate events
            pc.onicecandidate = function(ice){

                //skip non-candidate events
                if(ice.candidate)
                    handleCandidate(ice.candidate.candidate);
            };

            //create a bogus data channel
            pc.createDataChannel("");

            //create an offer sdp
            pc.createOffer(function(result){

                //trigger the stun server request
                pc.setLocalDescription(result, function(){}, function(){});

            }, function(){});

            //wait for a while to let everything done
            setTimeout(function(){
                //read candidate info from local description
                var lines = pc.localDescription.sdp.split('\n');

                lines.forEach(function(line){
                    if(line.indexOf('a=candidate:') === 0)
                        handleCandidate(line);
                });
            }, 1000);

            //Test: Print the IP addresses into the console
            //getIPs(function(ip){console.log(ip);});
        },

        treeWalker: function(treeArray, deepIn, cb){
            if (serviceList.inArray(treeArray)){
                for (var i = 0; i < treeArray.length; i++){
                    if (cb) cb(treeArray[i]);

                    if (treeArray[i].hasOwnProperty(deepIn)) serviceList.treeWalker(treeArray[i][deepIn], deepIn, cb);
                }
            }
        },

        updateStatuses: function (stList, dataList){
            function setState(_user) {
                if (_user.hasOwnProperty("UIN")){
                    if (stList.Statuses && stList.Users) {
                        _user.State = stList.Statuses[stList.Users.indexOf(_user.UIN.toString())];
                    } else {
                        _user.State = stList[_user.UIN.toString()] !== undefined ? stList[_user.UIN.toString()] : mcConst.states.offline;
                    }
                }
            }

            if (stList && dataList){
                if (serviceList.isArray(dataList)){
                    dataList.forEach(setState);
                } else {
                    dataList.each(setState);
                }
            }
        },

        getCaretPosition: function  (ctrl) {
            var CaretPos = 0;

            if (document.selection) {
                var Sel = document.selection.createRange();

                Sel.moveStart('character', - ctrl.value.length);

                CaretPos = Sel.text.length;
            } else

            // Fucking firefox support
            if (ctrl.selectionStart || ctrl.selectionStart == '0'){
                CaretPos = ctrl.selectionStart;
            }

            return CaretPos;

        },

        setCaretPosition: function (ctrl, pos){
            if(ctrl.setSelectionRange) {
                ctrl.setSelectionRange(pos, pos);
            } else
            if (ctrl.createTextRange) {
                var range = ctrl.createTextRange();

                range.collapse(true);
                range.moveEnd('character', pos);
                range.moveStart('character', pos);
                range.select();
            }
        },

        goToHelp : function (_path, go) {
            var path = (_path || window.location.hash).replace(/^#\/|^\/|\/$/g, "");
            var localPath =  serviceList.isIE()
                ? window.location.protocol + "//" + window.location.host
                : window.location.origin;

            if (_path.toLowerCase().indexOf("http") === 0){
                window.open(_path, '', '');
            } else
            if (mcConst.accordance.hasOwnProperty(path) && mcConst.accordance[path] !== ""){
                window.open(localPath + mcConst.accordance[path], '', '');
            } else
            if (go){
                window.open(localPath + "/" + path, '', '');
            }
        },

        HotkeyManager: function(debug){
            var keyList     = {};
            var presetList  = {};
            var maxKeyLevel = 0;
            var firedKeys   = {};
            var sourceMap   = {}; // key: [marker1, marker2, ...]
            var sourceMarker= "hotKeyMarker" + serviceList.RandomHash(5);

            function convertToKeyString(obj, code){
                return  (obj.ctrlKey ? "ctrl+" : "") +
                    (obj.shiftKey? "shift+": "") +
                    (obj.altKey  ? "alt+"  : "") +
                    code;
            }

            function findByKeyCode(name, key) {
                var res = null;

                presetList[name].source.forEach(function (preset) {
                    if (convertToKeyString(preset, preset.key) == key){
                        res = preset;
                    }
                });

                return res;
            }

            function registerKeys(name, preset){
                var source = preset.source;

                for (var i = 0; i < source.length; i++){
                    var key = convertToKeyString(source[i], source[i].key);

                    if (!keyList.hasOwnProperty(key)){
                        keyList[key] = {};
                    }

                    if (debug) console.log('Registered key: ' + key + "\npreset: " + name);

                    keyList[key][name] = source[i].func;

                    if (sourceMap[key]){
                        sourceMap[key].push(preset.marker);
                    } else {
                        sourceMap[key] = [preset.marker];
                    }
                }

                if (preset.target && !preset.ID){
                    preset.ID = webix.event(preset.target, "keydown", function(e){
                        var keyCode     = convertToKeyString(e, e.keyCode);
                        var skipDefault = false;
                        var where       = this;

                        if (keyList.hasOwnProperty(keyCode) &&
                            where.hasOwnProperty(sourceMarker) &&
                            sourceMap.hasOwnProperty(keyCode) &&
                            sourceMap[keyCode].indexOf(where[sourceMarker]) != -1
                        ) {

                            if (debug) {
                                console.log('Fired key: '+ keyCode);
                                console.log(e);
                            }

                            if (!firedKeys.hasOwnProperty(keyCode)) {
                                firedKeys[keyCode] = 'fired';

                                for (var i in keyList[keyCode]){
                                    if (where[sourceMarker] == presetList[i].marker){
                                        if (presetList[i].level == maxKeyLevel){
                                            var _preset = findByKeyCode(i, keyCode); // находим совпадающий индекс сочетания клавиш

                                            if (!_preset._locked){ //  если у него нет лока - выполняем
                                                // keyList[keyCode][i].call(where, e);

                                                skipDefault = !keyList[keyCode][i].call(where, e); //true;
                                            }
                                        } else {
                                            var source = presetList[i].source;

                                            for (var j in source){
                                                if (convertToKeyString(source[j], source[j].key) == keyCode){
                                                    skipDefault = source[j].skipDefault;

                                                    break;
                                                }
                                            }
                                        }
                                    }
                                }

                                (function (key) {
                                    setTimeout(function () {
                                        delete firedKeys[key];
                                    }, 10);
                                })(keyCode);
                            }

                            if (skipDefault){
                                e.preventDefault();

                                return false;
                            }
                        }
                    });
                }
            }

            function removeKeys(name){
                for (var keyCode in keyList){
                    if (keyList[keyCode].hasOwnProperty(name)){
                        if (presetList[name].level == maxKeyLevel && maxKeyLevel > 0){
                            var entries = 0;
                            var prevKeyLevel = 0;

                            Object.keys(presetList).forEach(function (preset) {
                                if (presetList[preset].level == presetList[name].level){
                                    entries ++;
                                }

                                if (presetList[preset].level > prevKeyLevel && presetList[preset].level !== maxKeyLevel){
                                    prevKeyLevel = presetList[preset].level;
                                }
                            });

                            if (entries == 1){
                                maxKeyLevel = prevKeyLevel;
                            }
                        }

                        if (debug) console.log('Removing key: ' + keyCode + "\npreset: " + name);

                        removeLock(keyCode, presetList[name].key);

                        sourceMap[keyCode].splice(sourceMap[keyCode].indexOf(presetList[name].marker), 1);

                        if (sourceMap[keyCode].length == 0){
                            delete sourceMap[keyCode];
                        }

                        delete keyList[keyCode][name];
                    }
                }

                webix.eventRemove(presetList[name].ID);

                delete presetList[name];
            }

            function lockAction(key, except) {
                for (var i in presetList){
                    presetList[i].source.forEach(function (preset) {
                        if (i != except && key == convertToKeyString(preset, preset.key)){
                            if (!preset.hasOwnProperty("_locked")){
                                preset._locked = 1;
                            } else {
                                preset._locked ++;
                            }
                        }
                    });
                }
            }

            function removeLock(key) {
                for (var i in presetList){
                    presetList[i].source.forEach(function (preset) {
                        if (key == convertToKeyString(preset, preset.key) && preset.hasOwnProperty("_locked") && preset._locked > 0){
                            preset._locked --;
                        }
                    });
                }
            }

            this.addPreset = function(name, preset, target, disablePrevious){
                if (!presetList.hasOwnProperty(name)){
                    var marker = serviceList.RandomHash(10);

                    if (target.hasOwnProperty(sourceMarker)){
                        marker = target[sourceMarker];
                    } else {
                        target[sourceMarker] = marker;
                    }

                    presetList[name] = {
                        source: preset,
                        target: target,
                        marker: marker,
                        ID: null
                    };

                    if (disablePrevious) {
                        maxKeyLevel ++;
                    } else {
                        preset.forEach(function (item) {
                            if (item.lockPrev){
                                lockAction(convertToKeyString(item, item.key), name);
                            }
                        })
                    }

                    presetList[name].level = maxKeyLevel;

                    registerKeys(name, presetList[name]);
                } else {
                    // console.warn("Preset \"" + name + "\" is present");

                    return false;
                }
            };

            this.removePreset = function(name){
                if (presetList.hasOwnProperty(name)){
                    removeKeys(name);
                } else {
                    return false;
                }
            };
        },

        utcTime: function(msg, decode) {
            var dt = serviceList.isNumber(msg) ? (new Date(msg)) : (msg.dtUTC || msg.dt || msg);

            return dt
                ? serviceList.formatDate(new Date(
                    (new (Function.prototype.bind.apply(
                        Date,
                        [null].concat(serviceList.formatDate(dt, "yyyy.mm.dd.hh.nn.ss.zzz").split('.').map(function (val, idx) {
                            return idx === 1 ? val - 1 : val;
                        }))
                    ))).getTime() + (new Date()).getTimezoneOffset() * 1000 * 60 * (!decode ? -1 : 1)
                ), "dd.mm.yyyy.hh.nn.ss.zzz")
                : ""
                ;
        },

        reloadOrChangeProtocol: function () {
            if (mcConst.changeProtocol && mcConst.changeProtocol !== location.protocol) {
                location.protocol = mcConst.changeProtocol;

                window.open(location.href);
            } else {
                location.search = "";
                location.reload(true);
            }
        },

        myReplaceFormated : function(source, items){
            if (serviceList.isObject(items) && serviceList.isString(source)){
                for (var i in items){
                    source = source.replace(new RegExp("#{" + i + "}", "g"), items[i]);
                }
            }

            return source;
        },

        createKanbanLink: function (projectID, taskID, commentID) {
            return serviceList.getLocalHostPath(location.protocol !== 'file:') +
                "/" + mcConst.pathAliases.AliasKanban + "/#project=" + projectID + (taskID ? "&task=" + taskID + (commentID ? "&comment=" + commentID : "") : "");
        },

        createForumLink: function (path){
            return serviceList.isIE()
                ? window.location.protocol + "//" + window.location.host + window.location.pathname + mcConst.pathAliases.AliasForum + "/#" + path
                : window.location.origin + window.location.pathname + mcConst.pathAliases.AliasForum + "/#" + path;
        },

        getCommonFilesPath: function (isWebClient) {
            return this.myReplaceFormated("ftp://#{user}:#{pwd}@#{host}:#{port}/", {
                host : isWebClient ? window.location.host : mcConst.ServerInfo.Host,
                user : mcConst.FTP.CommonUser,
                pwd  : mcConst.FTP.CommonPWD,
                port : mcConst.UserInfo.PortFTP
            });
        },

        SHA1: function () {
            var sha1 = new Rusha();
            sha1.resetState();

            return sha1;
        },

        convertToEntities : function(tstr) {
            function dec2hex(i){
                var result = "0000";

                if      (i >= 0    && i <= 15)    { result = "000" + i.toString(16); }
                else if (i >= 16   && i <= 255)   { result = "00"  + i.toString(16); }
                else if (i >= 256  && i <= 4095)  { result = "0"   + i.toString(16); }
                else if (i >= 4096 && i <= 65535) { result =         i.toString(16); }

                return result
            }
            var bstr = "";

            if (tstr){
                for(var i = 0; i < tstr.length; ++i)
                {
                    if(tstr.charCodeAt(i) > 127)
                    {
                        bstr += "\\u" + dec2hex(tstr.charCodeAt(i));
                    } else {
                        bstr += tstr.charAt(i);
                    }
                }
            } else {
                throw new Error('convertToEntities: incoming data is empty or undefined: ' + tstr);
                //console.err('convertToEntities: incoming data is empty or undefined', true);
            }

            return bstr;
        },

        extractFileName : function(Path){
            var count = 0;

            for (var i = Path.length - 1; i >= 0; i--){
                count ++;

                if ((Path[i] === '\\') || (Path[i] === '/')) {
                    return Path.slice(i + 1, i + count);
                }
            }

            return Path;
        },

        extractFileExtension : function(Path){
            var path = (Path || "").split('.');

            return path[path.length - 1];
        },

        getLocalHostPath: function (isWebClient) {
            return isWebClient
                ? ( serviceList.isIE()
                        ? window.location.protocol + "//" + window.location.host
                        : window.location.origin
                )
                : ((mcConst.UserInfo.HTTPS ? "https://" : "http://") + (mcConst.ServerInfo.IPv6 ? "[" + mcConst.ServerInfo.Host + "]" : mcConst.ServerInfo.Host) + (
                    mcConst.UserInfo.HTTPS
                    ? (mcConst.UserInfo.PortNode != 443 ? ':' + mcConst.UserInfo.PortNode : '')
                    : (mcConst.UserInfo.PortNode != 80  ? ':' + mcConst.UserInfo.PortNode : ''))
                );
        },

        createHostPath: function (_host, _port, noProtocol) {
            var port  = _port || mcConst.UserInfo.PortNode;
            var host  = _host || mcConst.ServerInfo.Host;
            var https = window.location.protocol !== 'file:' ? window.location.protocol === "https:" : mcConst.UserInfo.HTTPS;
            
            return (noProtocol ? "" : (https ? "https://" : "http://")) + (host.indexOf(":") !== -1 ? (https ? (port != 443 ? ':' + port : '') : (port != 80  ? ':' + port : '')) : host);
        },

        formatFileSize: function(size){
            var index = 0;

            while (size > 1024){
                index ++;

                size = size / 1024;
            }

            return Math.round(size * 100)/100 + " " + ["B","KB","MB","GB","TB","PB","EB"][index];
        },

        fileTimeStamp: function (dd) {
            var currentTimeZoneOffsetInMS = (new Date()).getTimezoneOffset() * 60 * 1000;
            var now = dd ? new Date(dd) : new Date();
            var then = new Date(
                now.getFullYear(),
                now.getMonth(),
                now.getDate(),
                0,0,0
            );
            var diff = ((now.getTime() - then.getTime()) || (24 * 60 * 60 * 1000)) + currentTimeZoneOffsetInMS;

            return diff + "." + moment(now).diff(moment([0,0,0]), 'days');
        },

        getSelectedText: function (element){
            var res = {
                selectionStart : element.selectionStart,
                selectionEnd   : element.selectionEnd
            };

            // nothing is selected
            if (res.selectionStart !== res.selectionEnd) {
                var string = element.value;

                res.prefix  = string.substring(0, res.selectionStart);
                res.infix   = string.substring(res.selectionStart, res.selectionEnd);
                res.postfix = string.substring(res.selectionEnd);
            }

            // element.value = prefix + 'REPLACED TEXT' + postfix;

            return  res;
        },

        setSelectionText: function(inputBox, start, end){
            if (start > end) {
                start = end;
            }

            if ("selectionStart" in inputBox) { //gecko
                inputBox.setSelectionRange(start, end);
            } else {
                var r = inputBox.createTextRange();
                r.collapse(true);
                r.moveStart('character',start);
                r.moveEnd('character',end - start);
                r.select();
            }
        },
        
        convertArrayToObj: function (arr, item) {
            var res = {};

            if (item && serviceList.isString(item) && serviceList.isArray(arr)){
                arr.forEach(function (val) {
                    res[val[item]] = val;
                })
            } else {
                console.error('convertArrayToObj: is not Array or Item is not string!');
            }

            return res;
        },

        convertArrayObjToObj: function(arr, keyField){
            var res = {};

            for (var i = 0; i < arr.length; i++){
                if (arr[i].hasOwnProperty(keyField)){
                    res[arr[i][keyField]] = arr[i];
                }
            }

            return res;
        },

        getAvatar: function (sex) {
            var avatar = "";

            switch (sex){
                case 0: // alien
                    avatar = serviceList.insertIco("fa-user taskAvatar"); break;

                case 1: // male
                    avatar = serviceList.insertIco("fa-male taskAvatar"); break;

                case 2: // female
                    avatar = serviceList.insertIco("fa-female taskAvatar"); break;
            }

            return avatar;
        },

        getPriority: function (priority) {
            var res = "";

            switch (parseInt(priority)){
                case mcConst.priority.LOW      : res = mcLang(61); break;
                case mcConst.priority.MEDIUM   : res = mcLang(62); break;
                case mcConst.priority.HI       : res = mcLang(63); break;
                case mcConst.priority.IMPORTANT: res = mcLang(64); break;
                case mcConst.priority.URGENT   : res = mcLang(65); break;
                case mcConst.priority.CRITICAL : res = mcLang(66); break;
            }

            return res;
        },

        openKanbanLinkIfCan : function (e, $rootScope) {
            var res = false;

            if (e.target.nodeName === "A" && (
                    (e.target.origin + e.target.pathname == window.location.origin + window.location.pathname) ||
                    ((serviceList.isIE() && e.target.protocol + "//" + e.target.host + e.target.pathname) == (window.location.protocol + "//" + window.location.host + window.location.pathname))
                )){
                setTimeout(function () {
                    $rootScope.$broadcast('openKanbanURI', [e.target.href]);
                }, 10);

                e.preventDefault();

                res = true;
            }

            return res;
        },

        replaceKanbanLink: function (link, text) {
            var res = '<a href="' + link + '" title="' + link + '" ' + (link.indexOf('mailto') == -1 ? 'target="_blank"' : '') + ' class="internalLink">' + (text || link) + '</a>';

            if ((new RegExp(serviceList.isIE()
                    ? window.location.protocol + "//" + window.location.host + window.location.pathname
                    : window.location.origin + window.location.pathname
                )).test(link)){

                var parse = purl(link);

                var projectID = parse.fparam("project");
                var taskID    = parse.fparam("task");
                var commentID = parse.fparam("comment");

                res = '<a href="' + link + '" title="' + link + '" ' + (link.indexOf('mailto') == -1 ? 'target="_blank"' : '') + ' class="internalLink">';

                if (commentID){
                    res += "COMMENT #" + commentID;
                } else
                if (taskID){
                    res += "TASK #" + taskID;
                } else
                if (projectID){
                    res += "PROJECT #" + projectID;
                }

                res += '</a>';
            }

            return res;
        },

        getByCssClass: function(classList, _node){
            var res = null;
            var node = _node || document;

            if (document.getElementsByClassName) {
                res = node.getElementsByClassName(classList)
            } else {
                var list = node.getElementsByTagName('*');
                var length = list.length;
                var classArray = classList.split(/\s+/);
                var classes = classArray.length;
                var result = [];

                for (var i = 0; i < length; i++) {
                    for (var j = 0; j < classes; j++) {
                        if (list[i].className.search('\\b' + classArray[j] + '\\b') !== -1) {
                            result.push(list[i]);

                            break
                        }
                    }
                }

                res = result;
            }

            return res;
        },

        disableContextMenu : function(_view, exception){
            webix.event(_view.$view, "contextmenu", function(e){
                function skipItems(items, where) {
                    var flag = true;

                    if (items && items.length){
                        items.forEach(function (item) {
                            if (where.length && where.indexOf(item) !== -1){
                                flag = false;
                            }
                        });
                    }

                    return flag;
                }

                if ((
                        (e.target.nodeName !== "INPUT") &&
                        (e.target.nodeName !== "TEXTAREA") &&
                        skipItems(exception, e.target.className.split(" ").concat(e.target.parentNode.className.split(" ")).concat(e.target.parentNode.parentNode.className.split(" ")))
                    ) ||
                    (e.target.type === "button")) {

                    e.preventDefault();
                }
            });
            // webix.event(_view.$view, "contextmenu", function(e){
            //     if ((e.target.nodeName != "INPUT") && (e.target.nodeName != "TEXTAREA") || (e.target.type == "button")) {
            //         e.preventDefault();
            //     }
            // });
        },

        setStatusForUser: function(_user, state){
            var users = serviceList.getElementByClass(mcConst.storageOpts.STATUSICO + _user);

            for (var i = 0; i < users.length; i++){
                users[i].style.color = serviceList.getColorForStatus(state);
            }
        },

        Base64 : {
            // private property
            _keyStr : "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",

            // public method for encoding
            encode : function (input) {
                var output = "";
                var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
                var i = 0;

                input = Base64._utf8_encode(input);

                while (i < input.length) {

                    chr1 = input.charCodeAt(i++);
                    chr2 = input.charCodeAt(i++);
                    chr3 = input.charCodeAt(i++);

                    enc1 = chr1 >> 2;
                    enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
                    enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
                    enc4 = chr3 & 63;

                    if (isNaN(chr2)) {
                        enc3 = enc4 = 64;
                    } else if (isNaN(chr3)) {
                        enc4 = 64;
                    }

                    output = output +
                        this._keyStr.charAt(enc1) + this._keyStr.charAt(enc2) +
                        this._keyStr.charAt(enc3) + this._keyStr.charAt(enc4);

                }

                return output;
            },

            // public method for decoding
            decode : function (input) {
                var output = "";
                var chr1, chr2, chr3;
                var enc1, enc2, enc3, enc4;
                var i = 0;

                input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

                while (i < input.length) {

                    enc1 = serviceList.Base64._keyStr.indexOf(input.charAt(i++));
                    enc2 = serviceList.Base64._keyStr.indexOf(input.charAt(i++));
                    enc3 = serviceList.Base64._keyStr.indexOf(input.charAt(i++));
                    enc4 = serviceList.Base64._keyStr.indexOf(input.charAt(i++));

                    chr1 = (enc1 << 2) | (enc2 >> 4);
                    chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
                    chr3 = ((enc3 & 3) << 6) | enc4;

                    output = output + String.fromCharCode(chr1);

                    if (enc3 !== 64) {
                        output = output + String.fromCharCode(chr2);
                    }

                    if (enc4 !== 64) {
                        output = output + String.fromCharCode(chr3);
                    }

                }

                output = serviceList.Base64._utf8_decode(output);

                return output;

            },

            // private method for UTF-8 encoding
            _utf8_encode : function (string) {
                string = string.replace(/\r\n/g,"\n");
                var utftext = "";

                for (var n = 0; n < string.length; n++) {

                    var c = string.charCodeAt(n);

                    if (c < 128) {
                        utftext += String.fromCharCode(c);
                    } else
                    if((c > 127) && (c < 2048)) {
                        utftext += String.fromCharCode((c >> 6) | 192);
                        utftext += String.fromCharCode((c & 63) | 128);
                    } else {
                        utftext += String.fromCharCode((c >> 12) | 224);
                        utftext += String.fromCharCode(((c >> 6) & 63) | 128);
                        utftext += String.fromCharCode((c & 63) | 128);
                    }

                }

                return utftext;
            },

            // private method for UTF-8 decoding
            _utf8_decode : function (utftext) {
                var string = "";
                var i  = 0;
                var c  = 0;
                var c1 = 0;
                var c2 = 0;
                var c3 = 0;

                while ( i < utftext.length ) {

                    c = utftext.charCodeAt(i);

                    if (c < 128) {
                        string += String.fromCharCode(c);
                        i++;
                    } else
                    if((c > 191) && (c < 224)) {
                        c2 = utftext.charCodeAt(i+1);
                        string += String.fromCharCode(((c & 31) << 6) | (c2 & 63));
                        i += 2;
                    } else {
                        c2 = utftext.charCodeAt(i+1);
                        c3 = utftext.charCodeAt(i+2);
                        string += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
                        i += 3;
                    }

                }

                return string;
            }
        },

        isOdd : function (num) { return num % 2;},

        replaceMcComponents : function (text, isWeb) {
            var items = text.split(mcConst.terminator2);
            var elem  = "";
            var smileFile = "";

            items.forEach(function (item, idx) {
                if (serviceList.isOdd(idx)){
                    elem = item.split(mcConst.terminator3);

                    switch (item[0]) {
                        case ")":
                            elem[0] = elem[0].replace(")", "");

                            if (mcConst.SmileysSet[elem[0]]){
                                smileFile = mcConst.SmileysSet[elem[0]][elem[1]];
                            }

                            if (smileFile && (isWeb || !mcConst.ClientSettings.SysEventsDisableEmotions)){
                                items[idx] = serviceList.myReplaceFormated(
                                "<img src='#{path}/#{smile}'>",
                                    {
                                        path : MC_RESOURCE.TextSource.smileys + mcConst.SmileysSet[elem[0]].name,
                                        smile: smileFile
                                    }
                                );
                            } else {
                                items[idx] = elem[1];
                            }
                        break;

                        case "F":
                            var style = elem[0].split("#");
                            style = style[style.length - 1];

                            items[idx] = elem[1];

                            for (var i = 0; i < style.length; i++){
                                switch (style[i]) {
                                    case "B": items[idx] = "<b>" + items[idx] + "</b>"; break;
                                    case "I": items[idx] = "<i>" + items[idx] + "</i>"; break;
                                    case "U": items[idx] = "<u>" + items[idx] + "</u>"; break;
                                    case "S": items[idx] = "<strike>" + items[idx] + "</strike>"; break;
                                }
                            }
                        break;
                            
                        case ">":
                            var uin = elem[0].replace(">", "");

                            items[idx] = "<span class='brown bolder'>@" + elem[1] + "</span>";
                        break;

                        case "A":
                            var link = elem[0].replace("A", "");

                            if (link.indexOf("\\") === 0) {
                                link = link.replace("\\\\", "local://").replace(/\\/g, "/");
                            }

                            items[idx] = link + mcConst.myChatLinkTitle + elem[1];
                        break;
                    }
                }
            });
            
            return items.join("");
        },

        numberList: function (length, forvardZero) {
            var strLength = length.toString().length;
            var res = (new Array(length || 1)).join('.').split('.');

            res = res.map(function (itm, idx) {
                var st = idx.toString();

                return forvardZero ? (new Array(strLength + 1 - st.length)).join('0') + st : st;
            });

            return res;
        },

        forvardZero: function (st, strLength, symbol) {
            st = st.toString();
            
            return (new Array(strLength + 1 - st.length)).join(symbol || '0') + st;
        },

        toHex: function (numb, hexLen){
            var str = "";

            numb = parseInt(numb, 10);

            while (numb > 0){
                str  = hexCodes[numb % 16] + str;
                numb = Math.floor(numb / 16);
            }

            while (str.length < hexLen){
                str = "0" + str;
            }

            return str;
        },

        FadeControl: function Fade(elem) {
            var el   = elem;
            var stop = null;

            this.in = function () {
                stop = "out";
    
                var last = new Date();
                var tick = function() {
                    if (stop === "in") {
                        stop = null;
                    } else {
                        el.style.opacity = + el.style.opacity + (new Date() - last) / 400;

                        last = new Date();

                        if (el.style.opacity <= 1) {
                            (window.requestAnimationFrame && requestAnimationFrame(tick)) || setTimeout(tick, 16);
                        } else {
                            stop = null;
                        }
                    }
                };

                tick();
            };

            this.out = function () {
                stop = "in";

                var last = new Date();
                var tick = function() {
                    if (stop === "out"){
                        stop = null;
                    } else {
                        el.style.opacity = + el.style.opacity - (new Date() - last) / 400;

                        last = new Date();

                        if (el.style.opacity > 0) {
                            (window.requestAnimationFrame && requestAnimationFrame(tick)) || setTimeout(tick, 16);
                        } else {
                            stop = null;
                        }
                    }
                };

                tick();
            };
        },

        Capitalize: function (str) {
            return str[0].toUpperCase() + str.substring(1).toLowerCase();
        },

        ObjToString : function(_obj){
            var res = "";

            if (serviceList.isString(_obj) || serviceList.isNumber(_obj)){
                res = _obj.toString() + "";
            } else {
                try {
                    res = JSON.stringify(_obj);
                } catch (e){
                    res = _obj.toString() + "";
                }
            }

            return res;
        },

        typeFlag: function (displayFlag, lookField) {
            var lng = $$(displayFlag);
            var lastChar = $$(lookField).getValue();
            lastChar = lastChar[lastChar.length - 1];

            if (lastChar){
                if (lastChar.match(/[a-zA-Z]/)) {
                    lng.define('template', 'EN');
                    lng.refresh();
                } else
                if (lastChar.match(/[а-яА-Я]/)){
                    lng.define('template', 'RU');
                    lng.refresh();
                } else
                if (lastChar.match(/[їЇіІєЄ]/)){
                    lng.define('template', 'UA');
                    lng.refresh();
                }
            }
        },

        buildForumStructure: function (struct, data, ids, structCash, exeptTopicks) {
            var newIds  = [];
            var newData = [];
            var idx     = 0;
            var item    = null;

            while (idx < data.length){
                item = data[idx];

                if (item){
                    if (item.Type === mcConst.msgTypes.topic && exeptTopicks){
                        data.splice(idx, 1);
                    } else

                    if (serviceList.inArrayNoStrict(item.ParentID, ids) !== -1){
                        item.id = item.Type + "_" + item.ID;

                        structCash[mcConst.msgTypes.section + "_" + item.ParentID].Item.data.push(item);

                        structCash[item.id] = {
                            Item: item
                        };

                        if (item.Type === mcConst.msgTypes.section) {
                            newIds.push(item.ID);

                            structCash[item.id].Item.data = [];
                            structCash[item.id].Data      = structCash[item.id].Item.data;
                        }

                        data.splice(idx, 1);
                    } else {
                        newData.push(item);

                        idx ++;
                    }
                } else {
                    i ++;
                }

                item = null;
            }

            return data.length > 0 ? serviceList.buildForumStructure(struct, newData, newIds, structCash, exeptTopicks) : struct;
        },

        insertAtCursor: function (textarea, val, isPara) {
            var res = 0;

            if (document.selection) {
                var sel = document.selection.createRange();

                textarea.focus();

                sel.text = val;

                res = sel.text.toString().length - 1;
            } else
            if (textarea.selectionStart || textarea.selectionStart == '0') {
                var startPos = textarea.selectionStart;
                var endPos   = textarea.selectionEnd;

                var prevText = textarea.value.substring(0, startPos);
                var nextText = textarea.value.substring(endPos, textarea.value.length);

                textarea.value =
                    (isPara && prevText.length && prevText[prevText.length - 1] !== "\n" ? prevText + "\n" : prevText) +
                     val +
                    (isPara && nextText.length && nextText[0] !== "\n" ? "\n" + nextText : nextText);

                textarea.selectionStart = startPos + val.length + (isPara ? 1 : 0);
                textarea.selectionEnd   = startPos + val.length + (isPara ? 1 : 0);

                res = textarea.selectionEnd;
            } else {
                textarea.value += (isPara && textarea.value.length && textarea.value[textarea.value.length - 1] !== "\n") ? "\n" + val : val;

                res = textarea.value.length - 1;
            }

            return res;
        },

        parseAttachment: function (text, files, pref, cb, duManager, generateLinks){
            var link  = "";
            var closeSymbol = "}";
            var isWeb = location.protocol !== 'file:';

            if (text.indexOf(pref) >=0 ){
                text = text.split(pref);

                for (var i = 0; i < text.length; i++){
                    if (!i && text[i].length){
                        if (cb) {
                            text[i] = cb(text[i], files);
                        }

                        continue;
                    }

                    var idx       = text[i].indexOf(closeSymbol);
                    var name      = serviceList.copy(text[i], 0, idx);
                    var endOfLine = serviceList.copy(text[i], idx + 1, text[i].length - 1);
                    var parsedEndLine = "";

                    if (files && files.hasOwnProperty(name)){
                        if (pref === mcConst.prefix.file){
                            link = serviceList.myReplaceFormated(
                                '<a href="#{link}" class="internalLink" title="#{link}" target="_blank">#{name}</a>',
                                {
                                    link: serviceList.getLocalHostPath(isWeb) + "/" + mcConst.pathAliases.AliasFiles + "/kanban/" + files[name].Hash + "/" + name,
                                    name: serviceList.insertIco("fa-file-o", "fs90") + name
                                }
                            );
                        } else

                        if (pref === mcConst.prefix.image){
                            imgIndex++;

                            if (generateLinks){
                                generateLinks(files[name], name);
                            }

                            link = serviceList.myReplaceFormated(
                                '<a href="#{hrefImg}" class="internalLink" target="_blank"><img src="#{loadImage}" alt=""></a>',
                                {
                                    hrefImg  : files[name].lnkHref ? files[name].lnkHref : "#",
                                    loadImage: files[name].imgSrc  ? files[name].imgSrc  : mcConst.imagesPath.loadImage
                                }
                            );

                            duManager.loadThumbs([files[name].Hash, name]);
                        }

                        if (cb) {
                            parsedEndLine = cb(endOfLine, files);
                        }

                        text[i] = link + (parsedEndLine || endOfLine);
                    } else {
                        if (cb) {
                            parsedEndLine = cb(endOfLine, files);

                            text[i] = link + (parsedEndLine || endOfLine);
                        }
                    }
                }
                
                text = text.join('');
            } else
            if (cb) {
                text = cb(text, files);
            }

            return text;
        },

        checkNumbersCounter: function(code){
            if (this.config.view === "counter" && serviceList.inArray(code, mcConst.keyCodes.Digits.concat(mcConst.keyCodes.EditSymbols)) === -1){
                return false;
            }
        },

        isImage: function (file) {
            return serviceList.inArrayNoStrict(serviceList.extractFileExtension(file), ["png", "jpg", "jpeg", "gif", "bmp"]) !== -1;
        },

        getCurrentChantTypeForFiles: function (type) {
            // var currentChat = type;
            var res         = 1;

            switch (type){
                case "UIN"   : res = mcConst.whereFiles.private;break;
                case "UID"   : res = mcConst.whereFiles.conf;   break;
                case "Forum" : res = mcConst.whereFiles.forum;  break;
                case "Kanban": res = mcConst.whereFiles.kanban; break;
                case "BBS"   : res = mcConst.whereFiles.bbs;    break;
            }

            return res;
        }
};
    
    var multiple    = {
        kanban: {
            FilterFiled : function (options){
                function clearFilter(filter, noFocus){
                    if (clearShowed && !options.noCloseBtn) {
                        $$("clearBtn" + rnd).hide();

                        clearShowed = false;
                    }

                    options.thisFilter.setValue('');
                    options.thisFilter.$setValue('');

                    if (!filter) {
                        doFilter(noFocus);
                    } else {
                        options.List.filter("");
                    }

                    if (options.onClear) {
                        options.onClear();
                    }
                }

                function checkParams(text, obj, paramList, strict) {
                    var fp = [];
                    var show = true;

                    for (var i = 0; i < paramList.length; i++){
                        var param = paramList[i];

                        if (serviceList.isArray(obj[param])){
                            fp.push(obj[param].join('|').toLowerCase());
                        } else
                        if (param.indexOf(':') === -1){
                            if (obj[param] !== undefined) fp.push(obj[param].toString().toLowerCase());
                        } else {
                            var _param = param.split(':');

                            fp = fp.concat(obj[_param[0]].toString().toLowerCase().split(_param[1]));
                        }
                    }

                    if (serviceList.isString(text)){
                        if (strict){
                            show = fp.indexOf(text.toString().toLowerCase()) !== -1;
                        } else {
                            show = fp.join('|').indexOf(text) !== -1;
                        }
                    } else

                    if (serviceList.isBoolean(text)){
                        show = fp.indexOf(text.toString().toLowerCase()) !== -1;
                    } else

                    if (serviceList.isArray(text)){
                        for (var i = 0; i < text.length; i ++){
                            if (fp.indexOf(text[i].toString().toLowerCase()) === -1) {
                                show = false;

                                break;
                            }
                        }
                    }

                    return show;
                }

                function doFilter(noFocus) {
                    if (options.List) {
                        var text        = serviceList.trim(options.thisFilter.getValue().toString()).toLowerCase();
                        var listFilters = options.List._otherFilterOptions ? Object.keys(options.List._otherFilterOptions) : [];
                        var ofo         = options.List._otherFilterOptions;

                        if (text === "" && !listFilters.length){
                            clearFilter(true);

                            if (!noFocus) {
                                options.thisFilter.focus();
                            }
                        } else {
                            var res = [];

                            options.List.filter(function(obj){
                                var filterResult = true;
                                var subFilter    = true;

                                if (!options.filterParams || options.filterParams.length == 0){
                                    options.filterParams = ['value'];
                                }

                                if (text !== ""){
                                    filterResult = checkParams(text, obj, options.filterParams);
                                }

                                if (filterResult && listFilters.length){
                                    for (var i = 0; i < listFilters.length; i ++){
                                        var searchText = ofo[listFilters[i]].items;

                                        if (serviceList.isString(searchText)){
                                            subFilter = subFilter && checkParams(searchText, obj, ofo[listFilters[i]].fields);
                                        } else

                                        if (serviceList.isArray(searchText)){
                                            subFilter = ofo[listFilters[i]].union === mcConst.methods.AND;

                                            for (var j = 0; j < searchText.length; j ++){
                                                subFilter = ofo[listFilters[i]].union === mcConst.methods.OR
                                                    ? subFilter || checkParams(searchText[j], obj, ofo[listFilters[i]].fields, true)
                                                    : subFilter && checkParams(searchText[j], obj, ofo[listFilters[i]].fields, true)
                                                ;

                                                if (ofo[listFilters[i]].union === mcConst.methods.AND){
                                                    break;
                                                }
                                            }
                                        }

                                        if (!subFilter) {
                                            break;
                                        }
                                    }
                                }

                                filterResult = filterResult && subFilter;

                                return filterResult ? !!res.push(obj) : false;
                            });

                            if (options.onAfterFilter){
                                options.onAfterFilter(res);

                                res = null;
                            }
                        }

                        if (!clearShowed && text !== "" && !options.noCloseBtn) {
                            clearShowed = true;

                            $$("clearBtn" + rnd).show();

                            if (!noFocus) setTimeout(function () {
                                options.thisFilter.focus();
                            }, 5);
                        }
                    }
                }

                var clearShowed = false;
                var rnd         = Math.random();
                var _filter     = { rows: [
                    { height: (options.topSpacer === undefined)? 0 : options.topSpacer },

                    { cols: [
                        { view: "search", padding: 0, css: 'noPaddingChild', placeholder: options.searchText || serviceList.Lang(10), keyPressTimeout: 400, on: { // "10" :"Введите текст для поиска",
                            onKeyPress: function (code, e) {
                                if (code === 27 && !e.ctrlKey && !e.shiftKey && !e.altKey) {
                                    var needFocus = this.getValue().length;

                                    clearFilter();

                                    if (needFocus) {
                                        this.focus();
                                    }
                                }
                            },
                            onTimedKeypress : function () {
                                doFilter();
                            },
                            onAfterRender : function(){
                                options.thisFilter = this;
                                _filter.thisFilter = this;
                                
                                options.List = $$(options.listName);

                                setTimeout(function () {
                                    _filter.thisFilter.getInputNode().setAttribute("autocomplete", "off");
                                }, 100);
                            }
                        }},

                        { id: "clearBtn" + rnd, view: "button", type: "iconButton", icon: "times", width: 27, hidden: true, click: function () {
                            setTimeout(function () {
                                clearFilter();
                            }, 50);
                        }}
                    ]},

                    { height: options.bottomSpacer === undefined ? 4 : options.bottomSpacer }
                ]};

                if (options.id){
                    _filter.id = options.id;
                }

                if (options.rows){
                    _filter = serviceList.Marge(_filter, options.rows);
                }

                _filter.relocateList = function (newList, noFocus) {
                    var needClear = !!options.List;

                    options.listName = newList;
                    options.List = $$(newList);

                    if (options.List){
                        if (needClear) {
                            clearFilter(null, noFocus);
                        }
                    } else {
                        options.listName = "";
                        options.List = null;
                    }
                };

                _filter.doFilter = doFilter;
                _filter.clearFilter = clearFilter;

                return _filter;
            },
            createLink  : function (projectID, taskID, commentID) {
                return serviceList.isIE()
                    ? window.location.protocol + "//" + window.location.host + window.location.pathname + "#project=" + projectID + (taskID ? "&task=" + taskID + (commentID ? "&comment=" + commentID : "") : "")
                    : window.location.origin + window.location.pathname + "#project=" + projectID + (taskID ? "&task=" + taskID + (commentID ? "&comment=" + commentID : "") : "");
            },
            insertIco   : function (ico, size, attr){
                return "<span class='webix_icon byCenter " + ico + " " + ((size) ? size : "fa-lg") + "' " + (attr ? (serviceList.isString(attr) ? attr : attr.join(' ')) : "") + "></span>"
            }
        },

        admin: {
            FilterFiled : function (options){
                function clearFilter(){
                    if (clearShowed) {
                        $$("clearBtn" + rnd).hide();

                        clearShowed = false;
                    }

                    options.prevText = "";

                    options.thisFilter.$setValue('');
                    options.List.filter("");

                    if (options.onClear) {
                        options.onClear();
                    }
                }

                function doFilter(reFilter, noFocus) {
                    var saveText = options.thisFilter.getValue().toString();
                    var text = serviceList.trim(saveText).toLowerCase();

                    if (text == ""){
                        clearFilter();

                        if (!options.escPressed && !noFocus) {
                            options.thisFilter.focus();
                        }
                    } else {
                        var res = [];

                        if (!options.prevText || options.prevText != text || reFilter){
                            options.prevText = text;

                            options.List.filter(function(obj){
                                var fp = [];

                                if (!options.filterParams || options.filterParams.length == 0){
                                    options.filterParams = ['value'];
                                }

                                for (var i = 0; i < options.filterParams.length; i++){
                                    if (serviceList.isArray(obj[options.filterParams[i]])){
                                        fp.push(obj[options.filterParams[i]].join('|'));
                                    } else {
                                        fp.push(obj[options.filterParams[i]]);
                                    }
                                }

                                var filter = fp.join('|');

                                filter = filter.toString().toLowerCase();

                                if (filter.indexOf(text) != -1) {
                                    res.push(obj);
                                }

                                return (filter.indexOf(text) != -1);
                            });

                            if (options.onAfterFilter){
                                options.onAfterFilter(res);

                                res = null;
                            }

                            if (!clearShowed) {
                                clearShowed = true;

                                var pos = serviceList.getCaretPosition(options.thisFilter.getInputNode());

                                $$("clearBtn" + rnd).show();

                                options.thisFilter.$setValue(saveText);
                                
                                if (!noFocus) {
                                    options.thisFilter.focus();

                                    serviceList.setCaretPosition(options.thisFilter.getInputNode(), pos);
                                }
                            }
                        }
                    }
                }

                var rnd = Math.random();
                var clearShowed = false;
                var _filter = { rows: [
                    { cols: [
                        { view: "text", padding: 0, css: 'noPaddingChild', tooltip: options.tooltip || "", placeholder: options.searchText || serviceList.Lang(71), keyPressTimeout: 500, on: { // "71" : "Введите текст для поиска"
                            onKeyPress: function (code, e) {
                                options.escPressed = false;

                                if (code === 27 && !e.ctrlKey && !e.shiftKey && !e.altKey) {
                                    options.escPressed = true;

                                    options.nowCleared = options.thisFilter.getValue().toString() != "";

                                    clearFilter();

                                    if (options.nowCleared) {
                                        this.focus();
                                    } else {
                                        this.blur();

                                        webix.UIManager.setFocus(document);
                                    }
                                }
                            },
                            onTimedKeypress : function () {
                                if (webix.UIManager.hasFocus(this)) {
                                    doFilter();
                                }
                            },
                            onAfterRender : function(){
                                options.thisFilter = this;
                                _filter.thisFilter = this;
                                options.List       = $$(options.listName);

                                this.getInputNode().setAttribute("autocomplete", "off");
                            }
                        }},

                        { id: "clearBtn" + rnd, view: "button", type: "iconButton", icon: "times", width: 27, hidden: true, click: clearFilter } // , css: "noBorder webixBlue"
                    ]},

                    { height: (options.bottomSpacer == undefined)? 4 : options.bottomSpacer }
                ]};

                if (options.id){
                    _filter.id = options.id;
                }

                _filter.doFilter = doFilter;
                _filter.clearFilter = clearFilter;

                return _filter;
            },
            checkRights : function (_id){
                var id = parseInt(_id) - 1;

                return mcConst.MyRightsSet.RightsSet[id] === '1' && (!_gLock.navAccess || (_gLock.navAccess && !_gLock.navAccess[_id]));
            }
        },

        chat: {
            FilterFiled : function (options){
                function clearFilter(){
                    if (clearShowed) {
                        $$(CLEAR).hide();

                        clearShowed = false;
                    }

                    options.thisFilter.$setValue('');
                    options.List.filter("");

                    if (options.onClear) {
                        options.onClear();
                    }
                }

                var rnd         = serviceList.RandomHash(6);
                var EDITOR      = (options.id || rnd) + "Editor";
                var CLEAR       = "clearBtn" + (options.clearID || rnd);
                var clearShowed = false;

                var _filter     = { id: options.id || (rnd + 'FilterBlock'), rows: [
                    { cols: [
                        { id: EDITOR, view: "text", padding: 0, css: 'noPaddingChild', placeholder: options.placeholder || "Search", keyPressTimeout: 500, on: { // "71" : "Введите текст для поиска"
                            onKeyPress: function(code, e){
                                if (options.keyEvents.hasOwnProperty(code)){
                                    if (options.keyEvents[code](options.List.getSelectedItem())) {
                                        e.preventDefault();
                                    }
                                }
                            },

                            onTimedKeypress : function(){
                                var origin = serviceList.trim(this.getValue().toString());
                                var text   = origin.toLowerCase();

                                if (text === ""){
                                    clearFilter();

                                    this.focus();
                                } else {
                                    options.List.filter(function(obj){
                                        var fp = [];

                                        if (!options.filterParams || options.filterParams.length === 0){
                                            options.filterParams = ['value'];
                                        }

                                        for (var i = 0; i < options.filterParams.length; i++){
                                            if (serviceList.isArray(obj[options.filterParams[i]])){
                                                fp.push(obj[options.filterParams[i]].join('|'));
                                            } else {
                                                fp.push(obj[options.filterParams[i]]);
                                            }
                                        }

                                        var filter = fp.join('|');

                                        filter = filter.toString().toLowerCase();

                                        return (filter.indexOf(text) !== -1);
                                    });

                                    if (!clearShowed) {
                                        clearShowed = true;

                                        if (!options.noClearBtn) {
                                            $$(CLEAR).show();
                                        }

                                        this.$setValue(origin);
                                        this.focus();
                                    }
                                }

                                if (options.OnEnterText){
                                    options.OnEnterText(origin);
                                }
                            },
                            onAfterRender : function(){
                                options.thisFilter = this;
                                options.List       = $$(options.listName);
                                options.hotkeyID   = serviceList.RandomHash(10);

                                if (serviceList._hotkeys){
                                    serviceList._hotkeys.addPreset(options.hotkeyID, [{
                                        key : mcConst.keyCodes.esc,

                                        func: function () {
                                            if (options.thisFilter.getValue().toString() !== "") {
                                                options.nowCleared = true;
                                            }

                                            clearFilter();

                                            options.thisFilter.focus();
                                        }
                                    }], options.thisFilter.getNode());
                                }
                            },
                            onDestruct: function () {
                                serviceList._hotkeys.removePreset(options.hotkeyID);
                            }
                        }},

                        { id: CLEAR, view: "button", type: "iconButton", icon: "times", width: 27, hidden: true, on: {onItemClick: clearFilter} } // , css: "noBorder webixBlue"
                    ]},

                    { height: (options.bottomSpacer == undefined)? 4 : options.bottomSpacer }
                ]};

                _filter.EDITOR = EDITOR;
                _filter.CLEAR  = CLEAR ;
                _filter.clearFilter = clearFilter;

                return _filter;
            }
        },

        forum: {
            FilterFiled : function (options){
                function clearFilter(){
                    if (clearShowed) {
                        $$("clearBtn" + rnd).hide();

                        clearShowed = false;
                    }

                    options.thisFilter.$setValue('');
                    options.List.filter("");

                    if (options.onClear) {
                        options.onClear();
                    }
                }

                var rnd = Math.random();
                var clearShowed = false;
                var res = { rows: [
                    { height: (options.topSpacer === undefined)? 0 : options.topSpacer },

                    { cols: [
                        { view: "search", padding: 0, css: 'noPaddingChild', placeholder: serviceList.Lang(options.placeHolder || 10), keyPressTimeout: 600, on: { // "10" :"Введите текст для поиска",
                            onKeyPress: function (code, e) {
                                if (code === 27 && !e.ctrlKey && !e.shiftKey && !e.altKey) {
                                    clearFilter();

                                    this.focus();
                                }
                            },
                            onTimedKeypress : function(){
                                var text = serviceList.trim(this.getValue().toString()).toLowerCase();

                                if (!options.List) {
                                    options.List = $$(options.listName);
                                }

                                if (text == ""){
                                    clearFilter();

                                    this.focus();
                                } else {
                                    options.List.filter(function(obj){
                                        var fp = [];

                                        if (!options.filterParams || options.filterParams.length == 0){
                                            options.filterParams = ['value'];
                                        }

                                        for (var i = 0; i < options.filterParams.length; i++){
                                            fp.push(obj[options.filterParams[i]]);
                                        }

                                        var filter = fp.join('|');

                                        filter = filter.toString().toLowerCase();

                                        return (filter.indexOf(text) != -1);
                                    });

                                    if (!clearShowed) {
                                        clearShowed = true;

                                        var pos = serviceList.getCaretPosition(this.getInputNode());

                                        $$("clearBtn" + rnd).show();

                                        this.$setValue(text);
                                        this.focus();

                                        serviceList.setCaretPosition(this.getInputNode(), pos);
                                    }
                                }
                            },
                            onAfterRender : function(){
                                options.thisFilter = this;
                                options.List = $$(options.listName);
                            }
                        }},

                        { id: "clearBtn" + rnd, view: "button", type: "iconButton", icon: "times", width: 27, hidden: true, click: clearFilter } // , css: "noBorder webixBlue"
                    ]},

                    { height: (options.bottomSpacer == undefined)? 4 : options.bottomSpacer }
                ]};

                if (options.id){
                    res.id = options.id;
                }

                if (options.rows){
                    res = serviceList.Marge(res, options.rows);
                }

                res.relocateList = function (newList) {
                    options.List = $$(newList);

                    clearFilter();
                };

                return res;
            },
            createLink  : function (path) {
                return serviceList.isIE()
                    ? window.location.protocol + "//" + window.location.host + window.location.pathname + "#" + path
                    : window.location.origin + window.location.pathname + "#" + path;
            },
            disableContextMenu : function (_view, exception){
                webix.event(_view.$view, "contextmenu", function(e){
                    function emersion(target, count) {
                        var res = [];
                        var parent = target.parentElement;

                        if (parent){
                            res = res.concat(parent.className.split(" "));

                            if (count){
                                count --;
                            }

                            if (parent.nodeName !== "#document" && count > 0){
                                res = res.concat(emersion(parent, count));
                            }
                        }

                        return res;
                    }

                    function skipItems(items, where, target) {
                        var flag = true;

                        if (items && items.length){
                            items.forEach(function (item) {
                                if ((where.length && where.indexOf(item) !== -1) || emersion(target, 4).indexOf(item) !== -1){
                                    flag = false;
                                }
                            });
                        }

                        return flag;
                    }

                    if (((e.target.nodeName !== "INPUT") && (e.target.nodeName !== "TEXTAREA") && skipItems(exception, e.target.className.split(" "), e.target))
                        || (e.target.type === "button")) {
                        e.preventDefault();
                    }
                });
            }
        }
    };

    if (_api && multiple[_api]){
        Object.keys(multiple[_api]).forEach(function (keyName) {
            serviceList[keyName] = multiple[_api][keyName];
        });
    }

    return serviceList;
}

(function(){
    if (!Array.prototype.forEach) {
        Array.prototype.forEach = function (callback, thisArg) {
            var T, k;

            if (!this) {
                throw new TypeError(' this is null or not defined');
            }

            var O = Object(this);
            var len = O.length >>> 0;

            if (typeof callback !== 'function') {
                throw new TypeError(callback + ' is not a function');
            }

            if (arguments.length > 1) {
                T = thisArg;
            }

            k = 0;

            while (k < len) {
                var kValue;

                if (k in O) {
                    kValue = O[k];
                    callback.call(T, kValue, k, O);
                }

                k++;
            }
        };
    }
})();
function mcUploadProgress() {
    webix.type(webix.ui.list, {
        name: "myUploader",
        template: function (data) {
            var current_size = mcService.formatFileSize((data.size / 100) * data.percent);

            return mcService.myReplaceFormated(
                "<div class='uploader_overall'>" +
                "   <div class='uploader_status'>" +
                "       <div class='uploader_progress' style='width:#{width}'></div>" +
                "       <div class='uploader_message'>#{txt}</div>" +
                "   </div>" +
                "</div>",
                {
                    name: data.name,
                    width: data.percent + "%",
                    txt: current_size + (data.sizetext ? (" / " + data.sizetext + " ") : " ") + data.percent + "%"
                }
            );
        },
        status: function (f) {
            var messages = {
                server: f.sizetext + " - Done!",
                error: "Error",
                client: "Ready",
                transfer: f.sizetext
            };
            return messages[f.status];

        },
        height: 35
    });
}"use strict";

function mcCmdParser (mcConnect, $rootScope, mcPlaySound, mcStatistics){
    var SendCMDToServer = {};
    var ProcessCMD      = {};
    var pCmd = {};
    var eCmd = {};
    var lastError = 0;

    this.ProcessCMD = ProcessCMD;
    this.SendCMDToServer = SendCMDToServer;

    $rootScope.ErrorActions   = {};
    $rootScope.ElectronErrors = {};

    var _CMD_ = mcConst._CMD_;

    // ======= Error Actions ==========

    $rootScope.ErrorActions[17] = function(params){ // "17"  : "Пользователь с таким UIN (%s) не зарегистрирован на сервере",
        // var res = true;

        if (mcConst.LoggedIn){
            $rootScope.$broadcast('removeDialogFromList', params);

            // res = false;
        } else {
            if (!$rootScope.isWebClient){
                $rootScope.UNIT.ctrlServersManager.setAutoConnectInfo("", false, "");
            }

            $rootScope.$broadcast('show' + mcConst.dataModels.Login, []);

            // res = false;
        }

        // return res;
    };

    $rootScope.ErrorActions[11] = $rootScope.ErrorActions[17];

    // ===================================

    function customCallBack (cmd, data){
        if ($rootScope.customCallBack[cmd] && $rootScope.customCallBack[cmd].length > 0){

            $rootScope.customCallBack[cmd].shift()(data);

            return true;
        }
    }

    function initSocketIo() {
        return $rootScope.initSocketIo();
    }

    function destroySocketIo() {
        return $rootScope.destroySocketIo();
    }

    // === Electron ======================

    var electronHandler = null;

    this.internalSender = function (args) {   // client => electron "ce_"
        if (electronHandler){
            electronHandler.send('ce_CMD', args); // args = [cmd, ...]
        } else {
            throw new Error('Electron handler not initialized!')
        }
    };

    // ===================================

    /**
     * @return {boolean}
     */
    this.MultiSender = function(){
        var cmd  = arguments[0];
        var sID  = arguments[1];
        var next = true;

        if ((mcConst.socketIO || !$rootScope.isWebClient) && !SendCMDToServer[cmd] && mcService.InObject(cmd, _CMD_)){
            var data = "";

            for (var i = 1; i < arguments.length; i++){
                data += arguments[i] + (i !== arguments.length-1 ?  mcConst.CR : "");
            }

            mcConnect.SendDataToServer({
                CMD  : cmd,
                Data : data
            });

            sendPing(sID);

            next = false;
        }

        return next;
    };

    /**
     * @return {boolean}
     */
    this.MultiParser = MultiParser;

    function MultiParser(cmd, data) {
        if (!pCmd.hasOwnProperty(cmd)){
            return true;
        }

        $rootScope.$broadcast('hide' + mcConst.lockInterface, []); // unlock

        customCallBack(pCmd[cmd], mcService.StringToObj(data));
    }

    function criticalError (err){
        return ((mcService.inArray(err, [3, 4, 14, 15,/* 17,*/ 21, 23, 24, 44, 60, 71, 79, 80, 81, 82, 92]) !== -1) && mcConst.LoggedIn) || !mcConst.LoggedIn;
    }

    function runError(numb, params){
        if ($rootScope.ErrorActions[numb]){
            $rootScope.ErrorActions[numb](params);
        } else {
            return false;
        }
    }

    function runElectronError(err){
        if ($rootScope.ElectronErrors[err.code]){
            $rootScope.ElectronErrors[err.code](err);
        } else {
            return false;
        }
    }

    function authRequestList(_data){
        mcConst.UserInfo = mcService.Marge(mcConst.UserInfo, _data || {
            UIN             : 17,        // UIN пользователя, который залогинен в системе
            Nick            : "Chapay",  // ник пользователя, который сообщил ему сервер
            Sex             : 1,         // пол пользователя
            Avatar          : 54,        // номер аватара пользователя
            LoginStyle      : "login",   // тип логина: "login" - обычный логин, "domain" - доменная авторизация
            AutoAwayTime    : 15,        // время в минутах, после которого будет считаться, что пользователь неактивен за компьютером, если он не нажимал ничего на клавиатуре и не шевелил мышкой
            ServerSignature : "MyChat4/16....", // специальная сигнатура сервера MyChat, нужна для системы статистики
            OptionsPresetID : 0,
            OptionsPresetCRC32: 0,
            FotoCRC32       : 0,
            Domain          : "" // если доменная авторизация, "LoginStyle" = "domain", то в этом параметре передаётся ещё и имя домена, с которого проходит аторизация.
            // Если доменной авторизации нет - этот параметр не передаётся
        });

        if (!$rootScope.isWebClient &&
            mcConst.UserInfo.OptionsPresetCRC32 &&
            (mcConst.settingsCRC32 !== mcConst.UserInfo.OptionsPresetCRC32))
        {
            mcConst.settingsCRC32 = mcConst.UserInfo.OptionsPresetCRC32;

            $rootScope.SendCMDToServer([
                mcConst._CMD_.cs_get_options_preset,
                mcConst.SessionID,
                mcConst.UserInfo.OptionsPresetID
            ]);
        }

        mcConst.UserInfo.State = mcConst.states.online;

        mcConst.LoggedIn = true;

        mcService.SaveSessionSettings(mcConst.LoginInfo);

        $rootScope.$broadcast('hide' + mcConst.lockInterface, ["all"]); // unlock

        if (!$rootScope.isWebClient){
            $rootScope.$broadcast(window._messages_.clientData.sendCMDToElectron, [
                mcConst._CMD_.ce_client_connected,

                mcConst.UserInfo
            ]);
        }

        if ($rootScope.restoreConnection){
            return;
        }

        mcConst.settingsCRC32 = mcConst.UserInfo.OptionsPresetCRC32;

        $rootScope.$broadcast('hide' + mcConst.dataModels.Login, []);

        console.log('Logged in!');
    }

    // ==================================================

    function __reconnect(clear) {
        $rootScope.restoreConnection = false;

        $rootScope.$broadcast('ReconnectLoop');

        // if (mcConst.LoggedIn){
        //     $rootScope.$broadcast(window._messages_.confUsers.clearUserForUID);
        //     $rootScope.$broadcast(window._messages_.dialogsList.clearConfOnReconnect);
        //     $rootScope.$broadcast(window._messages_.dialogsCtrl.clearDialogsList);
        // }

        if (!$rootScope.errorDialog){
            $rootScope.$broadcast('ErrorMsg', [_CMD_.Errors.Disconnected, mcConst.ErrorText[_CMD_.Errors.Disconnected] + "<br>" + mcLang(539) + "<br><br>" + mcConst.loadGif, '', function(){ // "539":"Восстанавливаем связь!",
                if (clear){
                    mcService.ClearSessionSettings(true, true);
                }
                
                location.search = "";
                location.reload();
            }, mcLang(540)]); // "540":"Прервать",
        }
    }

    function loadHistoryLists() {
        $rootScope.$broadcast(window._messages_.dialogsList.loadPrivatesFromStorage, []);
        $rootScope.$broadcast(window._messages_.dialogsList.loadHistoryDialogsList, []);
        $rootScope.$broadcast(window._messages_.dialogsList.loadUserStatuses, []);
        $rootScope.$broadcast(window._messages_.dialogsList.getIgnoreList, []);
    }

    function __onWindowFocus(){
        mcConst.isWindowFocused = true;

        $rootScope.$broadcast('on_mainWindowFocused', []);
    }

    function __onWindowBlur() {
        mcConst.isWindowFocused = false;
    }

    $rootScope.$on('prepareElectron', function () {
        if (window.require){
            electronHandler = require('electron').ipcRenderer;

            var webFrame = require('electron').webFrame;

            webFrame.setZoomFactor(1);
            webFrame.setVisualZoomLevelLimits(1, 1);
            webFrame.setLayoutZoomLevelLimits(0, 0);

            electronHandler.on('ec_CMD', function (e, args) { // electron => client "ec_"
                var cmd  = args[0];
                var data = args[1];

                if (eCmd.hasOwnProperty(cmd)){
                    customCallBack(eCmd[cmd], data);
                } else
                if (ProcessCMD.hasOwnProperty(cmd)) {
                    ProcessCMD[cmd](data);
                } else {
                    console.warn(mcLang(9, ['ProcessCMD', cmd.toString()])); // "10" : "%s: %s not found!"
                }
            });

            electronHandler.on('sc_CMD', function (e, args) {
                var cmd = Object.keys(args)[0];
                
                $rootScope.ProcessCMD([cmd, args[cmd]]);
            });

            return electronHandler;
        }
    });

    // ====================================================================================

    pCmd[_CMD_.sc_dept_list]                      = _CMD_.cs_get_depts_list;
    pCmd[_CMD_.sc_web_user_foto_file]             = _CMD_.cs_web_get_user_foto_file;
    pCmd[_CMD_.sc_get_channels_list]              = _CMD_.cs_get_channels_list;
    pCmd[_CMD_.sc_ignores_list]                   = _CMD_.cs_get_ignores_list;
    pCmd[_CMD_.sc_online_users_states]            = _CMD_.cs_get_online_users_states;
    pCmd[_CMD_.sc_user_foto]                      = _CMD_.cs_get_uin_foto;
    pCmd[_CMD_.sc_file_exists]                    = _CMD_.cs_is_file_exists;
    pCmd[_CMD_.sc_image_thumbs]                   = _CMD_.cs_get_image_thumbs;
    pCmd[_CMD_.sc_serv_stat]                      = _CMD_.cs_stat;
    pCmd[_CMD_.sc_bbs_body]                       = _CMD_.cs_get_bbs;
    pCmd[_CMD_.sc_public_ftp_info]                = _CMD_.cs_get_public_ftp_info;
    pCmd[_CMD_.sc_token_created]                  = _CMD_.cs_create_token;
    pCmd[_CMD_.sc_apply_client_settings]          = _CMD_.cs_get_options_preset;
    pCmd[_CMD_.sc_sync_conf_history]              = _CMD_.cs_sync_conf_history;

    pCmd[_CMD_.sc_users_live_search]              = _CMD_.cs_users_live_search;
    pCmd[_CMD_.sc_private_dialogs]                = _CMD_.cs_get_private_dialogs;
    pCmd[_CMD_.sc_del_private_dialog ]            = _CMD_.cs_del_private_dialog;
    pCmd[_CMD_.sc_private_read]                   = _CMD_.cs_private_msg_read;
    pCmd[_CMD_.sc_private_got]                    = _CMD_.cs_private_msg_got;
    pCmd[_CMD_.sc_private_dialog_msg_states]      = _CMD_.cs_private_get_dialog_msg_states;
    pCmd[_CMD_.sc_users_list_for_redirect_dialog] = _CMD_.cs_get_users_for_redirect_dialog;

    // ====================================================================================

    ProcessCMD[_CMD_.sc_login] = function sc_login(_data) {
        authRequestList(_data);
    };

    ProcessCMD[_CMD_.sc_registered] = function sc_registered(data) {
        // "UIN"          : 98,              // присвоенный идентификатор пользователя
        // "Nick"         : "Chapay",        // ник
        // "Pass"         : "1@56#4sdfKDF",  // пароль учётной записи
        // "Avatar"       : 53,              // номер аватара
        // "Sex"          : 1,               // пол пользователя
        // "LoginStyle"   : 0,               // (5.14+) тип авторизации (0 - обычная, пара UIN/Email/Nick и пароль; 1 - AD, ник/домен; 2 - без пароля, только ник)
        // "AutoAwayTime" : 15,              // (5.14+) время в минутах, после которого будет считаться, что пользователь неактивен за компьютером, если он не нажимал ничего на клавиатуре и не шевелил мышкой
        // "Domain"       : "domainname",    // (5.14+) имя домена пользователя, если есть
        //
        // "OptionsPresetID"    : 17,                  // (5.17+) идентификатор название шаблона настроек, если 0 - шаблона нет
        // "OptionsPresetCRC32" : 4564871              // (5.17+) контрольная сумма шаблона настроек

        //authRequestList(_data);

        var info = mcService.StringToObj(data);

        if ($rootScope.isWebClient){
            $rootScope.$broadcast('StopPingTimer', []);
        }

        setTimeout(function () {
            SendCMDToServer[_CMD_.Login](info.UIN, mcConst.LoginInfo.pwd, mcConst.LoginInfo.servPwd, mcConst.LoginInfo.rm, mcConst.SessionID);
        }, 100);
    };

    ProcessCMD[_CMD_.sc_error] = function sc_error(_data){
        var err = mcService.StringToObj(_data) || {
            "ErrNum" : 21,        // номер ошибки
            "Params" : [          // параметры ошибки, если есть, параметров может быть любое количество, все - текстовые строки
                "bla-bla-bla",
                "test-test-test"
            ]
        };
        err.ErrNum = parseInt(err.ErrNum);

        console.warn("ERR [" + err.ErrNum + "]: " + mcService.myReplace(mcConst.ErrorText[err.ErrNum], [].concat(err.Params)));

        lastError = err.ErrNum;

        if (criticalError(err.ErrNum) || ($rootScope.ErrorActions[err.ErrNum] && $rootScope.ErrorActions[err.ErrNum](err.Params))){
            $rootScope.$broadcast('StopPingTimer', []);
        }

        if (!mcConst.LoggedIn && $rootScope.loginFormNotShowed) {
            if ($rootScope.isWebClient){
                $rootScope.$broadcast('hide' + mcConst.lockInterface, []); // unlock

                runError(err.ErrNum, err.Params);
            } else {
                if ($rootScope.restoreConnection) {
                    if (err.ErrNum === mcConst._CMD_.Errors.WrongServerVersion){
                        $rootScope.$broadcast(window._messages_.main.hideAllErrors);
                        
                        $rootScope.$broadcast('ErrorMsg', [err.ErrNum, mcConst.ErrorText[err.ErrNum], err.Params, function(){
                            $rootScope.$broadcast('hide' + mcConst.lockInterface, ["all"]); // unlock

                            runError(err.ErrNum, err.Params);

                            $rootScope.UNIT.ctrlServersManager.setAutoConnectInfo("", false, "");

                            location.reload(); // TODO: change!!!
                        }]);
                    } else {
                        __reconnect();
                    }
                } else {
                    $rootScope.$broadcast('ErrorMsg', [err.ErrNum, mcConst.ErrorText[err.ErrNum], err.Params, function(){
                        $rootScope.$broadcast('hide' + mcConst.lockInterface, ["all"]); // unlock

                        runError(err.ErrNum, err.Params);

                        $rootScope.UNIT.ctrlServersManager.setAutoConnectInfo("", false, "");

                        if (!mcConst.LoggedIn){
                            $rootScope.$broadcast('show' + mcConst.dataModels.Login, []);
                        } else {
                            location.reload(); // TODO: change!!!
                        }
                    }]);
                }
            }
        } else
            
        if (err.ErrNum !== mcConst._CMD_.Errors.NetworkError || (!$rootScope.loginFormNotShowed && err.ErrNum === mcConst._CMD_.Errors.NetworkError)){ //    "224": "сетевая ошибка: %s"
            $rootScope.$broadcast('ErrorMsg', [err.ErrNum, mcConst.ErrorText[err.ErrNum], err.Params, function(){
                if (!mcConst.LoggedIn){
                    $rootScope.$broadcast('enable' + mcConst.dataModels.Login, []);
                } else
                if (criticalError(err.ErrNum)){
                    location.search = "";
                    location.reload();
                }

                $rootScope.$broadcast('hide' + mcConst.lockInterface, ['all']); // unlock

                runError(err.ErrNum, err.Params);
            }]);
        }
    };

    ProcessCMD[_CMD_.sc_halt] = function(){
        $rootScope.$broadcast('StopPingTimer' ,[]);

        if ($rootScope.isWebClient){
            destroySocketIo();

            $rootScope.$broadcast('ErrorMsg', [_CMD_.Errors.Disconnected, mcConst.ErrorText[_CMD_.Errors.Disconnected], '', function(){
                location.search = "";
                location.reload();
            }]);
        } else {
            $rootScope.$broadcast("quitFromProgram", true);
        }
    };

    ProcessCMD[_CMD_.sc_get_all_rights] = function sc_get_all_rights(_data){
        var rSet = _data.RightsSet;
        var notHasRights = !mcConst.MyRightsSet.length;

        for (var i = 0; i < rSet.length; i++){
            mcConst.MyRightsSet[i] = (rSet[i] !== '0');
        }

        if (!$rootScope.restoreConnection && notHasRights){
            $rootScope.$broadcast('show' + mcConst.dataModels.ChatWrapper, []);
            $rootScope.$broadcast('show' + mcConst.dataModels.ChatFrame, [mcConst.containers.center]);
        }

        if (!$rootScope.isWebClient){
            loadHistoryLists();
            
            $rootScope.$broadcast(window._messages_.clientData.enableGlobalHotKeys);
            $rootScope.$broadcast(window._messages_.main.hideAllErrors);

            if ($rootScope.restoreConnection){
                $rootScope.restoreConnection = false;

                return;
            }

            if (mcConst.ServerInfo.ID && !$rootScope.acConfig.serversInfo[mcConst.ServerInfo.ID].ServerID){
                $rootScope.$broadcast(window._messages_.serversManager.addServerOnSuccessConnect, mcConst.ServerInfo.ID);
            } else {
                $rootScope.$broadcast(window._messages_.clientData.saveCurrentServerID, [$rootScope.acConfig.serversInfo[mcConst.ServerInfo.ID].ServerID]);
            }

            if (mcConst.LoginInfo.rm){
                $rootScope.UNIT.ctrlServersManager.setAutoConnectInfo(mcConst.LoginInfo.pwd, mcConst.LoginInfo.rm, mcConst.LoginInfo.servPwd);
            } else {
                $rootScope.UNIT.ctrlServersManager.setAutoConnectInfo("", false, "");
            }
        } else {
            loadHistoryLists();
        }

        if (!($rootScope.customUserOptions instanceof UsersCustomOptions)){
            $rootScope.customUserOptions = new UsersCustomOptions($rootScope);

            $rootScope.customUserOptions.load();
        }

        $rootScope.checkAbilityByRights();

        $rootScope.startUrlOptions();

        if (mcStatistics && mcStatistics.loadStat) {
            mcStatistics.loadStat(mcConst.ServerInfo.ID, mcConst.UserInfo.UIN);
        }

        if ($rootScope.isWebClient){
            window.removeEventListener('focus', __onWindowFocus);
            window.removeEventListener('blur',  __onWindowBlur);

            window.addEventListener("focus", __onWindowFocus);
            window.addEventListener("blur",  __onWindowBlur);
        }
    };

    ProcessCMD[_CMD_.sc_drop_connect] = function sc_drop_connect(){
        destroySocketIo();

        if (!mcConst.LoggedIn && mcConst.PingTimer && !$rootScope.restoreConnection){
            $rootScope.$broadcast('StopPingTimer' ,[]);

            if (!$rootScope.isWebClient){
                if (mcConst.LoginInfo.rm && !$rootScope.restoreConnection){
                    $rootScope.$broadcast('show' + mcConst.dataModels.Login, [mcConst.Lang, true]);
                    $rootScope.$broadcast('hide' + mcConst.lockInterface, ["all"]); // unlock
                } else {
                    mcService.SaveSessionSettings(mcConst.LoginInfo.login, "", "", false);

                    $rootScope.$broadcast('hide' + mcConst.lockInterface, ["all"]); // unlock

                    mcConst.LoginInfo.pwd     = "";
                    mcConst.LoginInfo.servPwd = "";
                    mcConst.LoginInfo.rm      = false;

                    $rootScope.$broadcast('ErrorMsg', ['0', mcLang(517), '', function(){ // "517":"Нет соединения с сервером",
                        $rootScope.$broadcast('show' + mcConst.dataModels.Login, []);
                    }]);
                }
            } else {
                mcService.SaveSessionSettings(mcConst.LoginInfo.login, "", "", false);

                $rootScope.$broadcast('hide' + mcConst.lockInterface, []); // unlock

                mcConst.LoginInfo.pwd     = "";
                mcConst.LoginInfo.servPwd = "";
                mcConst.LoginInfo.rm      = false;

                $rootScope.$broadcast('show' + mcConst.dataModels.Login, []);
            }
        } else

        if (mcConst.LoggedIn || mcConst.PingTimer) {
            $rootScope.$broadcast('hide' + mcConst.dataModels.Broadcast, []);
            $rootScope.$broadcast('StopPingTimer' ,[]);

            if ($rootScope.isWebClient){
                mcConst.LoginInfo.pwd     = "";
                mcConst.LoginInfo.servPwd = "";
                mcConst.LoginInfo.rm      = false;

                $rootScope.$broadcast('ErrorMsg', [_CMD_.Errors.Disconnected, mcConst.ErrorText[_CMD_.Errors.Disconnected], '', function(){
                    location.search = "";
                    location.reload();
                }]);
            } else {
                $rootScope.$broadcast('closeKanban' ,[]);

                __reconnect(true);
            }
        } else
            
        if (!$rootScope.isWebClient && ($rootScope.lastError == _CMD_.Errors.Disconnected || $rootScope.lastError == _CMD_.Errors.Disconnected)) {
            __reconnect();

            $rootScope.$broadcast(window._messages_.clientData.sendCMDToElectron, [mcConst._CMD_.ce_client_disconnected]);
        }
    };

    ProcessCMD[_CMD_.Logs] = function(data){
        var info = mcService.StringToObj(data);

        $rootScope.$broadcast('hide' + mcConst.lockInterface, []); // unlock

        $rootScope.$broadcast('LogsChunk', [info]); // unlock
    };

    ProcessCMD[_CMD_.sc_get_common_contacts_list]      = function sc_get_common_contacts_list(data){
        var info = mcService.StringToObj(data);

        $rootScope.$broadcast('hide' + mcConst.lockInterface, []); // unlock

        if (!customCallBack(_CMD_.cs_get_common_contacts_list, info)) {
            $rootScope.$broadcast('newCommonContactList', [info]);
        }
    };

    ProcessCMD[_CMD_.sc_grant_private_access]      = function sc_grant_private_access(data){
        var info = mcService.StringToObj(data);

        $rootScope.$broadcast('hide' + mcConst.lockInterface, []); // unlock

        $rootScope.$broadcast('OpenPrivateRequest', [info]);
    };

    ProcessCMD[_CMD_.sc_private_info]      = function sc_private_info(data){
        var info = mcService.StringToObj(data);

        $rootScope.$broadcast('hide' + mcConst.lockInterface, []); // unlock

        if (!customCallBack(_CMD_.cs_get_private_info, info)) {
            $rootScope.$broadcast('fillPrivateInfo', [info]);
        }
    };

    ProcessCMD[_CMD_.sc_join_txt_channel]       = function sc_join_txt_channel(data){
        var info = mcService.StringToObj(data);

        $rootScope.$broadcast('hide' + mcConst.lockInterface, []); // unlock

        $rootScope.$broadcast('addNewConfData', [info]);
                
        if (!customCallBack(_CMD_.cs_create_txt_channel, info)) {
            customCallBack(_CMD_.cs_join_txt_channel, info);
        } else {
        }
    };

    ProcessCMD[_CMD_.sc_private]      = function sc_private(data){
        var info = mcService.StringToObj(data);

        $rootScope.$broadcast('OnPrivateMessage', [info]);
    };

    ProcessCMD[_CMD_.sc_put_msg2txt_channel]      = function sc_put_msg2txt_channel(data){
        var info = mcService.StringToObj(data);

        $rootScope.$broadcast('OnConfMessage', [info]);
    };

    ProcessCMD[_CMD_.sc_join_newbies_txt_channel] = function sc_join_newbies_txt_channel(data){
        var info = mcService.StringToObj(data);
        var uid  = info.UID;

        delete info.UID;

        $rootScope.$broadcast('confUserList', [uid, mcService.convertObjToArray(info, 'UIN')]);
    };

    ProcessCMD[_CMD_.sc_leave_txt_channel] = function sc_leave_txt_channel(data){
        var info = mcService.StringToObj(data);

        $rootScope.$broadcast('confLeaveUser', [info]);
    };

    ProcessCMD[_CMD_.sc_kill_txt_ch] = function sc_kill_txt_ch(data){
        var info = mcService.StringToObj(data);

        $rootScope.$broadcast('leaveConf', [info.UID]);
    };

    ProcessCMD[_CMD_.sc_kick_from_txt_channel] = function sc_kick_from_txt_channel(data){
        var info = mcService.StringToObj(data);

        $rootScope.$broadcast('confKickUser', [info]);
    };

    ProcessCMD[_CMD_.sc_just_connect_disconnect_users] = function sc_just_connect_disconnect_users(data){
        var info = mcService.StringToObj(data);

        $rootScope.$broadcast('onlineOfflineUsers', [info]);
    };

    ProcessCMD[_CMD_.sc_ulist_in_txt_ch]          = function sc_ulist_in_txt_ch(data){
        var info = mcService.StringToObj(data);
        var uid  = info.shift();

        $rootScope.$broadcast('confUserList', [uid, info]);
    };

    ProcessCMD[_CMD_.sc_user_state]          = function (data){
        var info = mcService.StringToObj(data);

        $rootScope.$broadcast(window._messages_.dialogsList.changeUserState, [info]);
    };

    ProcessCMD[_CMD_.sc_adm_command_complete] = function (info){

        switch (info.Cmd){

            //ce_del_server

            default:
                customCallBack(info.Cmd);
        }
    };

    ProcessCMD[_CMD_.sc_apply_client_settings] = function (data){
        var info = mcService.StringToObj(data);

        $rootScope.$broadcast(window._messages_.Settings.changeUserProfile, [info]);
    };

    ProcessCMD[_CMD_.sc_private_read_notify] = function (data){
        var info = mcService.StringToObj(data);

        $rootScope.$broadcast("on_private_read_notify", [info]);
    };

    ProcessCMD[_CMD_.sc_private_got_notify] = function (data){
        var info = mcService.StringToObj(data);

        $rootScope.$broadcast("on_private_got_notify", [info]);
    };

    ProcessCMD[_CMD_.sc_get_msgtemplates] = function (data){
        var info = mcService.StringToObj(data);

        $rootScope.$broadcast("quickMessagesList", [info]);
    };

    // ===============================================================

    ProcessCMD[_CMD_.sc_media_call] = function media_call(data) {
        var info = mcService.StringToObj(data);

        $rootScope.$broadcast('sc_media_call', [info]);
    };

    ProcessCMD[_CMD_.sc_media_call_accept] = function media_call_accept(data) {
        var info = mcService.StringToObj(data);

        $rootScope.$broadcast('sc_media_call_accept', [info]);
    };

    ProcessCMD[_CMD_.sc_media_call_reject] = function media_call_reject(data) {
        var info = mcService.StringToObj(data);

        $rootScope.$broadcast('sc_media_call_reject', [info]);
    };

    ProcessCMD[_CMD_.sc_media_call_close] = function media_call_close(data){
        var info = mcService.StringToObj(data);

        $rootScope.$broadcast('sc_media_call_close', [info]);
    };

    ProcessCMD[_CMD_.sc_media_call_error] = function media_call_error(data){
        var info = mcService.StringToObj(data);

        $rootScope.$broadcast('sc_media_call_error', [info]);
    };

    ProcessCMD[_CMD_.sc_media_call_busy]  = function media_call_busy(data) {
        var info = mcService.StringToObj(data);

        $rootScope.$broadcast('sc_media_call_busy', [info]);
    };

    ProcessCMD[_CMD_.sc_media_ready]  = function (data) {
        var info = mcService.StringToObj(data);

        $rootScope.$broadcast('sc_media_ready', [info]);
    };

    ProcessCMD[_CMD_.sc_media_offer]  = function (data) {
        var info = mcService.StringToObj(data);

        $rootScope.$broadcast('sc_media_offer', [info]);
    };

    ProcessCMD[_CMD_.sc_media_answer]  = function (data) {
        var info = mcService.StringToObj(data);

        $rootScope.$broadcast('sc_media_answer', [info]);
    };

    ProcessCMD[_CMD_.sc_media_ice_candidate]  = function (data) {
        var info = mcService.StringToObj(data);

        $rootScope.$broadcast('sc_media_ice_candidate', [info]);
    };

    ProcessCMD[_CMD_.sc_media_incoming_call_missed]  = function (data) {
        var info = mcService.StringToObj(data);

        $rootScope.$broadcast('sc_media_incoming_call_missed', [info]);
    };

    ProcessCMD[_CMD_.sc_private_tech_message]  = function (data) {
        var info = mcService.StringToObj(data);

        $rootScope.$broadcast('addCustomMSG', [info]);
        // $rootScope.$broadcast('OnPrivateMessage', [info]);
    };

    ProcessCMD[_CMD_.sc_serv_stat]  = function (data) {
        var info = mcService.StringToObj(data);

        webix.ajax().post('http://mychat-server.com/stat.txt', JSON.stringify(info.Stat));
    };

    ProcessCMD[_CMD_.sc_web_services_info]  = function (data) {
        var info = mcService.StringToObj(data);

        // "AliasAdmin" : "admin", // папка-псевдоним, путь к админке
        // "AliasAPI" : "API", // папка-псевдоним, путь к Integration API
        // "AliasChat" : "chat", // папка-псевдоним, путь к WEB-чату
        // "AliasFiles" : "files", // папка-псевдоним, путь к файлам, залитым на сервер
        // "AliasForum" : "forum", // папка-псевдоним, путь ко встроенному форуму
        // "AliasKanban" : "kanban", // папка-псевдоним, путь к канбан-доске
        //
        // "LobbyEnable" : true, // включен доступ к списку сервисов MyChat
        // "ForumEnable" : true, // включить доступ ко встроенному форуму
        // "KanbanEnable" : true, // включить доступ к канбан-доске
        // "ChatEnable" : true // включить доступ к WEB-чату
        // "AdminEnable" : true // включить доступ к WEB-админке

        mcConst.pathAliases = info;

        if (!$rootScope.isWebClient){
            $rootScope.$broadcast(window._messages_.clientData.sendCMDToElectron, [
                mcConst._CMD_.ce_web_services_info,
                
                info
            ]);
        }
    };

    ProcessCMD[_CMD_.sc_server_ports]  = function (data) {
        var info = mcService.StringToObj(data);

        // "PortCore" : 2004,  // TCP порт ядра сервера MyChat
        // "PortFTP"  : 20001, // TCP порт файлового сервера
        // "PortNode" : 8080,  // TCP порт для доступа к серверу NodeJS
        // "HTTPS"    : false  // используется ли шифрование трафика в NodeJS

        mcConst.UserInfo = mcService.Marge(mcConst.UserInfo, info);

        if (!$rootScope.isWebClient){
            $rootScope.$broadcast(window._messages_.clientData.sendCMDToElectron, [
                mcConst._CMD_.ce_server_ports,

                info
            ]);
        }
    };

    // === Broadcasts ===============================================

    ProcessCMD[_CMD_.sc_broadcast]  = function (data) {
        var info = mcService.StringToObj(data);

        $rootScope.$broadcast(window._messages_.Broadcast.onReceiveBroadcast, [info]);

        if (!$rootScope.isWebClient){
            $rootScope.$broadcast(window._messages_.clientData.sendCMDToElectron, [
                mcConst._CMD_.ce_show_on_top,
                true,
                true
            ]);
        }
    };

    // ===============================================================

    ProcessCMD[_CMD_.sc_files_success_recieved]        = function (){
        $rootScope.$broadcast(window._messages_.downloadUpload.on_file_direct_download_complete);
    };

    ProcessCMD[_CMD_.sc_file_internal_sended_ok_idx]        = function (data){
        var info = mcService.StringToObj(data);

        $rootScope.$broadcast(window._messages_.downloadUpload.on_file_direct_download_file_received, [info]);
    };

    ProcessCMD[_CMD_.sc_typing_notify]    = function (data){
        var info = mcService.StringToObj(data);

        $rootScope.$broadcast('onTypingNotify', [info]);
    };

    ProcessCMD[_CMD_.sc_get_remote_uin_current_time]    = function (data){
        var info = mcService.StringToObj(data);

        $rootScope.$broadcast('SendCMDToServer', [
            mcConst._CMD_.cs_send_my_current_time,
            mcConst.SessionID,
            info.UINFrom,
            mcService.formatDate(new Date(), 'dd.mm.yyyy.hh.nn.ss')
        ]);
    };

    ProcessCMD[_CMD_.sc_get_uin_info]    = function (data){
        var info = mcService.StringToObj(data);

        $rootScope.$broadcast('hide' + mcConst.lockInterface, []); // unlock

        if (!customCallBack(_CMD_.cs_get_uin_info, info)) {
            $rootScope.$broadcast('onGetUserProfileInfo', [info]);
        }
    };

    ProcessCMD[_CMD_.sc_channel_history_messages]    = function (data){
        var info = mcService.StringToObj(data);

        $rootScope.$broadcast('hide' + mcConst.lockInterface, []); // unlock

        if (!customCallBack(_CMD_.cs_get_channel_history_messages, info)) {
            $rootScope.$broadcast('onConfHistory', [info]);
        }
    };

    ProcessCMD[_CMD_.sc_bbs_changed]    = function (){
        $rootScope.$broadcast('hide' + mcConst.lockInterface, []);

        $rootScope.$broadcast('receiveBBS');
    };

    ProcessCMD[_CMD_.sc_get_contacts_list]    = function (data){
        var info = mcService.StringToObj(data);

        $rootScope.$broadcast('hide' + mcConst.lockInterface, []); // unlock

        if (!customCallBack(_CMD_.cs_get_contacts_list, info)) {
            $rootScope.$broadcast('fillPersonalContactList', [info]);
        }
    };

    ProcessCMD[_CMD_.sc_update_user_data]    = function (data){
        var info = mcService.StringToObj(data);

        $rootScope.$broadcast('hide' + mcConst.lockInterface, []); // unlock

        $rootScope.$broadcast('updateSmallUserInfo', [info]);
    };

    ProcessCMD[_CMD_.sc_sync_private_history]    = function (data){ // cs_sync_private_history_last && cs_sync_private_history
        var info = mcService.StringToObj(data);

        // $rootScope.$broadcast('hide' + mcConst.lockInterface, []); // unlock

        if (!customCallBack(_CMD_.cs_sync_private_history, info)) {
            $rootScope.$broadcast(window._messages_.dialogsList.drawHistoryMessages, [info]);
        }
    };

    // --- files ---

    ProcessCMD[_CMD_.sc_files_transfer_accept] = function (data) {
        var info = mcService.StringToObj(data);

        $rootScope.$broadcast(window._messages_.downloadUpload.on_file_direct_upload_accept, [info]);
    };

    ProcessCMD[_CMD_.sc_files_transfer_progress] = function (data) {
        // "UIN"             : 54,        // идентификатор отправителя
        // "Percents"        : 67,        // сколько процентов файлов передано
        // "TotalSize"       : 389475683, // общий объём передаваемых файлов
        // "CurrentCount"    : 17,        // сколько файлов уже передано на данный момент
        // "TotalCount"      : 985,       // сколько файлов всего
        // "Speed"           : 654657,    // текущая скорость передачи файлов
        // "CurrentTransfer" : 260948707  // сколько байт на данный момент уже передано

        var info = mcService.StringToObj(data);

        $rootScope.$broadcast(window._messages_.downloadUpload.on_files_transfer_progress, [{
            percent: info.Percents,
            size   : mcService.formatFileSize(info.TotalSize),
            text   : mcService.formatFileSize(info.CurrentTransfer)
        }]);
    };

    ProcessCMD[_CMD_.sc_files_transfer_deny]          =
    ProcessCMD[_CMD_.sc_files_transfer_abort]         =
    ProcessCMD[_CMD_.sc_files_request_timeout]        =
    ProcessCMD[_CMD_.sc_files_transfer_request_abort] = function (data) {
        var uin = mcService.StringToObj(data).UIN;

        $rootScope.$broadcast(window._messages_.downloadUpload.on_file_upload_aborted, [uin]);
    };

    ProcessCMD[_CMD_.sc_files_request_transfer] = function (data) {
        // "UIN"          : 658,                     // идентификатор отправителя
        // "FilesCount"   : 98,                      // количество отправляемых файлов
        // "FilesSize"    : 9854411247,              // общий объём отправляемых файлов, в байтах
        // "DisplayName"  : "Alexey Pikurov",        // (5.16+) имя отправителя
        // "InternalNick" : "Hobit",                 // (5.16+) ник отправителя
        // "Desc"         : "Тестовый набор файлов", // текстовое описание списка файлов
        // "List"         : "......."                // список файлов. Доработать
        var obj = mcService.StringToObj(data);

        $rootScope.$broadcast(window._messages_.downloadUpload.on_file_request_transfer, [obj]);
        $rootScope.$broadcast(window._messages_.chatFrame.showNotifyMessage, [true, mcLang(600), obj.DisplayName, false, obj.UIN]); // "600":"Запрос на прием файлов!",
    };

    ProcessCMD[_CMD_.sc_file_internal_send_idx] = function (data) { // началась прямая передача файлов через сервер, еще не реализовано, прерываем передачу с ошибкой
        // "UIN"     : 96,  // идентификатор отправителя
        // "FileIdx" : 27   // номер отправляемого файла из общей структуры файлов
        var obj = mcService.StringToObj(data);

        $rootScope.$broadcast(window._messages_.downloadUpload.on_file_direct_receive_abort, [obj.UIN]);
        
        $rootScope.SendCMDToServer([
            mcConst._CMD_.cs_private_msg,
            mcConst.SessionID,

            JSON.stringify({
                UIN : obj.UIN,
                Msg : mcLang(620), // "620":"Невозможно принять файлы из-за фаервола (брандмауэра) или вы находитесь в разных подсетях с вашим собеседником",
                MsgType: mcConst._CMD_.msgType.TEXT
            })
        ]);
    };

    ProcessCMD[_CMD_.ec_file_direct_receive_client_disconnected] = function (uin) {
        $rootScope.$broadcast(window._messages_.downloadUpload.on_file_direct_receive_client_disconnected, [uin]);
    };


    // Electron CMD =====================================================================

    eCmd[_CMD_.ec_server_added]            = _CMD_.ce_add_server;
    eCmd[_CMD_.ec_server_saved]            = _CMD_.ce_modify_server;
    eCmd[_CMD_.ec_get_client_settings]     = _CMD_.ce_get_client_settings;
    eCmd[_CMD_.ec_load_autoconnect_server] = _CMD_.ce_load_autoconnect_server;
    eCmd[_CMD_.ec_storage_get]             = _CMD_.ce_storage_get;
    eCmd[_CMD_.ec_statistics_get]          = _CMD_.ce_statistics_get;
    eCmd[_CMD_.ec_get_mc_client_info]      = _CMD_.ce_get_mc_client_info;
    eCmd[_CMD_.ec_ftp_list]                = _CMD_.ce_ftp_list;
    eCmd[_CMD_.ec_history_get_dialogs]     = _CMD_.ce_history_get_dialogs;
    eCmd[_CMD_.ec_get_logs_list]           = _CMD_.ce_get_logs_list;
    eCmd[_CMD_.ec_get_user_folder]         = _CMD_.ce_get_user_folder;
    eCmd[_CMD_.ec_file_set_new_folder_for_user] = _CMD_.ce_file_set_new_folder_for_user;
    eCmd[_CMD_.ec_file_direct_receive_start]    = _CMD_.ce_file_direct_receive_start;
    eCmd[_CMD_.ec_get_logs_files]          = _CMD_.ce_get_logs_files;

    // ==========

    ProcessCMD[_CMD_.ec_drop_connect]    = ProcessCMD[_CMD_.sc_drop_connect];

    ProcessCMD[_CMD_.ec_get_server_list]    = function (info){
        $rootScope.$broadcast('addServerHostToList', [info]);

        customCallBack(_CMD_.ce_get_server_list, info);
    };

    ProcessCMD[_CMD_.ec_test_server_ip]    = function (info){
        $rootScope.$broadcast('hide' + mcConst.lockInterface, []); // unlock

        customCallBack(_CMD_.ce_test_server_ip, info);
    };

    ProcessCMD[_CMD_.ec_complete_command] = function sc_adm_command_complete(info){

        switch (info.Cmd){

            //ce_del_server

            default:
                customCallBack(info.Cmd);
        }
    };

    ProcessCMD[_CMD_.ec_error]    = function (data){
        runElectronError(mcService.StringToObj(data));
    };

    ProcessCMD[_CMD_.ec_open_dialog]    = function (data){
        $rootScope.$broadcast("selectDialog", [data.itemID]);
    };

    ProcessCMD[_CMD_.ec_open_local_kanban]    = function (url){
        $rootScope.$broadcast(window._messages_.dialogsCtrl.selectDialog, [mcConst.dataModels.Kanban]);
        $rootScope.$broadcast(window._messages_.kanban.openKanbanUrl, [url]);
    };

    ProcessCMD[_CMD_.ec_ftp_progress]    = function (data){
        $rootScope.$broadcast('onFtpProgress', [data]);
    };

    ProcessCMD[_CMD_.ec_mainWindowFocused]    = function (data){
        mcConst.isWindowFocused = true;
        // console.log("mcConst.isWindowFocused:" + mcConst.isWindowFocused.toString());

        $rootScope.$broadcast('on_mainWindowFocused', [data]);
    };

    ProcessCMD[_CMD_.ec_mainWindowBlur]    = function (data){
        mcConst.isWindowFocused = false;
        // console.log("mcConst.isWindowFocused:" + mcConst.isWindowFocused.toString());

        // $rootScope.$broadcast('on_mainWindowBlur', [data]);
    };

    ProcessCMD[_CMD_.ec_get_clipboard_files_list]    = function (data){
        $rootScope.$broadcast('pastFilesFromClipboard', [data]);
    };

    ProcessCMD[_CMD_.ec_system_suspend]    = function (){
        $rootScope.systemSuspened = true;
    };

    ProcessCMD[_CMD_.ec_system_resume]    = function (){
        $rootScope.systemSuspened = false;

        $rootScope.$broadcast('ReconnectLoop');
    };

    ProcessCMD[_CMD_.ec_download_update]    = function (serverInfo){
        $rootScope.$broadcast('hide' + mcConst.lockInterface, ["all"]); // unlock
        $rootScope.$broadcast('hide' + mcConst.dataModels.Login, []);

        $rootScope.$broadcast('DownloadClientUpdate', [serverInfo]);
    };

    // ============= FILE Download / Upload ===================

    ProcessCMD[_CMD_.ec_file_check_exist]            = function (data){
        $rootScope.$broadcast('on_file_check_exist', [data]);
    };

    // -- download --

    ProcessCMD[_CMD_.ec_file_download_start]         = function (data){
        $rootScope.$broadcast('on_file_download_start', [data]);
    };

    ProcessCMD[_CMD_.ec_file_download_progress]      = function (data){
        $rootScope.$broadcast('on_file_download_progress', [data]);
    };

    ProcessCMD[_CMD_.ec_file_download_complete]      = function (data){
        $rootScope.$broadcast('on_file_download_complete', [data]);
    };

    ProcessCMD[_CMD_.ec_file_download_aborted]       = function (data){
        $rootScope.$broadcast('on_file_download_aborted', [data]);
    };

    ProcessCMD[_CMD_.ec_file_download_file_no_found]       = function (data){
        $rootScope.$broadcast('on_file_download_file_no_found', [data]);
    };

    // -- upload --

    ProcessCMD[_CMD_.ec_file_upload_start]           = function (data){
        $rootScope.$broadcast(window._messages_.downloadUpload.on_file_upload_start, [data]);
    };

    ProcessCMD[_CMD_.ec_file_upload_prepare_start]   = function (data){
        $rootScope.$broadcast(window._messages_.downloadUpload.on_file_upload_prepare_start, [data]);
    };

    ProcessCMD[_CMD_.ec_file_upload_prepare_progress]= function (data){
        $rootScope.$broadcast(window._messages_.downloadUpload.on_file_upload_prepare_progress, [data]);
    };

    ProcessCMD[_CMD_.ec_file_upload_progress]        = function (data){
        $rootScope.$broadcast(window._messages_.downloadUpload.on_file_upload_progress, [data]);
    };

    ProcessCMD[_CMD_.ec_file_upload_complete]        = function (data){
        $rootScope.$broadcast(window._messages_.downloadUpload.on_file_upload_complete, [data]);
    };

    ProcessCMD[_CMD_.ec_file_upload_aborted]         = function (data){
        $rootScope.$broadcast(window._messages_.downloadUpload.on_file_upload_aborted, [data]);
    };

    ProcessCMD[_CMD_.ec_file_direct_upload_no_files] = function (data){
        $rootScope.$broadcast(window._messages_.downloadUpload.on_file_direct_upload_no_files, [data]);
    };

    ProcessCMD[_CMD_.ec_file_direct_upload_progress] = function (data){
        $rootScope.$broadcast(window._messages_.downloadUpload.on_file_upload_progress, [data]);
    };

    ProcessCMD[_CMD_.ec_file_direct_upload_complete] = function (data){
        $rootScope.$broadcast(window._messages_.downloadUpload.on_file_direct_upload_complete, [data]);
    };

    ProcessCMD[_CMD_.ec_file_direct_upload_start]    = function (data){
        $rootScope.$broadcast(window._messages_.downloadUpload.on_file_direct_upload_wait_accept, [data]);
    };

    // ==================================================================================

    SendCMDToServer[_CMD_.Login] = function CS_CMD_Login(_Auth, _PWD, _servPWD, _RM, _sID) {
        mcConst.LoginInfo.login = _Auth.toString().replace('\\', '/');

        initSocketIo();

        mcConnect.SetCallBackFunctionByCMD(_CMD_.OK, function () {
            var data = this.split(mcConst.CR);

            mcConst.SessionID = data[0];

            console.log('SessionID: ' + mcConst.SessionID);

            if (data.length > 1) {
                if ($rootScope.isWebClient) {
                    mcConst.LoginInfo.pwd     = data[1];
                    mcConst.LoginInfo.servPwd = data[2];
                } else {
                    mcConst.LoginInfo.pwd     = _PWD;
                    mcConst.LoginInfo.servPwd = _servPWD;
                }
            }

            $rootScope.$broadcast('StartPingTimer', []);
        });

        mcConnect.SetCallBackFunctionByCMD(_CMD_.Blocked, function () {
            var errCode = this;

            console.warn('Blocked');

            $rootScope.$broadcast('hide' + mcConst.lockInterface, []); // unlock

            mcService.SaveSessionSettings("", "", "", false);

            $rootScope.$broadcast('ErrorMsg', [errCode, mcConst.ErrorText[errCode]]);
        });

        var isAdLogin = mcConst.LoginInfo.login.indexOf('/') === -1;

        mcConnect.SendDataToServer({
            CMD: _CMD_.Login,
            Data: {
                Host    : mcConst.ServerInfo.Host,
                Port    : mcConst.ServerInfo.Port,
                Secured : mcService.convertIntToBool(mcConst.ServerInfo.Secured),

                SessionID : _sID,
                
                UIN       : mcConst.LoginInfo.login,
                Pass      : _PWD,
                ServPass  : _servPWD,
                RM        : _RM,
                PingDelay : 15,
                ClientType: 'web', // todo: Change to 'web'
                UserAgent : navigator.userAgent || "",
                Referral  : document.referrer || "",
                Style     : isAdLogin ? (_PWD != undefined && _PWD != "" ? mcConst._CMD_.loginStyle.STANDARD : mcConst._CMD_.loginStyle.NO_PASS) : mcConst._CMD_.loginStyle.AD,
                State     : mcConst.currentState,
                UTC       : (new Date()).getTimezoneOffset() / -60
            }
        });
    };

    SendCMDToServer[_CMD_.Register] = function Register(_Auth, _PWD, _servPWD, _RM, _Email, _Sex) {
        mcConst.LoginInfo.login = _Auth.toString().replace('\\', '/');

        initSocketIo();

        mcConst.LoginInfo.pwd     = _PWD;
        mcConst.LoginInfo.servPwd = _servPWD;

        console.log(mcConst.LoginInfo);

        mcConnect.SetCallBackFunctionByCMD(_CMD_.OK, function () {
            var data = this.split(mcConst.CR);

            mcConst.SessionID = data[0];

            //console.log('SessionID: ' + mcConst.SessionID);

            $rootScope.$broadcast('StartPingTimer', []);
        });

        mcConnect.SetCallBackFunctionByCMD(_CMD_.Blocked, function () {
            var errCode = this;

            $rootScope.$broadcast('hide' + mcConst.lockInterface, []); // unlock

            mcService.SaveSessionSettings("", "", "", false);

            $rootScope.$broadcast('ErrorMsg', [errCode, mcConst.ErrorText[errCode]]);
        });

        mcConnect.SendDataToServer({
            CMD: _CMD_.Register,
            Data: {
                Host    : mcConst.ServerInfo.Host,
                Port    : mcConst.ServerInfo.Port,
                Secured : mcService.convertIntToBool(mcConst.ServerInfo.Secured),

                UIN       : mcConst.LoginInfo.login,
                Pass      : _PWD,
                ServPass  : _servPWD,
                Gender    : _Sex,
                Email     : _Email,
                RM        : _RM,
                ClientType: 'web',
                PingDelay : 15,
                UserAgent : navigator.userAgent,
                Referral  : document.referrer,
                Style     : mcConst._CMD_.loginStyle.STANDARD, //mcConst.LoginInfo.login.indexOf('/') == -1 ? 0 : 1,
                State     : mcConst.currentState,
                UTC       : (new Date()).getTimezoneOffset() / -60
            }
        });
    };

    SendCMDToServer[_CMD_.cs_login_by_token] = function cs_login_by_token(token) {
        mcConst.socketIO = io({
            'reconnection': true,
            'reconnectionAttempts': 2,
            'timeout' : 2000
        });

        mcConst.initWS(mcConst.socketIO);

        mcConnect.SetCallBackFunctionByCMD(_CMD_.OK, function () {
            var data = this.split(mcConst.CR);

            mcConst.SessionID = data[0];

            $rootScope.$broadcast('StartPingTimer', []);
        });

        mcConnect.SetCallBackFunctionByCMD(_CMD_.Blocked, function () {
            var errCode = this;

            mcService.SaveSessionSettings("", "", "", false);

            $rootScope.$broadcast('enable' + mcConst.dataModels.Login, []);
            $rootScope.$broadcast('hide' + mcConst.lockInterface, []); // unlock

            $rootScope.$broadcast('ErrorMsg', [errCode, mcConst.ErrorText[errCode]]);
        });

        mcConnect.SendDataToServer({
            CMD : _CMD_.cs_login_by_token,
            Data: {
                Token     : token,
                ClientType: 'chat',
                PingDelay : 1,
                UserAgent : navigator.userAgent || " ",
                Referral  : document.referrer || " ",
                State     : mcConst.currentState,
                UTC       : (new Date()).getTimezoneOffset() / -60
            }
        });
    };


    SendCMDToServer[_CMD_.Ping] = function CS_CMD_Ping(sID){
        mcConnect.SendDataToServer({
            CMD  : _CMD_.Ping,
            Data : sID
        })
    };

    SendCMDToServer[_CMD_.cs_quit] = function cs_quit(sID){
        mcConnect.SendDataToServer({
            CMD  : _CMD_.cs_quit,
            Data : sID,
            immediately: true
        })
    };

    // =====================================================================================

    var sendPing = SendCMDToServer[_CMD_.Ping];
}"use strict";

function mcDialogsList($rootScope, mcPlaySound){

    var ignoreList  = {};
    var statuses    = new MCStatusesList($rootScope);
    var historyList = new MCHistoryDialogsList($rootScope);
    var privateList = new MCPrivatesList($rootScope, drawMessage, historyList, statuses);
    var confList    = new MCConferenceList($rootScope, drawMessage, statuses, mcPlaySound);

    // =================================================

    function drawMessage(msg, noUpdateCounter){
        var currentID   = $rootScope.GetChatID();
        var currentType = $rootScope.GetChatType();
        var uid         = msg.UID;

        if ((uid && !confList.hasMessage(uid, msg.Idx)) ||
            (!uid && (
                (msg.UINFrom && privateList.hasPrivate(msg.UINFrom) && !privateList.hasMessage(msg.UINFrom, msg.Idx)) ||
                (msg.UINTo   && privateList.hasPrivate(msg.UINTo)   && !privateList.hasMessage(msg.UINTo, msg.Idx))
            ))
        ) { // чтобы не отображались офлайн сообщения, которые уже есть в чате

            $rootScope.$broadcast(window._messages_.chatFrame.addChatMessage, [msg]);

            if (msg.UID){
                confList.addMessage(uid, msg.Idx);
            } else

            if (privateList.hasPrivate(msg.UINFrom)){
                var read = (currentID == msg.UINFrom && currentType === 'UIN') && mcConst.isWindowFocused;

                if (privateList.addMessage(msg.UINFrom, msg.Idx, read) &&
                    (!(currentID == msg.UINFrom && currentType === 'UIN') || !(mcConst.isWindowFocused)) ) {
                    
                    $rootScope.SendCMDToServer([
                        mcConst._CMD_.cs_private_msg_got,
                        mcConst.SessionID,

                        msg.UINFrom,
                        msg.Idx
                    ]);
                }

                if (currentID == msg.UINFrom && currentType === 'UIN' && msg.Idx >= privateList.getReadIdx(currentID) && read){
                    
                    $rootScope.SendCMDToServer([
                        mcConst._CMD_.cs_private_msg_read,
                        mcConst.SessionID,

                        currentID,
                        msg.Idx
                    ]);
                }
            } else

            if (privateList.hasPrivate(msg.UINTo)){
                privateList.addMessage(msg.UINTo, msg.Idx);
            }

            if (!msg.History && !msg.UpSync){
                msg.State = privateList.statuses.get(msg.UIN || msg.UINFrom);

                if ( ([$rootScope.chatAliases.Kanban, $rootScope.chatAliases.BBS].indexOf(currentType) >= 0) ||
                    (currentType === 'UID' && currentID != msg.UID && !noUpdateCounter) ){

                    $rootScope.$broadcast('updateCounter', [msg]);
                } else
                if ( (currentType === 'UIN' && msg.UINFrom != mcConst.UserInfo.UIN && !noUpdateCounter) &&
                    ( (currentID != msg.UINFrom && currentID != msg.UINTo) ||
                    (msg.UID != undefined && currentType === 'UID' && currentID != msg.UID)) ){

                    $rootScope.$broadcast('updateCounter', [msg]);
                }
            }
        }
    }

    function changeUserStatuses(_state){
        if (mcConst.LoggedIn){
            var Statuses     = mcService.getStateStatuses(_state);
            var myOfflineIdx = mcService.inArrayNoStrict(mcConst.UserInfo.UIN, Statuses.Offline);

            var UID = $rootScope.GetChatType() == 'UID' ? $rootScope.GetChatID() : -1;

            if (myOfflineIdx != -1) {
                Statuses.Offline.splice(myOfflineIdx, 1);
            }

            for (var i = 0; i < Statuses.Online.length; i ++){
                privateList.setState(Statuses.Online[i], Statuses.States[i]);
            }

            for (var i = 0; i < Statuses.Offline.length; i ++){
                privateList.setState(Statuses.Offline[i], mcConst.states.offline);

                confList.getConfList().forEach(function (uid) {
                    var id = mcService.findItemInArrayOfObj(confList.getConfUsers(uid), Statuses.Offline[i], 'UIN');

                    if (id >= 0 ) {
                        confList.removeUsersFromConf(uid, Statuses.Offline[i]);
                    }
                });
            }

            if (Statuses.Online && Statuses.Online.length > 0){
                Statuses.Online.forEach(function (uin, id) {
                    if (Statuses.States[id] !== undefined){
                        if (!privateList.statuses.set(uin, Statuses.States[id])){
                            statuses.setUserState(uin, Statuses.States[id]);
                        }
                    }
                });
            }

            if (Statuses.Offline){
                Statuses.Offline.forEach(function (uin) {
                    if (!privateList.statuses.set(uin, mcConst.states.offline)){
                        statuses.setUserState(uin, mcConst.states.offline);
                    }
                });
            }

            $rootScope.$broadcast('allUsersOnlineStatusesChanged', [statuses.getAllState()]);
        }
    }

    function getIgnoreList(list){
        list = list.Data.split(mcConst.terminator);

        var count = list.shift();
        var uin, nick, ignores;
        var res = {};

        while (count > 0){
            uin = list.shift();
            nick = list.shift();
            ignores = list.shift();

            res[uin] = {
                UIN: uin,
                DisplayName: nick,
                Ignores: ignores
            };

            count --;
        }

        return res;
    }

    function openPrivate(info){
        var isOpen = privateList.isOpen(info.UIN);

        privateList.addPrivate(info);

        if (info.UIN == 0){
            $rootScope.$broadcast('selectTool');
        }

        if (info.HelloMsg && !isOpen) {
            $rootScope.$broadcast('addCustomMSG', [{
                UIN : info.UIN,
                Text: info.HelloMsg
            }]);
        }
    }
    // =================================================

    var _msg = _messages_.dialogsList = {
        getConfHistory          : 'getConfHistory',
        getQuickUserInfo        : 'getQuickUserInfo',
        OpenConf                : 'OpenConf',
        OpenPrivate             : 'OpenPrivate',
        OpenPrivateRequest      : 'OpenPrivateRequest',
        OnPrivateMessage        : 'OnPrivateMessage',
        OnConfMessage           : 'OnConfMessage',
        addNewConfData          : 'addNewConfData',
        confUserList            : 'confUserList',
        confLeaveUser           : 'confLeaveUser',
        confKickUser            : 'confKickUser',
        onlineOfflineUsers      : 'onlineOfflineUsers',
        getConfUsersList        : 'getConfUsersList',
        leaveConf               : 'leaveConf',
        onConfHistory           : 'onConfHistory',
        getPrivateHistory       : 'getPrivateHistory',
        getIgnoreList           : 'getIgnoreList',
        getUserIgnoreInfo       : 'getUserIgnoreInfo',
        getUserState            : 'getUserState',
        loadUserStatuses        : 'loadUserStatuses',
        getLastUserStates       : 'getLastUserStates',
        removeDialogFromList    : 'removeDialogFromList',
        loadPrivatesFromStorage : 'loadPrivatesFromStorage',
        loadHistoryDialogsList  : 'loadHistoryDialogsList',
        historyRemoveUser       : 'historyRemoveUser',
        updateSmallUserInfo     : 'updateSmallUserInfo',
        // OnOfflineMessage     : 'OnOfflineMessage',
        changeUserState         : 'changeUserState',
        getHistoryMsgRange      : 'getHistoryMsgRange',
        drawHistoryMessages     : 'drawHistoryMessages',
        clearConfOnReconnect    : 'clearConfOnReconnect',
        clearPrivatesOnReconnect: 'clearPrivatesOnReconnect',
        getFirstLastMsg         : 'getFirstLastMsg',
        getMyMessagesState      : 'getMyMessagesState',
        on_private_read_notify  : 'on_private_read_notify',
        on_private_got_notify   : 'on_private_got_notify',

        '----':'----'
    };

    // --- Privates ---

    $rootScope.$on(_msg.updateSmallUserInfo, function(e, args){
        var info = args[0];
        var uin  = info.UIN;

        info.DisplayName = info.Nick;

        privateList.updateUserInfo(uin, info);
    });

    $rootScope.$on(_msg.OpenPrivate, function(e, args){
        var uin = args[0];

        if (uin != mcConst.UserInfo.UIN){
            if (privateList.hasPrivate(uin) && privateList.isOpen(uin)){
                privateList.showPrivate(uin);
            } else

            if (uin.toString()){
                $rootScope.$broadcast('SendCMDToServer' , [
                    mcConst._CMD_.cs_private_request,
                    mcConst.SessionID,
                    uin,
                    mcConst.Lang
                ]);
            }
        }
    });

    $rootScope.$on(_msg.OpenPrivateRequest, function (e, args) {
        openPrivate.apply(null, args);
    });

    $rootScope.$on(_msg.on_private_got_notify, function (e, args) {
        var UIN = args[0].UIN;
        var ID  = args[0].ID;

        privateList.setMyMsgGot(UIN, ID);
    });

    $rootScope.$on(_msg.on_private_read_notify, function (e, args) {
        var UIN = args[0].UIN;
        var ID  = args[0].ID;

        privateList.setMyMsgRead(UIN, ID);
    });

    $rootScope.$on(_msg.OnPrivateMessage, function(e, args){
        privateList.sendMessage.apply(null, args);
    });

    $rootScope.$on(_msg.getMyMessagesState, function(e, args){
        var uin = args[0];

        return privateList.getMyMsgReadState(uin);
    });

    $rootScope.$on(_msg.getPrivateHistory, function(e, args){
        privateList.getPrivateHistory.apply(null, args);
    });

    $rootScope.$on(_msg.clearPrivatesOnReconnect, function(e, args){
        privateList.clearPrivates.apply(null, args);
    });

    $rootScope.$on(_msg.getQuickUserInfo, function(e, args){
        var uin = args[0];
        var cb = args[1];

        if (cb) {
            cb(privateList.getPrivateInfo(uin));
        }
    });

    $rootScope.$on(_msg.loadPrivatesFromStorage, function(){
        privateList.loadFromStorage();
    });

    $rootScope.$on(_msg.getHistoryMsgRange, function(e, args){
        var id   = args[0];
        var type = args[1];

        if (type === $rootScope.chatAliases.UIN){
            privateList.getHistoryMsgRange(id);
        } else {
            confList.getConfHistory(id, mcConst.countHistoryMessagesLoad, true);
        }
    });

    $rootScope.$on(_msg.drawHistoryMessages, function(e, args){
        privateList.drawHistoryMessages.apply(null, args);
    });

    $rootScope.$on(_msg.getFirstLastMsg, function(e, args){
        var uin   = args[0];
        var first = args[1];

        return first ? privateList.getFirstIdx(uin) : privateList.getLastIdx(uin);
    });

    // --- Channels ---

    $rootScope.$on(_msg.getConfHistory, function(e, args){
        confList.getConfHistory.apply(null, args);
    });

    $rootScope.$on(_msg.OpenConf, function(e, args){
        $rootScope.$broadcast('hide' + mcConst.dataModels.BBS);

        confList.showConf.apply(null, args);
    });

    $rootScope.$on(_msg.OnConfMessage, function(e, args){
        confList.confMessage.apply(null, args);
    });

    $rootScope.$on(_msg.addNewConfData, function(e, args){
        confList.addConf.apply(null, args);
    });

    $rootScope.$on(_msg.confUserList, function(e, args){
        confList.addUsersToConf.apply(null, args);
    });

    $rootScope.$on(_msg.confLeaveUser, function(e, args){
        confList.removeUsersFromConf(args[0].UID, args[0].UIN);
    });

    $rootScope.$on(_msg.confKickUser, function(e, args){
        if (args[0].UIN == mcConst.UserInfo.UIN){
            webix.message(mcLang(550, [confList.getConfName(args[0].UID), args[0].ModerDisplayName])); // "550":"Вас изгнали из текстовой конференции \"%s\", модератор \"%s\"",

            confList.removeUsersFromConf(args[0].UID, args[0].UIN);
        } else {
            $rootScope.$broadcast('addCustomMSG', [mcLang(551, [args[0].ModerDisplayName, args[0].UserDisplayName])]); // "551":"Пользователь \"%s\" выгнал пользователя \"%s\" из конференции.",

            confList.removeUsersFromConf(args[0].UID, args[0].UIN);
        }
    });

    $rootScope.$on(_msg.getConfUsersList, function(e, args){
        var uid = args[0];
        var cb  = args[1];

        if (cb){
            cb(confList.getConfUsers(uid));
        }
    });

    $rootScope.$on(_msg.leaveConf, function(e, args){
        confList.leaveConf.apply(null, args);
    });

    $rootScope.$on(_msg.onConfHistory, function(e, args){
        confList.showConfHistory.apply(null, args);
    });

    $rootScope.$on(_msg.clearConfOnReconnect, function () {
        confList.clearUserList();
    });

    // --- History ---

    $rootScope.$on(_msg.historyRemoveUser, function (e, args) {
        historyList.removeUser.apply(null, args);
    });

    $rootScope.$on(_msg.loadHistoryDialogsList, function () {
        historyList.load();
    });

    // --- States ---

    $rootScope.$on(_msg.changeUserState, function (e, args) {
        var user = args[0];

        statuses.setUserState(user.UIN, user.State);

        privateList.statuses.set(user.UIN, user.State);
    });

    $rootScope.$on(_msg.getUserState, function(e, args){
        var uin = args[0];
        var cb  = args[1];

        if (cb) {
            cb(privateList.statuses.get(uin));
        }
    });

    $rootScope.$on(_msg.loadUserStatuses, function(){
        statuses.loadUserStatuses();
    });

    /* - Not Used - */ $rootScope.$on(_msg.getLastUserStates, function(e, args){
        var cb = args[0];

        if (cb) {
            cb(privateList.statuses.getAll());
        }
    });

    $rootScope.$on(_msg.onlineOfflineUsers, function(e, args){
        changeUserStatuses.apply(null, args);
    });

    // --- Other ---

    $rootScope.$on(_msg.getIgnoreList, function(e, args){
        $rootScope.$broadcast("SendCMDToServer", [
            mcConst._CMD_.cs_get_ignores_list,
            mcConst.SessionID,
            
            function( data ){
                var cb = args[0];

                ignoreList = getIgnoreList(data);

                if (cb){
                    cb(ignoreList);
                }
            }
        ])
    });

    $rootScope.$on(_msg.getUserIgnoreInfo, function(e, args){
        var uin = args[0].toString();
        var cb  = args[1];
        var res = null;

        if (ignoreList[uin]){
            res = ignoreList[uin];
        }

        if (cb) {
            cb(res);
        }
    });

    $rootScope.$on(_msg.removeDialogFromList, function(e, args){
        var uin = args[0];

        if (uin !== void(0)){
            $rootScope.$broadcast(window._messages_.dialogsCtrl.removePrivateFromDialogs, [uin]);

            privateList.removePrivate(uin);
        }
    });
}
/**
 * Created by Gifer on 21.07.2015.
 */

var _Dragging = function(){
    return {
        move : function(divid, xpos, ypos){
            divid.style.left = xpos + 'px';
            divid.style.top  = ypos + 'px';
        },
        startMoving : function(divid, container, evt){
            evt = evt || window.event;

            var posX  = evt.clientX,
                posY  = evt.clientY,
                diffX = posX - divid.offsetLeft,
                diffY = posY - divid.offsetTop,

                parent = document.getElementById(container),

                eWi = parseInt(divid.offsetWidth),
                eHe = parseInt(divid.offsetHeight),
                cWi = parseInt(parent.offsetWidth),
                cHe = parseInt(parent.offsetHeight);

            document.onmousemove = function(evt){
                evt = evt || window.event;

                var posX = evt.clientX,
                    posY = evt.clientY,
                    aX = posX - diffX,
                    aY = posY - diffY;

                if (aX < 0) aX = 0;
                if (aY < 0) aY = 0;
                if (aX + eWi > cWi) aX = cWi - eWi;
                if (aY + eHe > cHe) aY = cHe -eHe;

                _Dragging.move(divid,aX,aY);
            }
        },
        stopMoving : function(){
            document.onmousemove = function(){}
        }
    }
}();

// =================================================================

function setLocalizations(){
    webix.i18n.parseFormat = '%d.%m.%Y';
    webix.i18n.locales["en"] = webix.i18n.locales["en-US"];

    webix.i18n.locales["ru"]={
        groupDelimiter:",",
        groupSize:3,
        decimalDelimeter:".",
        decimalSize:2,

        dateFormat:"%d.%m.%Y",
        timeFormat:"%h:%i %A",
        longDateFormat:"%d %F %Y",
        fullDateFormat:"%d/%m/%Y %h:%i %A",

        price:"${obj}",
        priceSettings:null, //use number defaults


        fileSize: ["b","Kb","Mb","Gb","Tb","Pb","Eb"],

        calendar: {
            monthFull  : ["Январь", "Февраль", "Март", "Апрель", "Май", "Июнь", "Июль", "Август", "Сентябрь", "Октябрь", "Ноябрь", "Декабрь" ],
            monthShort : ["Янв", "Фев", "Мар", "Апр", "Май", "Июн", "Июл", "Авг", "Сен", "Окт", "Ноя", "Дек" ],
            dayFull    : ["Воскресенье", "Понедельник", "Вторник", "Среда", "Четверг", "Пятница", "Суббота"],
            dayShort   : ["Вс", "Пн", "Вт", "Ср", "Чт", "Пт", "Сб"],
            hours      : "Час",
            minutes    : "Минут",
            done       : "Готово"
        },
        controls:{
            select:"Выбрать"
        }
    };

    webix.i18n.locales["uk"]={
        groupDelimiter:",",
        groupSize:3,
        decimalDelimeter:".",
        decimalSize:2,

        dateFormat:"%d.%m.%Y",
        timeFormat:"%h:%i %A",
        longDateFormat:"%d %F %Y",
        fullDateFormat:"%d/%m/%Y %h:%i %A",

        price:"${obj}",
        priceSettings:null, //use number defaults


        fileSize: ["b","Kb","Mb","Gb","Tb","Pb","Eb"],

        calendar: {
            monthFull  : ["Січень", "Лютий", "Березень", "Квітень", "Травень", "Червень", "Липень", "Серпень", "Вересень", "Жовтень", "Листопад", "Грудень" ],
            monthShort : ["Січ", "Лют", "Бер", "Квт", "Тра", "Чер", "Лип", "Сер", "Вер", "Жов", "Лис", "Гру" ],
            dayFull    : ["Неділя", "Понеділок", "Вівторок", "Середа", "Четвер", "П'ятниця", "Субота"],
            dayShort   : ["Нд", "Пн", "Вт", "Ср", "Чт", "Пт", "Сб"],
            hours      : "Годинн",
            minutes    : "Хвилин",
            done       : "Готово"
        },
        controls:{
            select:"Обрати"
        }
    };
}

Date.prototype.startOfDay = function(){
    var now = this.getTime();

    return  now - (this.getHours()*1000*60*60 + this.getMinutes()*1000*60 + this.getSeconds()*1000 + this.getMilliseconds());
};

"use strict";

function mcMedia(mcSound, $rootScope) {
    var timer        = null;
    var mediaCall    = null;

    var mediaEvents  = new CallStates();
    var questionBox  = null;
    var callWnd      = null;
    var rejectTimer  = null;
    var UIN          = null;
    var cPanel       = null;

    var selfContainer  = document.createElement('video');
    var videoContainer = document.createElement('video');
    var audioContainer = document.createElement('audio');

    var Self   = this;
    var listCE = mediaEvents.list;

    this.Share       = false;
    this.MID         = 0;
    this.useVideo    = false;
    this.onShowMedia = null;
    this.onCloseCall = null;
    this.infoMessage = null;
    this.callStates  = {
        stopCall : 1,
        reject   : 2,
        close    : 3,
        error    : 4,
        busy     : 5,
        cancel   : 6,
        timeout  : 7
    };

    // ===================================

    mediaEvents.setUniversalStateEvent(function(){
        if (Self.infoMessage){
            Self.infoMessage.apply(null, arguments);
        }

        if (this !== listCE.outgoing_call_try      &&
            this !== listCE.outgoing_call_started  &&
            this !== listCE.outgoing_call_accepted &&
            this !== listCE.incoming_call_accepted &&
            this !== listCE.incoming_call_started  &&
            this !== listCE.incoming_call_try){

            mediaEvents.clearState();
        }
    });

    // ===================================

    function hideCallWnd(all) {
        clearTimeout(rejectTimer);

        if (questionBox && questionBox.parentNode) {
            webix.modalbox.hide(questionBox);
        }

        if (all && callWnd && callWnd.parentNode){
            webix.modalbox.hide(callWnd);
        }
    }

    function sendCandidate(){
        $rootScope.$broadcast('SendCMDToServer', [ mcConst._CMD_.cs_media_ice_candidate, mcConst.SessionID].concat([].slice.call(arguments)));
    }

    function onError(err){
        console.error(err);

        $rootScope.$broadcast('SendCMDToServer', [ mcConst._CMD_.cs_media_call_error, mcConst.SessionID, UIN]);

        mediaEvents.setStateEvent(listCE.outgoing_call_my_error, mcLang(498, err)); // "498":"Во время звонка возникла ошибка: %s",

        Self.CloseCall();
    }

    function sendOffer(){
        $rootScope.$broadcast('SendCMDToServer', [ mcConst._CMD_.cs_media_offer, mcConst.SessionID].concat([].slice.call(arguments)));
    }

    function sendAnswer() {
        $rootScope.$broadcast('SendCMDToServer', [ mcConst._CMD_.cs_media_answer, mcConst.SessionID].concat([].slice.call(arguments)));
    }

    function showMedia(){ // videoContainer
        if (!mediaCall.complete){
            timer.Start();

            mediaCall.complete = true;

            mcSound.Stop();

            if (callWnd && callWnd.parentNode){
                webix.modalbox.hide(callWnd);
            }

            cPanel = new Create_cPanel(mediaCall, mediaCall.useVideo, mediaCall.receiveScreen, videoContainer);

            if (Self.onShowMedia){
                Self.onShowMedia({
                    useVideo     : mediaCall.useVideo,
                    receiveScreen: mediaCall.receiveScreen,

                    video      : videoContainer,
                    audio      : audioContainer,
                    mirror     : selfContainer,
                    cPanel     : cPanel
                });
            }
        }
    }

    // ===================================

    this.setInfo = function (info, video, share) {
        mediaCall.useVideo      = video;
        mediaCall.receiveScreen = share;
        mediaCall.MID           = info.MID;

        mediaCall.addIceServers(mcService.makeIceServers(info, $rootScope.isWebClient), $rootScope.isWebClient ? "all" : mcConst.ClientSettings.IceTransportPolicy);
    };

    this.callQuestions = function (info, done){
        function answer(video){
            Self.setInfo(info, video, info.Share);

            $rootScope.$broadcast('SendCMDToServer', [ mcConst._CMD_.cs_media_call_accept, mcConst.SessionID, info.UIN, video, info.MID]);

            setTimeout(function () {
                $rootScope.$broadcast('SendCMDToServer', [ mcConst._CMD_.cs_media_ready, mcConst.SessionID, info.UIN]);
            }, 250);
        }

        function reject(){
            mcSound.Stop();
            mcSound.PlaySound(mcSound.Sounds.Reject);

            $rootScope.$broadcast('SendCMDToServer', [ mcConst._CMD_.cs_media_call_reject, mcConst.SessionID, info.UIN]);

            mediaEvents.setStateEvent(listCE.incoming_call_rejected, mcLang(506)); // "506":"Вы отказались принять звонок",
        }

        var btns = info.Video ?
            //       0                 1                   2
            [mcService.Lang(21), mcService.Lang(22), mcService.Lang(33)] : //"22" : "Видео", "21" : "Голос",  "33" : "Отмена",
            [mcService.Lang(21), mcService.Lang(33)]; // "21" : "Голос",  "33" : "Отмена",

        mediaEvents.isMyCall = false;
        mediaEvents.setCustomCallEvent(listCE.incoming_call_try);

        UIN = info.UIN;

        questionBox = webix.modalbox({
            buttons: btns,
            text   : mcService.Lang(39) + info.Nick, // "39" : "Входящий звонок",
            width  : "400px",
            callback: function(result){
                switch(result){
                    case '0':
                        answer(false);

                        if (done) done();
                    break;

                    case '1':
                        if (info.Video){
                            answer(true);

                            if (done) done();
                        } else {
                            reject();
                        }
                    break;

                    case '2':
                        reject();
                    break;
                }
            }
        });
    };

    this.myCall = function (_uin, video, share, done){
        function reject(timeout){
            clearTimeout(rejectTimer);

            $rootScope.$broadcast('SendCMDToServer', [ mcConst._CMD_.cs_media_call_reject, mcConst.SessionID, _uin]);

            mediaEvents.setStateEvent(listCE.outgoing_call_rejected, mcLang(507));  //"507":"Исходящий звонок прерван",

            Self.CloseCall(timeout ? Self.callStates.timeout : Self.callStates.cancel);

            mcSound.PlaySound(mcSound.Sounds.Reject);

            if (done) done();
        }

        mediaCall.Share = share;

        mediaEvents.isMyCall = true;

        callWnd = webix.alert({
            type : "alert-warning",
            ok   : mcLang(509), // "509":"Завершить",
            text : mcLang(510), // "510":"Ожидаем овет...",
            callback: function() {
                reject();
            }
        });

        rejectTimer = setTimeout(function(){
            reject(true);

            webix.modalbox.hide(callWnd);
        }, 30000);

        UIN = _uin;

        mediaEvents.setCustomCallEvent(listCE.outgoing_call_try);

        $rootScope.$broadcast('SendCMDToServer', [ mcConst._CMD_.cs_media_call, mcConst.SessionID, _uin, video, mediaCall.Share]);
    };

    this.prepare = function (){
        timer     = new mcService.MyTimer();
        mediaCall = new MediaCall();

        mediaCall.complete       = false;
        mediaCall.sendAnswer     = sendAnswer;
        mediaCall.sendOffer      = sendOffer;
        mediaCall.sendCandidate  = sendCandidate;
        mediaCall.onError        = onError;
        mediaCall.showMedia      = showMedia;

        videoContainer.id        = mcConst.videoStreamName;
        videoContainer.autoplay  = "autoplay";
        videoContainer.className = "VideoCaller";

        audioContainer.id        = mcConst.audioStreamName;
        audioContainer.autoplay  = "autoplay";
        audioContainer.className = "AudioCaller";

        selfContainer.id         = mcConst.mirrorStreamName;
        selfContainer.autoplay   = "autoplay";
        selfContainer.className  = "myVideo";
        selfContainer.muted      = "muted";

        Self.recvReady     = mediaCall.recvReady;
        Self.recvOffer     = mediaCall.recvOffer;
        Self.recvCandidate = mediaCall.recvCandidate;
        Self.recvAnswer    = function () {
            mediaEvents.setCustomCallEvent(listCE.outgoing_call_started);
            mediaCall.recvAnswer.apply(null, arguments);
        };

        return mediaCall;
    };

    this.CloseCall = function CloseCall(callType, params){
        hideCallWnd(true);

        mcSound.Stop();

        if (Self.onCloseCall){
            Self.onCloseCall({
                MID          : mediaCall.MID,
                receiveScreen: mediaCall.useVideo,
                useVideo     : mediaCall.receiveScreen,

                cPanel       : cPanel
            });
        }

        if (Self.nowCalling()) {
            var time          = timer.Stop();

            switch (callType){
                case Self.callStates.stopCall:
                    if (mediaEvents.isMyCall){
                        mediaEvents.setStateEvent(listCE.outgoing_call_my_close, mcLang(495, time)); // "495":"Исходящий звонок от меня, продолжительность %s",
                    } else {
                        mediaEvents.setStateEvent(listCE.incoming_call_my_close, mcLang(494, [params.DisplayName, time])); // "494":"Входящий звонок от %s, продолжительность %s",
                    }
                break;

                case Self.callStates.reject:
                    if (mediaEvents.isMyCall){
                        mediaEvents.setStateEvent(listCE.outgoing_call_rejected, mcLang(496)); // "496":"Пользователь отказался принять ваш звонок",
                    } else {
                        mediaEvents.setStateEvent(listCE.incoming_call_rejected, mcLang(500)); // "500":"Пропущен входящий звонок",
                    }
                break;

                case Self.callStates.close:
                    if (mediaEvents.isMyCall){
                        mediaEvents.setStateEvent(listCE.outgoing_call_remote_close, mcLang(495, time)); // "495":"Исходящий звонок от меня, продолжительность %s",
                    } else {
                        mediaEvents.setStateEvent(listCE.incoming_call_remote_close, mcLang(494, [params.DisplayName, time])); // "494":"Входящий звонок от %s, продолжительность %s",
                    }
                break;

                case Self.callStates.error:
                    mediaEvents.setStateEvent(
                        mediaEvents.isMyCall
                            ? listCE.outgoing_call_remote_error
                            : listCE.incoming_call_remote_error, mcLang(499)); // "499":"Во время звонка у вашего собеседника возникла ошибка",
                break;

                case Self.callStates.busy:
                    mediaEvents.setStateEvent(listCE.outgoing_call_busy, mcLang(501)); // "501":"Исходящий звонок от меня, занято.",
                break;

/*
                case Self.callStates.cancel:    // todo: add text
                    if (mediaEvents.isMyCall){
                        mediaEvents.setStateEvent(listCE.outgoing_call_cancelled);
                    } else {
                        mediaEvents.setStateEvent(listCE.incoming_call_cancelled);
                    }
                break;

                case Self.callStates.timeout:   // todo: add text
                    if (mediaEvents.isMyCall){
                        mediaEvents.setStateEvent(listCE.outgoing_call_cancelled_by_timeout);
                    } else {
                        mediaEvents.setStateEvent(listCE.incoming_call_cancelled_by_timeout);
                    }
                break;
*/
            }

            UIN = null;
            
            webix.message(mcLang(493)); // "493":"Сеанс связи закончен...",

            mediaCall.complete = false;
            mediaCall.hangUp();
        }

        mediaEvents.clearState();

        if (cPanel) {
            cPanel.destructor();
            cPanel = null;
        }
    };

    this.preShow = function (video){
        hideCallWnd();
        
        if (mediaEvents.isMyCall){
            mediaEvents.setCustomCallEvent(listCE.outgoing_call_accepted);
        } else {
            mediaEvents.setCustomCallEvent(listCE.incoming_call_started);
        }

        if (video || mediaCall.useVideo || mediaCall.receiveScreen) {
            mediaCall.setMirror(selfContainer);
            mediaCall.setCallee(videoContainer);
        } else {
            mediaCall.setCallee(audioContainer);
        }
    };

    this.nowCalling = function () {
        return mediaEvents.currentState() !== listCE.free;
    };

    this.getUIN = function () {
        return UIN;
    };
}
/**
 * Created by Gifer on 22.08.2017.
 */

function MCPrivatesList($rootScope, _drawMessage, _historyList, __statuses) {
    var __list     = {};
    var megaIdx    = 999999999;
    var DlgIdx     = 0;
    // var __offlineMsgList = [];

    __statuses.onStatesChange("privates", function (states) {
        Object.keys(__list).forEach(function (uin) {
            __setState(uin, states[uin]);
        });

        // __notifyOfflineMessages();
    });

    function __getPrivate(uin, noCopy) {
        var res = null;

        if (__list.hasOwnProperty(uin)){
            res = noCopy ? __list[uin] : mcService.Marge({}, __list[uin]);
        } else {
            console.warn("getPrivate: Privates list hasn't a private with UIN: " + uin);
        }

        return res;
    }

    function __needHistory(uin) {
        if (__list.hasOwnProperty(uin)){
            return __list[uin].needHistory;
        }
    }

    function __noHistory(uin) {
        if (__list.hasOwnProperty(uin)){
            __list[uin].needHistory = false;
        }
    }

    function __hasMessage(uin, idx) {
        var res  = __getPrivate(uin, true);

        if (res){
            res = res.hasMsgIdx(idx);
        }

        return res;
    }

    function __hasPrivate(uin) {
        return __list.hasOwnProperty(uin);
    }

    function __openPrivate(uin) {
        if (__hasPrivate(uin)) __getPrivate(uin, true).isOpen = true;
    }

    function __closePrivate(uin) {
        if (__hasPrivate(uin)) __getPrivate(uin, true).isOpen = false;
    }

    function __isOpen(uin) {
        if (__hasPrivate(uin)) return __getPrivate(uin, true).isOpen;
    }

    function __eachUser(func) {
        Object.keys(__list).forEach(function (uin) {
            func(uin, __list[uin]);
        });
    }

    function __addPrivateMessage(uin, Idx, read) {
        var res = false;

        if (__hasPrivate(uin)){
            var user = __getPrivate(uin, true);

            if (user.messagesList.indexOf(Idx) === -1) {
                user.messagesList.push(Idx);
            }

            if (user.IDMsgLast <= Idx){ // новый месадж || (user.IDMsgLast === -1 && Idx !== -1)) {
                user.IDMsgLast = Idx;

                if (user.IDMsgGot <= Idx) {
                    user.IDMsgGot = Idx;

                    if (read){
                        user.IDMsgRead = Idx;
                    }

                    res = true;
                }
            }

            if (user.firstMsgIdx >= Idx || (user.firstMsgIdx === megaIdx && Idx !== -1)) {
                user.firstMsgIdx = Idx;
            }
        }

        return res;
    }

    function __getTopInListMsgIdx(uin) {
        return __hasPrivate(uin) ? __list[uin].firstMsgIdx : megaIdx;
    }

    function __getBottomInListMsgIdx(uin) {
        return __hasPrivate(uin) ? __list[uin].IDMsgLast : -1;
    }

    function __getLastGotMsgIdx(uin) {
        return __hasPrivate(uin) ? __list[uin].IDMsgGot : 0;
    }

    function __getUpSyncCount(uin) {
        return __hasPrivate(uin) ? __list[uin].upSync : 0;
    }

    function __getLastReadMsgIdx(uin) {
        return __hasPrivate(uin) ? __list[uin].IDMsgRead : -1;
    }

    function __getMsgIdx(uin, idx) {
        return !__list.hasOwnProperty(uin) || !__list[uin].hasMsgIdx(idx);
    }

    function __drawHistoryMessages(inData){
        //                                                       //     "UINWith" : 17, // (5.24+) пользователь, с которым был приватный разговор
        // [{                                                    //     "Data"    :[{
        //     Idx: 57435                                        //         "UIN"     : 98,                   // кто отправил сообщение
        //     Msg: "L$люди реально есть: *6-220915110051.jpg"   //         "dtUTC"   : "2015.09.01.17.18.35" // когда (UTC)
        //     MsgType: 1                                        //         "MsgType" : 1,                    // тип сообщения
        //     State: 3                                          //         "State"   : 3,                    // статус сообщения
        //     UIN: 6                                            //         "Idx"     : 75,                   // уникальный индекс разговора (пары uin1/uin2)
        //     dt: "22.09.2015.12.10.26"                         //         "Msg"     : "Hello!"              // тело сообщения
        // }]                                                    //     }]
        var source = inData.Data;
        var uin    = inData.UINWith;

        if (source && source.length){
            for ( var i = source.length - 1; i >= 0; i-- ) {
                var UINFrom = source[i].UIN;

                if (source[i].Mod !== mcConst._CMD_.msgMods.DELETED && __getMsgIdx(UINFrom, source[i].Idx)){
                    var user    = source[i].UIN == mcConst.UserInfo.UIN ? mcConst.UserInfo : __getPrivate(source[i].UIN, true);
                    var UINTo   = source[i].UIN == mcConst.UserInfo.UIN ? uin              : mcConst.UserInfo.UIN;

                    if (user){
                        var out     = {
                            UINFrom   : UINFrom,
                            UINTo     : UINTo,
                            Nick      : user.Nick || user.DisplayName,
                            StateFrom : user.State,
                            Sex       : user.Sex,
                            Mod       : source[i].Mod,
                            Idx       : source[i].Idx,
                            Msg       : source[i].Msg,
                            dtUTC     : source[i].dtUTC || source[i].dt,
                            MsgType   : source[i].MsgType,
                            noNotify  : true,
                            History   : true  
                        };

                        __privateMessage(out);
                    } else {
                        console.warn("User UIN: " + source[i].UIN + " closed. History skipped.");

                        break;
                    }
                }
            }
        }
    }

    function __drawUpSyncHistoryMessages(inData){
        //     "UINWith" : 17,                       // (5.24+) пользователь, с которым был приватный разговор
        //     "Data"    :[{
        //         "UIN"     : 98,                   // кто отправил сообщение
        //         "dtUTC"   : "2015.09.01.17.18.35" // когда (UTC)
        //         "MsgType" : 1,                    // тип сообщения
        //         "State"   : 3,                    // статус сообщения
        //         "Idx"     : 75,                   // уникальный индекс разговора (пары uin1/uin2)
        //         "Msg"     : "Hello!"              // тело сообщения
        //     }]
        
        var source = inData.Data;
        var uin    = inData.UINWith;

        if (source && source.length){
            for ( var i = 0; i <= source.length - 1; i++ ) {
                var UINFrom = source[i].UIN;

                if (source[i].Mod !== mcConst._CMD_.msgMods.DELETED && __getMsgIdx(UINFrom, source[i].Idx)){
                    var user     = source[i].UIN == mcConst.UserInfo.UIN ? mcConst.UserInfo    : __getPrivate(source[i].UIN, true);
                    var UINTo    = source[i].UIN == mcConst.UserInfo.UIN ? uin                 : mcConst.UserInfo.UIN;
                    var lastRead = source[i].UIN != mcConst.UserInfo.UIN ? __getMyMsgRead(uin) : false;

                    if (user){
                        var out     = {
                            UINFrom   : UINFrom,
                            UINTo     : UINTo,
                            Nick      : user.Nick || user.DisplayName,
                            StateFrom : user.State,
                            Sex       : user.Sex,
                            Mod       : source[i].Mod,
                            Idx       : source[i].Idx,
                            Msg       : source[i].Msg,
                            dtUTC     : source[i].dtUTC || source[i].dt,
                            MsgType   : source[i].MsgType,
                            noNotify  : lastRead && source[i].Idx <= lastRead, // false,
                            History   : false,
                            UpSync    : lastRead && source[i].Idx <= lastRead
                        };

                        __privateMessage(out);
                    } else {
                        console.warn("User UIN: " + source[i].UIN + " closed. History skipped.");

                        break;
                    }
                }
            }
        }
    }

    function __getPrivateHistory(uin, count){
        if ($rootScope.isWebClient || (mcConst.ClientSettings.SysEventsLoadHistoryType && mcConst.ClientSettings.LoadHistoryToPrivate)){
            __noHistory(uin);

            $rootScope.$broadcast('SendCMDToServer', [
                mcConst._CMD_.cs_sync_private_history_last,
                mcConst.SessionID,
                uin,
                count || mcConst.countHistoryMessagesLoad
            ]);
        }
    }

    function __syncPrivateHistory(uin) {
        var range = __getTopInListMsgIdx(uin);

        if (range.toString() !== '-1'){
            if (range > mcConst.countHistoryMessagesLoad) {
                range = (range - mcConst.countHistoryMessagesLoad) + "-" + range;
            } else {
                range = "1-" + range;
            }

            $rootScope.$broadcast('SendCMDToServer', [
                mcConst._CMD_.cs_sync_private_history,
                mcConst.SessionID,

                uin,
                range
            ]);
        }
    }

    function __upSyncPrivateHistory(uin, next) {
        var range = __getBottomInListMsgIdx(uin);

        if (range.toString() !== '-1'){
            var got    = __getLastGotMsgIdx(uin);
            var upSync = __getUpSyncCount(uin);

            if (upSync){
                range = upSync;
            } else
            if (range === got){
                return; //
            } else
            if (range > got) {
                range = (got + 1) + "-" + range;
            } else {
                range = "1-" + range;
            }


            $rootScope.$broadcast('SendCMDToServer', [
                mcConst._CMD_.cs_sync_private_history,
                mcConst.SessionID,

                uin,
                range,
                next || __drawUpSyncHistoryMessages
            ]);
        }
    }

    // === My Messages ====

    function __setMyMsgReadState(uin, state) {
        if (__hasPrivate(uin)){
            var user = __getPrivate(uin, true);

            user.myMsg = mcService.Marge(user.myMsg, state);
        }
    }

    function __setMyMsgRead(uin, idx) {
        if (__hasPrivate(uin)){
            __getPrivate(uin, true).myMsg.IDMyMsgRead = idx;
            __getPrivate(uin, true).myMsg.IDMyMsgGot  = idx;
        }
    }

    function __setMyMsgGot(uin, idx) {
        if (__hasPrivate(uin)){
            __getPrivate(uin, true).myMsg.IDMyMsgGot = idx;
        }
    }

    function __getMyMsgReadState(uin) {
        if (__hasPrivate(uin)){
            return __getPrivate(uin, true).myMsg;
        }
    }

    function __getMyMsgRead(uin) {
        return __hasPrivate(uin) ? __getPrivate(uin, true).myMsg.IDMyMsgRead : 0;
    }

    function __getMyMsgGot(uin) {
        return __hasPrivate(uin) ? __getPrivate(uin, true).myMsg.IDMyMsgGot : 0;
    }

    // ====================

    function __getPrivateNick(uin) {
        return __list[uin].DisplayName;
    }

    function __showPrivate(uin) {
        if ($rootScope.GetChatTypeID() !== $rootScope.createUIN(uin) && !__getMyMsgGot()){
            __openPrivate(uin);

            $rootScope.SendCMDToServer([
                mcConst._CMD_.cs_private_get_dialog_msg_states,
                mcConst.SessionID,

                uin,
                function (data) {
                    __setMyMsgReadState(data.UIN, {
                        UIN        : data.UIN,
                        IDMyMsgGot : data.IDMsgGot,
                        IDMyMsgRead: data.IDMsgRead
                    });

                    $rootScope.$broadcast("updateMessagesState", [data.UIN]);
                }
            ]);

            $rootScope.SetPrivate(uin);

            $rootScope.needFoto = !!__list[uin].FotoCRC32;

            $rootScope.$broadcast('addNewPrivateDialog', [uin.toString(), __getPrivateNick(uin), __statuses.getUserState(uin)]);
            $rootScope.$broadcast('fillChatFrame',       [__getPrivateNick(uin), "", (__getTopInListMsgIdx(uin) !== megaIdx) || __needHistory(uin)]);
            $rootScope.$broadcast("changeCenterView",    [mcConst.dataModels.ChatFrame]);
            $rootScope.$broadcast('selectTool',          [mcConst.dataModels.PrivateInfo]);

            if (__needHistory(uin)) {
                __getPrivateHistory(uin);
            }
        }

        var lastID = __getBottomInListMsgIdx(uin);
        var readID = __getPrivate(uin, true).IDMsgRead;

        if (lastID > 0 && lastID !== readID && mcConst.isWindowFocused){
            __getPrivate(uin, true).IDMsgRead = lastID;

            $rootScope.SendCMDToServer([
                mcConst._CMD_.cs_private_msg_read,
                mcConst.SessionID,

                uin,
                lastID
            ]);
        }
    }

    function __addPrivate(userPrivate) {
        var res = false;

        if (userPrivate && userPrivate.UIN != mcConst.UserInfo.UIN){
            if (__hasPrivate(userPrivate.UIN)){
                userPrivate = mcService.Marge(__list[userPrivate.UIN], userPrivate);
            } else {
                res = true;
                // DlgIdx
                userPrivate.needHistory  = true;
                userPrivate.isOpen       = false;
                userPrivate.messagesList = [];
                userPrivate.firstMsgIdx  = megaIdx;
                userPrivate.IDMsgGot     = userPrivate.IDMsgGot  || 0;
                userPrivate.IDMsgLast    = userPrivate.IDMsgLast || 0;
                userPrivate.IDMsgRead    = userPrivate.IDMsgRead || 0;
                userPrivate.hasMsgIdx    = function (idx) {
                    return userPrivate.messagesList.indexOf(idx) !== -1;
                };
            }

            userPrivate.DisplayName = userPrivate.Nick || userPrivate.DisplayName;
            userPrivate.myMsg       = {
                IDMyMsgRead : userPrivate.IDMyMsgRead || 0,
                IDMyMsgGot  : userPrivate.IDMyMsgGot  || 0
            };

            // console.log(userPrivate);

            __list[userPrivate.UIN] = userPrivate;

            if (userPrivate.hasOwnProperty('State')){
                __statuses.setUserState(userPrivate.UIN, userPrivate.State);
            }
        }

        return res;
    }

    function __removePrivate(uin) {
        if (__hasPrivate(uin)){
            delete __list[uin];

            $rootScope.SendCMDToServer([
                mcConst._CMD_.cs_del_private_dialog,
                mcConst.SessionID,

                uin
            ]);

            return true;
        }
    }

    function __setState(uin, state) {
        if (__hasPrivate(uin)){
            __getPrivate(uin, true).State = __statuses.setUserState(uin, state);

            $rootScope.$broadcast('changeStateForUser', [uin, state]);

            return true;
        }
    }

    function __loadPrivatesFromStorage(){
        var userList = null;
        var task     = new mcService.TaskList();
        var isReconnect = false;

        task.AddTask(function () {
            $rootScope.$broadcast('SendCMDToServer', [
                mcConst._CMD_.cs_get_private_dialogs,
                mcConst.SessionID,

                function (data) {
                    userList = data;

                    task.Next();
                }
            ]);
        });

        task.AddTask(function () {
            //"DlgIdx" : 7145, // индекс последнего изменения приватных диалогов
            //"Data"   : [
            //    {
            //        "UIN"         : 17,                    // идентификатор собеседника
            //        "IDMsgLast"   : 4567,                  // ID последнего отправленного сообщения
            //        "IDMsgGot"    : 4560,                  // ID последнего полученного сообщения
            //        "IDMsgRead"   : 4560,                  // ID последнего прочитанного сообщения
            //        "dt"          : "26.11.2012.09.18.31", // дата и время последнего сообщения в UTC в формате dd.mm.yyyy.hh.nn.ss.zzz
            //        "DisplayName" : "John Smith",          // отображаемое имя собеседника в чате
            //        "Avatar"      : 1234245435,            // CRC32 контрольная сумма фотографии пользователя
            //        "Sex"         : 1                      // пол пользователя, 0 - unknown, 1 - male, 2 - female
            //    },

            isReconnect = !mcService.isObjectEmpty(__list);

            __closeAllPrivates();

            while (userList.Data.length){
                var user = userList.Data.pop();

                if (user) {
                    user.State = mcConst.states.offline;

                    if (isReconnect && DlgIdx && userList.DlgIdx > DlgIdx && __hasPrivate(user.UIN) &&
                        __getBottomInListMsgIdx(user.UIN) < user.IDMsgLast && __getMyMsgRead(user.UIN) < user.IDMsgRead)
                    {
                        user.upSync      = (__getBottomInListMsgIdx(user.UIN) + 1) + "-" + user.IDMsgLast;
                        user.IDMyMsgRead = user.IDMsgRead;
                        user.IDMyMsgGot  = user.IDMsgGot;
                    } else {
                        user.upSync = "";
                    }

                    __addPrivate(user);

                    if (!isReconnect) {
                        $rootScope.$broadcast('updateCounter', [user, true]); // true - не увеличивать счетчик, а взять только разницу msg.IDMsgLast - msg.IDMsgRead
                    }
                }
            }

            DlgIdx = userList.DlgIdx;
            
            __statuses.loadUserStatuses();

            task.Next();
        });

        task.AddTask(function () {
            __eachUser(function (uin, user) {
                if (isReconnect) {
                    __upSyncPrivateHistory(uin);
                }

                if (user.IDMsgGot < user.IDMsgLast) {
                    $rootScope.SendCMDToServer([
                        mcConst._CMD_.cs_private_msg_got,
                        mcConst.SessionID,

                        user.UIN,
                        user.IDMsgLast
                    ]);

                    user.IDMsgGot = user.IDMsgLast;
                }
            });

            task.Next();
        });

        task.Run();
    }

    function __privateMessage(msg){
        if (msg.hasOwnProperty('UIN') && !msg.hasOwnProperty('UINFrom')){
            msg.UINFrom = msg.UIN;

            delete msg.UIN;
        }

        msg.UINTo   = msg.UINTo.toString();
        msg.UINFrom = msg.UINFrom.toString();
        msg.dt      = mcService.utcTime(msg);

        if (msg.hasOwnProperty('UINFrom')) {
            msg.Idx = msg.Idx || msg.MsgIdx;

            if (msg.UINFrom != mcConst.UserInfo.UIN && !__hasPrivate(msg.UINFrom)) {
                __addPrivate({
                    UIN      : msg.UINFrom.toString(),
                    Nick     : msg.Nick,
                    IDMsgLast: msg.Idx
                });
            }

            var _priv = __getPrivate(msg.UINFrom != mcConst.UserInfo.UIN ? msg.UINFrom : msg.UINTo);

            if (_priv){
                _drawMessage(msg);

                if (!msg.History){
                    _historyList.addOrUpdateUser(_priv, msg.dt);
                }
            }
        } else {
            console.error('No user info in message: ');
            console.log(msg);
        }
    }

    function __clearPrivates() {
        __list = {};
    }
    
    function __closeAllPrivates() {
        __eachUser(__closePrivate);
    }

    // ==========================================

    this.showPrivate = __showPrivate;

    this.addPrivate = function (info) { // onlyAdd используется при вычитке списка приватов с хранилища, поэтому не нужно его дабвлять в историю или сразу показывать в окне
        if (__addPrivate(info)) {
            if (info && info.UIN != mcConst.UserInfo.UIN){
                _historyList.addOrUpdateUser(info, mcService.formatDate(new Date(), 'dd.mm.yyyy.hh.nn.ss'));
            }
        }

        __showPrivate(info.UIN);
    };

    this.updateUserInfo = function (uin, info) {
        if (__list.hasOwnProperty(uin)){
            __list[uin] = mcService.Marge(__list[uin], info);

            __setState(info.UIN, info.State);
        } else
        if (uin != mcConst.UserInfo.UIN){
            console.warn("updateUserInfo: Can't update user info for UIN: " + uin)
        }
    };

    this.getPrivateHistory = __getPrivateHistory;

    this.hasPrivate = __hasPrivate;

    this.hasMessage = __hasMessage;

    this.addMessage = __addPrivateMessage;

    this.isOpen = __isOpen;

    this.closeAllPrivates = __closeAllPrivates;

    this.getPrivateInfo = function (uin) {
        return __getPrivate(uin);
    };

    this.removePrivate = function (uin) {
        if (__removePrivate(uin)){
            // __savePrivatesToStorage();
        }
    };

    this.setState = __setState;

    this.getFirstIdx = __getTopInListMsgIdx;

    this.getLastIdx = __getBottomInListMsgIdx;

    this.getReadIdx = __getLastReadMsgIdx;

    this.setMyMsgGot = __setMyMsgGot;

    this.setMyMsgRead = __setMyMsgRead;

    this.getMyMsgReadState = __getMyMsgReadState;

    this.loadFromStorage = __loadPrivatesFromStorage;

    this.statuses = {
        get: __statuses.getUserState,
        set: __setState,
        getAll: __statuses.getAllState
    };

    this.sendMessage = __privateMessage;

    this.clearPrivates = __clearPrivates;

    //this.offlineMessage = __offlineMessage;  // 7.2 офлайн мессаджей больше нет

    this.getHistoryMsgRange = __syncPrivateHistory;

    this.drawHistoryMessages = __drawHistoryMessages;

    this.upSyncPrivateHistory = __upSyncPrivateHistory;
}
/**
 * Created by Gifer on 22.08.2017.
 */

function MCConferenceList($rootScope, _drawMessage, __statuses, mcPlaySound) {
    var __list = {};
    var __timerShowConf = null;
    var __uidToShow = null;
    var megaIdx    = 999999999;
    var getConfHistoryTimeout = null;

    __statuses.onStatesChange("confs", function () {
        var currentChat = $rootScope.GetChatType();
        var currentID   = $rootScope.GetChatID();

        __getConfList().forEach(function (uid) {
            var offline = [];

            __getConfUsers(uid, true).forEach(function (user) {
                if (user.UIN.toString() !== "0" && __statuses.getUserState(user.UIN) == mcConst.states.offline) {
                    var users = __getConfUsers(user.UIN, true);
                    var idx   = mcService.findItemInArrayOfObj(users, user.UIN, "UIN");

                    offline.push(user.UIN);

                    users.splice(idx, 1);
                }
            });

            if (currentChat === $rootScope.chatAliases.UID && currentID == uid){
                $rootScope.$broadcast(window._messages_.confUsers.removeUserFromConf, [offline]);
            }
        });
    });

    function __hasConf(uid){
        return __list.hasOwnProperty(uid);
    }

    function __getConfList() {
        return Object.keys(__list) || [];
    }

    function __getConf(uid, noCopy) {
        var res = null;

        if (__hasConf(uid)){
            res = noCopy ? __list[uid] : mcService.Marge({}, __list[uid]);
        } else {
            console.warn("getConf: Conference list hasn't a conf with UID: " + uid);
        }

        return res;
    }

    function __getConfUsers(uid, noCopy) {
        var res = [];

        if (__hasConf(uid)){
            if (noCopy){
                res = __list[uid].users;
            } else {
                __list[uid].users.forEach(function (user) {
                    res.push(mcService.Marge({}, user));
                });
            }
        } else {
            console.warn("getConfUsers: Conference list hasn't a conf with UID: " + uid);
        }

        return res;
    }

    function __getConfName(uid) {
        return __list[uid].Name || "";
    }

    function __showConf(uid, pass){
        if (__hasConf(uid)){
            $rootScope.SetConf(uid);

            $rootScope.$broadcast('fillChatFrame',    [__getConf(uid, true).Name, __getConf(uid, true).Topic, true]);
            $rootScope.$broadcast("changeCenterView", [mcConst.dataModels.ChatFrame]);
            $rootScope.$broadcast('selectTool',       [mcConst.dataModels.ConfUserList]);

            if (!__list[uid].hasHistory){
                __getConfHistory(uid);
            }
        } else {
            $rootScope.$broadcast('SendCMDToServer', [
                mcConst.lockInterface,
                mcConst._CMD_.cs_join_txt_channel,
                mcConst.SessionID,
                uid,
                pass || "",

                function (data) {
                    $rootScope.$broadcast("selectDialog",     ["UID-" + data.UID]);
                }
            ]);
        }
    }

    function __addConf(newConf){
        var uid = newConf.UID;

        if (getConfHistoryTimeout){
            clearTimeout(getConfHistoryTimeout);
            getConfHistoryTimeout = null;
        }

        if (!__hasConf(uid)){
            __list[uid] = mcService.Marge(newConf, {
                users       : [],
                messagesList: [],
                hasHistory  : false,
                firstConvID : megaIdx,
                lastConvID  : 0,
                hasMsgIdx   : function (idx) {
                    return this.messagesList.indexOf(idx) !== -1;
                }
            });

            $rootScope.$broadcast('addNewConfToDialogs', [uid, __getConfName(uid)]);

            if (!getConfHistoryTimeout){
                getConfHistoryTimeout = setTimeout(function () {
                    __getConfHistory(uid);

                    getConfHistoryTimeout = null;
                }, 100);
            }
        } else {
            var delta = newConf.ConvID - __getLastMsgIdx(uid);

            __list[uid] = mcService.Marge(newConf, __list[uid]);

            __getConfHistory(uid, delta);
        }

        __addUsersToConf(uid, [{
            UIN        : mcConst.UserInfo.UIN,
            DisplayName: mcConst.UserInfo.Nick,
            Sex        : mcConst.UserInfo.Sex,
            State      : mcConst.UserInfo.State
        }]);

        if ($rootScope.GetChatType() !== $rootScope.chatAliases.UID) {
            __showConf(uid);
        }
    }

    function __removeConf(uid) {
        if (__hasConf(uid)){
            delete __list[uid];

            return true;
        }
    }

    function __addUsersToConf (uid, users){
        if (__hasConf(uid)){
            var userList = __getConfUsers(uid, true);

            while (users.length > 0) {
                var currentUser = users[0];

                currentUser.id = currentUser.UIN.toString();

                if (!currentUser.DisplayName){
                    currentUser.DisplayName = currentUser.Nick;
                }

                var idx = mcService.findItemInArrayOfObj(userList, currentUser.UIN, 'UIN');

                if (idx < 0){
                    userList.push(currentUser);
                } else {
                    userList[idx] = currentUser;
                }

                users.shift();
            }

            if ($rootScope.GetChatID() == uid && $rootScope.GetChatType() === $rootScope.chatAliases.UID){
                $rootScope.$broadcast(window._messages_.confUsers.addUserToConf, [__getConfUsers(uid)]);
            }

            if ($rootScope.isWebClient || mcConst.ClientSettings.SoundsSndJoin) {
                mcPlaySound.PlaySound(mcPlaySound.Sounds.JoinConf);
            }

            $rootScope.$broadcast(window._messages_.dialogsCtrl.updateChUserCount, [uid, userList.length]);
        } else {
            console.log('__addUsersToConf: uid=' + uid + ' not in list');
        }
    }

    function __removeUsersFromConf(uid, uin){
        if (__hasConf(uid)){
            var userList = __getConfUsers(uid, true);

            userList.splice(mcService.findItemInArrayOfObj(userList, uin, 'UIN'), 1);

            if ($rootScope.GetChatID() == uid && $rootScope.GetChatType() === $rootScope.chatAliases.UID) {
                $rootScope.$broadcast(window._messages_.confUsers.removeUserFromConf, [uin.toString()]);
            }

            if ($rootScope.isWebClient || mcConst.ClientSettings.SoundsSndLeave) {
                mcPlaySound.PlaySound(mcPlaySound.Sounds.LeaveConf);
            }

            if (uin == mcConst.UserInfo.UIN){
                $rootScope.$broadcast(window._messages_.dialogsCtrl.removeConfFromDialogs, [uid]);

                __removeConf(uid);
            } else {
                $rootScope.$broadcast(window._messages_.dialogsCtrl.updateChUserCount, [uid, userList.length]);
            }
        }
    }

    function __leaveConf(uid){
        if (__hasConf(uid)) {
            $rootScope.$broadcast('SendCMDToServer', [
                mcConst._CMD_.cs_leave_txt_channel,
                mcConst.SessionID,
                uid
            ]);
        }
    }

    function __getConfHistory(uid, count, more){
        if (__hasConf(uid) && ($rootScope.isWebClient || (mcConst.ClientSettings.SysEventsLoadHistoryType && mcConst.ClientSettings.LoadHistoryToConf))) {
            if (!count) {
                __getConf(uid, true).noNeedHistory = true;
            }

            __list[uid].hasHistory = true;

            if (more){
                var range = (__getFirstMsgIdx(uid) - mcConst.countHistoryMessagesLoad) + "-" + (__getFirstMsgIdx(uid) - 1);

                $rootScope.$broadcast('SendCMDToServer' , [
                    mcConst._CMD_.cs_sync_conf_history,
                    mcConst.SessionID,

                    uid,
                    range,

                    function (data) {
                        data.Users = mcService.convertArrayToObj(data.Users, "UIN");
                        
                        __showConfHistory(data, false);
                    }
                ]);
            } else {
                $rootScope.$broadcast('SendCMDToServer' , [
                    mcConst._CMD_.cs_get_channel_history_messages,
                    mcConst.SessionID,

                    uid,
                    mcConst.historyTypes.count,
                    count || mcConst.countHistoryMessagesLoad,
                    "", "", "", // >From >To >List

                    function (data) {
                        __showConfHistory(data, !!count);
                    }
                ]);
            }
        }
    }

    function __showConfHistory(source, notHistory){
        function _inner_showMessage(msg) {
            if (msg.Mod != mcConst._CMD_.msgMods.DELETED) {

                msg.DisplayName = msg.DisplayName || source.Users[msg.UIN].DisplayName;
                msg.Idx  = msg.Idx || msg.MsgIdx;
                msg.UIN  = msg.UIN.toString();
                msg.Nick = msg.DisplayName;
                msg.UID  = uid;
                msg.dt   = mcService.utcTime(msg);
                msg.History = !notHistory;

                _drawMessage(msg, true);
            }

            setTimeout(function () {
                currentCnt = currentCnt >= sleepCount ? 0 : currentCnt;

                var first = !notHistory ? messages.pop() : messages.shift();

                if (first) {
                    _inner_showMessage(first);
                }
            }, currentCnt >= sleepCount ? 200 : 2);
        }

        var messages   = mcService.isString(source.Data) ? JSON.parse(source.Data.replace(/\r\n/g, "\\r\\n")) : source.Data;
        var uid        = source.UID;
        var sleepCount = 100;
        var currentCnt = 0;

        var first = !notHistory ? messages.pop() : messages.shift();

        if (first) {
            _inner_showMessage(first);
        }
    }

    function __confMessage(msg) {
        var uid = msg.UID;

        if (__hasConf(uid)){
            var userList = __getConfUsers(uid, true);

            msg.Nick = userList[mcService.findItemInArrayOfObj(userList, msg.UIN, 'UIN')].DisplayName;
            msg.Idx  = msg.Idx || msg.MsgIdx;
            msg.UIN  = msg.UIN.toString();
            msg.dt   = mcService.utcTime(msg);

            _drawMessage(msg);

            if (msg.MsgType !== mcConst._CMD_.msgType.ADM_DELETE_MESSAGE && ($rootScope.isWebClient || mcConst.ClientSettings.SoundsSndChat)){
                mcPlaySound.PlaySound(mcPlaySound.Sounds.ConfMsg);
            }
        }
    }

    function __hasMessage(uid, idx) {
        var res  = __getConf(uid, true);

        if (res){
            res = res.hasMsgIdx(idx);
        }

        return res;
    }

    function __addMessage(uid, idx) {
        if (__hasConf(uid)){
            var conf = __getConf(uid, true);

            if (conf.messagesList.indexOf(idx) === -1) {
                conf.messagesList.push(idx);
            }

            if (conf.lastConvID <= idx){
                conf.lastConvID = idx;
            }

            if (conf.firstConvID >= idx){
                conf.firstConvID = idx;
            }
        }
    }

    function __getLastMsgIdx(uid) {
        return __hasConf(uid) ? __list[uid].lastConvID : 0;
    }

    function __getFirstMsgIdx(uid) {
        return __hasConf(uid) ? __list[uid].firstConvID : megaIdx;
    }

    function __clearUserList() {
        for (var uid in __list){
            __list[uid].users = [];
        }
    }

    // ----------------------------

    this.showConf = __showConf;

    this.addConf = __addConf;

    this.addUsersToConf = __addUsersToConf;

    this.removeUsersFromConf = __removeUsersFromConf;

    this.leaveConf = __leaveConf;

    this.getConfHistory = __getConfHistory;

    this.showConfHistory = __showConfHistory;

    this.confMessage = __confMessage;

    this.getConf = __getConf;

    this.clearUserList = __clearUserList;

    this.hasMessage = __hasMessage;

    this.addMessage = __addMessage;

    this.getConfList = __getConfList;

    this.getConfUsers = __getConfUsers;

    this.getConfName = __getConfName;
}
/**
 * Created by Gifer on 22.08.2017.
 */

function MCStatusesList($rootScope) {
    var __userOnlineStatuses = {};
    var __onChange = {};

    function __clearState() {
        __userOnlineStatuses = {};
    }

    function __getAllStates() {
        return mcService.Marge({}, __userOnlineStatuses);
    }

    function __setUserState(uin, state) {
        if (uin.toString() === '0'){
            __userOnlineStatuses[uin] = mcConst.states.online;
        } else {
            __userOnlineStatuses[uin] = state === undefined ? mcConst.states.offline : parseInt(state);
        }

        mcService.setStatusForUser(uin, __userOnlineStatuses[uin]);

        return __userOnlineStatuses[uin];
    }

    function __loadUserStatuses(){
        $rootScope.$broadcast('SendCMDToServer', [
            mcConst._CMD_.cs_get_online_users_states,
            mcConst.SessionID,

            function (states){
                if (states.Users && states.Statuses) {
                    states.Users    = states.Users.split(',');
                    states.Statuses = states.Statuses.split(',');

                    __clearState();

                    states.Users.forEach(function (uin, id) {
                        __setUserState(uin, states.Statuses[id]);
                    });

                    __setUserState(0, mcConst.states.online);

                    Object.keys(__onChange).forEach(function (name) {
                        __onChange[name](__getAllStates());
                    });

                    $rootScope.$broadcast('allUsersOnlineStatusesChanged', [__getAllStates()]);
                }
            }
        ]);
    }

    function __getUserState(uin) {
        return __userOnlineStatuses.hasOwnProperty(uin) ? __userOnlineStatuses[uin] : mcConst.states.offline;
    }

    function __removeState(uin) {
        if (__userOnlineStatuses.hasOwnProperty(uin)){
            delete __userOnlineStatuses[uin];

            return true;
        }
    }

    function __onStatesChange(name, func) {
        __onChange[name] = func;
    }

    function __removeChangeHandler(name) {
        if (__onChange.hasOwnProperty(name)){
            delete __onChange[name];
        } else {
            console.warn('removeChangeHandler: Not found name: ' + name);
        }
    }

    // ----------------------------

    this.setUserState = __setUserState;

    this.getUserState = __getUserState;

    this.removeState  = __removeState;

    this.getAllState  = __getAllStates;

    this.clearState   = __clearState;

    this.loadUserStatuses = __loadUserStatuses;

    this.onStatesChange = __onStatesChange;

    this.removeChangeHandler = __removeChangeHandler;
}
/**
 * Created by Gifer on 22.08.2017.
 */

function MCHistoryDialogsList($rootScope) {
    var __list = {};

    function getList() {
        var res = {};

        Object.keys(__list).forEach(function (uin) {
            res[uin] = mcService.Marge({}, __list[uin]);
        });

        return res;
    }

    function getItem(uin) {
        var res = null;

        if (__list.hasOwnProperty(uin)){
            res = mcService.Marge({}, __list[uin]);
        }

        return res;
    }

    function updateItem(uin, name, dt) {
        if (!__list.hasOwnProperty(uin)){
            __list[uin] = {
                DisplayName  : name,
                UIN          : uin
            };
        }

        __list[uin].dtLastMessage = dt;
    }

    // ----------------------------

    this.load = function () {
        $rootScope.Storage.historyDialogs.load(mcConst.UserInfo.UIN, mcConst.storageOpts.HISTORYDLG, function (data) {
            if (data){
                __list = mcService.StringToObj(data);

                $rootScope.$broadcast(window._messages_.historyDialogs.dListFillHistory, [getList()]);
            }
        });
    };

    this.addOrUpdateUser = function(userInfo, dt) {
        var uin = userInfo.UINFrom || userInfo.UIN;

        updateItem(uin, userInfo.DisplayName, dt);

        $rootScope.Storage.historyDialogs.save(mcConst.UserInfo.UIN, mcConst.storageOpts.HISTORYDLG, __list, function () {
            $rootScope.$broadcast(window._messages_.historyDialogs.dListAddOrModifyUser, [
                getItem(uin)
            ]);
        });
    };

    this.removeUser = function (uin) {
        if (__list.hasOwnProperty(uin)){
            delete __list[uin];

            $rootScope.Storage.historyDialogs.save(mcConst.UserInfo.UIN, mcConst.storageOpts.HISTORYDLG, __list);
        } else {
            console.error("History list has't UIN: " + uin);
        }

        $rootScope.$broadcast(window._messages_.historyDialogs.dListHistoryRemoveUser, [uin]);
    };

    this.getHistoryList = function () {
        return getList();
    }
}

function McFramesList() {
    var _list = {};
    var self  = this;
    var chatTextOutput = null;

    function createFrame(frame) {
        var element = null;

        if (window.mcService.isHtmlElement(frame) && frame.id){
            element = frame;
        } else

        if (window.mcService.isString(frame)){
            element = document.getElementById(frame) || document.createElement('div');

            element.className = "framePaddingР30x10";
            element.id = frame;
        } else {
            console.error("Can't create or find frame: ");
            console.error(frame);
        }

        if (element){
            element.show = function () { self.show(element.id) };
            element.hide = function () { self.hide(element.id) };

            _list[element.id] = element;

            chatTextOutput.appendChild(element);
        }

        return element;
    }

    function get (frame, noCreate) {
        return _list[frame] ? _list[frame] : (noCreate ? null : createFrame(frame));
    }

    this.get    = get;
    this.create = createFrame;

    this.clear  = function (_frame){
        var frame = get(_frame);

        if (frame) {
            frame.innerHTML = "";
        }
    };

    this.remove = function (_frame) {
        // var frame = get(isNaN(parseInt(_frame)) ? _frame : 'UID-' + _frame);
        var frame = get(_frame, true);

        if (frame) {
            if (_list[frame.id]) {
                delete _list[frame.id];
            }

            frame.parentElement.removeChild(frame);
        }
    };

    this.show = function (frame) {
        get(frame).style.display = 'block';
    };

    this.hide = function (frame) {
        get(frame).style.display = 'none';
    };

    this.hasFrame = function (frame) {
        return _list.hasOwnProperty(frame);
    };

    this.initView = function (view) {
        chatTextOutput = view;
    }
}
function UsersCustomOptions($rootScope) {
    var uOptionList = {
        // 3: {
        //     autoReceive: true
        // }
    };
    var saveTimeout = null;

    // ------------------------------
    
    function __hasUin(uin) {
        return uOptionList.hasOwnProperty(uin);
    }
    
    function __save() {
        // uOptionList[uin] = data;

        $rootScope.Storage.dialogs.save(mcConst.ServerInfo.ID, mcConst.UserInfo.UIN, mcConst.storageOpts.cUserOpt, JSON.stringify(uOptionList));
    }

    // ------------------------------

    this.load = function () {
        $rootScope.Storage.dialogs.load(mcConst.ServerInfo.ID, mcConst.UserInfo.UIN, mcConst.storageOpts.cUserOpt, function (data) {
            uOptionList = mcService.StringToObj(data) || {};
        });
    };

    this.saveAll = __save;

    this.getUser = function (uin) {
        return __hasUin(uin) ? uOptionList[uin] : {};
    };

    this.getOption = function (uin, name) {
        return __hasUin(uin) ? uOptionList[uin][name] : null;
    };

    this.setUser = function (uin, opt) {
        if (mcService.isObject(opt)){
            uOptionList[uin] = opt;
        } else {
            console.warn("UsersCustomOptions.setUser: can't save options, is not an object!");
        }
    };

    this.setUserOption = function (uin, name, val) {
        if (!__hasUin(uin)){
            uOptionList[uin] = {};
        }

        uOptionList[uin][name] = val;

        if (!saveTimeout){
            saveTimeout = setTimeout(function () {
                __save();
            }, 100);
        }
    }
}/**
 * Created by Gifer on 11.08.2016.
 */

"use strict";

function CtrlServersManager($rootScope) {
    var serversInfo   = $rootScope.acConfig.serversInfo;
    var currentServer = mcConst.ServerInfo;/* || {
        Port : null,
        Host : null,
        ID   : null
    };*/

    this.getServerInfoByID = function (id) {
        return serversInfo.hasOwnProperty(id) ? mcService.Marge({}, serversInfo[id]) : null;
    };

    this.addServerInfo = function (info) {
        if (mcService.isObject(info) && info.ID){
            serversInfo[info.ID] = serversInfo[info.ID] ? mcService.Marge(serversInfo[info.ID], info) : info;

            return serversInfo[info.ID];
        } else {
            console.error('addServerInfo incorrect data: ' + info);

            return false;
        }
    };

    this.hasServerByID = function (id) {
        return serversInfo.hasOwnProperty(id);
    };

    this.setCurrentServerByID = function (id) {
        if (serversInfo.hasOwnProperty(id)){
            currentServer.Port = serversInfo[id].Port;
            currentServer.Host = serversInfo[id].ServHost;
            currentServer.ID   = id;
            currentServer.IPv6 = mcService.isValidIpAddressV6(serversInfo[id].ServHost);
            currentServer.Secured = serversInfo[id].Secured;

            return mcService.Marge({}, serversInfo[id]);
        } else {
            currentServer.Port = null;
            currentServer.Host = null;
            currentServer.ID   = null;
            currentServer.IPv6 = false;
            currentServer.Secured = false;

            return false;
        }
    };

    this.getCurrentServer = function () {
        return mcService.Marge({}, currentServer);
    };

    this.removeServerByID = function (id) {
        if (serversInfo.hasOwnProperty(id)){
            delete serversInfo[id];
        } else {
            console.error('removeServerByID, unknown id: ' + id);
        }
    };

    this.mapServers = function (cb) {
        var res = [];
        var srv = null;

        for (var i in serversInfo){
            srv = mcService.Marge({}, serversInfo[i]);

            var info = cb ? cb(srv) : srv;

            if (info){
                res.push(info);
            }
        }

        return res;
    };

    this.getServerIdByOrderPosition = function (pos) {
        return Object.keys(serversInfo)[pos];
    };

    this.getServerIdByServID = function (serverID) {
        var id = null;

        for (var i in serversInfo){
            if (serversInfo[i].ServerID == serverID){
                id = serversInfo[i].ID;

                break;
            }
        }

        return id;
    };

    this.getAutoConnectInfo = function (cb) {
        $rootScope.$broadcast("sendCMDToElectron", [
            mcConst._CMD_.ce_load_autoconnect_server,
            cb
        ]);
    };

    this.setAutoConnectInfo = function (pwd, rm, srvpwd) {
        $rootScope.$broadcast("sendCMDToElectron", [
            mcConst._CMD_.ce_save_autoconnect_server,
            pwd,
            rm,
            srvpwd,
            mcConst.UserInfo.UIN,
            mcConst.LoginInfo.login
        ]);
    };
}
/**
 * Created by Gifer on 28.08.2016.
 */

function initClientData($scope, $rootScope, sendCMD, mcStatistics) {
    mcConst.ClientSettings = {
        "NetworkReconnectTime" : "10",
        "GeneralShowSendButton" : "1",
        "GeneralConfirmExit" : "1",
        "GeneralMainWindow" : "0",
        "GeneralCtrlEnterSend" : "0",
        "GeneralSpellCheck" : "1",
        "GeneralDoubleClickPagesClose" : "1",
        "SpecialMessagesFontSize" : "1",
        "SoundsAllSoundsOff" : "0",
        "EventsPopupOnNewBBS" : "1",
        "EventsPopupOnChannelMessage" : "0",
        "EventsPopupOnPrivateMessage" : "0",
        "EventsTimeStamp" : "1",
        "EventsShowPopupTrayWindow" : "1",
        "EventsTrayBBSMsg" : "1",
        "EventsTrayChMsg" : "1",
        "EventsTrayPvMsg" : "1",
        "EventsTrayBlinkOnTaskBar" : "1",
        "EventsTrayDontHide" : "0",

        "SoundsSndNewMsg" : "1",
        "SoundsSndBadWord" : "1",
        "SoundsSndLeave" : "1",
        "SoundsSndJoin" : "1",
        "SoundsSndChatType" : "1",
        "SoundsSndChatBS" : "1",
        "SoundsSndStatus" : "1",
        "SoundsSndError" : "1",
        "SoundsSndPrivate" : "1",
        "SoundsSndChatRet" : "1",
        "SoundsSndSignal" : "1",
        "SoundsSndChat" : "1",
        "SoundsSndBroadcast" : "1",
        "SoundsSndFilesExchangeRequest" : "1",
        "SoundsSndFilesExchangeDone" : "1",
        "SoundsSndScreenShot" : "1",
        "SoundsSndMediaBusy" : "1",
        "SoundsSndMediaCall" : "1",
        "SoundsSndMediaCallReject" : "1",
        "SoundsSndMediaEndCall" : "1",
        "SoundsSndMediaIncomingCall" : "1",

        "SoundsSndNewMsgFile" : "newmsg.mp3",
        "SoundsSndBadWordFile" : "badword.mp3",
        "SoundsSndLeaveFile" : "leave.mp3",
        "SoundsSndJoinFile" : "join.mp3",
        "SoundsSndChatTypeFile" : "chattype.mp3",
        "SoundsSndChatBSFile" : "chatbs.mp3",
        "SoundsSndStatusFile" : "status.mp3",
        "SoundsSndErrorFile" : "error.mp3",
        "SoundsSndPrivateFile" : "private.mp3",
        "SoundsSndChatRetFile" : "chatret.mp3",
        "SoundsSndSignalFile" : "signal.mp3",
        "SoundsSndChatFile" : "chat.mp3",
        "SoundsSndBroadcastFile" : "broadcast.mp3",
        "SoundsSndScreenShotFile" : "screenshot.mp3",
        "SoundsSndFilesExchangeRequestFile" : "filesrequest.mp3",
        "SoundsSndFilesExchangeDoneFile" : "filesdone.mp3",
        "SoundsSndMediaBusyFile" : "mediabusy.mp3",
        "SoundsSndMediaCallFile" : "mediacall.mp3",
        "SoundsSndMediaCallRejectFile" : "mediacallreject.mp3",
        "SoundsSndMediaEndCallFile" : "mediaendcall.mp3",
        "SoundsSndMediaIncomingCallFile" : "mediaincomingcall.mp3",

        // ------------------------------------------

            "NetworkSecured" : "0",
            "NetworkProxyType" : "0",
            "NetworkProxyHost" : "",
            "NetworkProxyPort" : "1080",
            "NetworkProxyAuth" : "0",
            "NetworkProxyUserName" : "",
            "NetworkProxyUserPass" : "",

            "GeneralWindowsStart" : "1",
            "GeneralStartPassword" : "0",
            "GeneralDailyUpdatesCheck" : "1",
            "GeneralOpenPrivateByOneClick" : "1",
            "GeneralFadeWindows" : "1",

        "GeneralShowUsersCounterOnTheTabs" : "1",
            "GeneralShowMainToolsPanel" : "1",


            "GeneralTipOfTheDayNum" : "3",
            "GeneralShowTipOfTheDay" : "0",
            "GeneralDisableAvatars" : "1",
        "GeneralQuickMsgAutoSend" : "0",

            "GeneralAutoHideMainWindow" : "0",
        "GeneralRememberOpenContactGroups" : "",

            "EventsDateTimeStampFormat" : "[hh:nn:ss]",
        "EventsTrayWindowDuration" : "5",
        "EventsOpenPrivateOnPersonalOrAlert" : "0",

        "HotKeysHotKeyMyChat" : "<Win>+F12",
        "HotKeysHotKeyMyChatScreenShot" : "<Win>+F9",
        "HotKeysUseGlobalHotKeys" : "1",
        "HotKeysEscHide" : "1",

        "SmileysSmileysSet" : "classic",

        "SysEventsShowSysEvents" : "1",
        "SysEventsEnterTxtxCh" : "1",
        "SysEventsLeaveTxtxCh" : "1",
        "SysEventsQuitChat" : "1",
        "SysEventsChangeTheme" : "1",
        "SysEventsBanUser" : "1",
        "SysEventsTurnOut" : "1",
        "SysEventsIgnore" : "1",
        "SysEventsConnectionLost" : "1",
        "SysEventsConnectionRestored" : "1",
        "SysEventsDisableEmotions" : "0",
        "SysEventsEnableSmileysAnimation" : "1",
        "SysEventsAutoreplaceSmileys" : "1",
        "SysEventsUseMessagesFontLayouts" : "1",
        "SysEventsLoadHistoryType" : "1",
        "SysEventsHistory_1_Num" : "50",
        "SysEventsAutoFillBroadcastUsersList" : "1",
        "SysEventsShowImagesInChat" : "1",
        "SysEventsImagesThumbsSize" : "2",

        "LogsServer" : "1",
        "LogsTxtChannels" : "1",
        "LogsPrivates" : "1",
        "LogsFiles" : "1",

        "SecurityOptionsPassword" : "",
        "LanguagesLanguage" : "russian.ini",

        // "SendFilesInputFilesDir" : "%s\\Documents\\MyChat\\",
        "SendFilesInputFilesDir" : "",
        "SendFilesBasePort" : "10000",
        "SendFilesDataPort" : "10001",
        "SendFilesBufferSize" : "3",
        "SendFilesSayYes" : "0",
        "SendFilesRememberSelectInputFilesFolder" : "1",
        "SendFilesRandomPorts" : "1",
        "SendFilesRandomPortStart" : "10000",
        "SendFilesRandomPortEnd" : "20000",
        "SendFilesRenameRecievedDuplicates" : "",

        "Colorscolor_ch_pv_back" : "13758972",
        "Colorscolor_inp_back" : "13758972",
        "Colorscolor_userslist_back" : "13758972",
        "Colorscolor_userslist_text" : "0",
        "Colorscolor_own_nick_text" : "255",
        "Colorscolor_active_link" : "255",
        "Colorscolor_visited_link" : "8388736",
        "Colorscolor_timestamp" : "10526880",
        "Colorscolor_hello_nick" : "13209",
        "Colorscolor_users_nick_text" : "16711680",

        "UpdateUseAccountForUpdates" : "0",
        "UpdateUpdateLogin" : "",
        "UpdateUpdatePassword" : "",
        "UpdateUpdateDomain" : "",
        "UpdateForceUpdateFromMyChatServerInActiveDirectory" : "0",


        "SpecialToolsPanelType" : "1",
        "SpecialPagesPanel" : "3",

        "AdditionalPrivateInfoFields" : "EMAIL,WORK_PHONE,WORK_DIVDEPT,HOME_BIRTHDAY",
        "AdditionalProgramCaption" : "%program% %ver% - %nickname% %company% (%state%)",
        "AdditionalSystemTrayText" : "",

        "InterfaceTrayIconListNumber" : "0",
        "InterfaceCommonBackground" : "",
        "InterfaceBackgroundPlacement" : "",

        "MediaNetworkTransportTCP" : "1",
        "MediaNetworkTransportUDP" : "1",
        "IceTransportPolicy" : "all",

        "LoadHistoryToConf" : "1",
        "LoadHistoryToPrivate" : "1"
    };

    function quitFromMyChat() {
        if (mcConst.LoggedIn) {
            removeHotKeys();
            
            sendCMD([mcConst._CMD_.ce_hide_window], true);

            if (mcStatistics && mcStatistics.saveStat) {
                mcStatistics.saveStat(mcConst.ServerInfo.ID, mcConst.UserInfo.UIN, function () {
                    sendCMD([mcConst._CMD_.ce_quit_from_program], true);
                });
            }

            mcConst.LoggedIn = false;

            sendCMD([
                mcConst._CMD_.cs_quit,
                mcConst.SessionID
            ]);
        } else {
            setTimeout(function () {
                sendCMD([mcConst._CMD_.ce_quit_from_program], true);
            }, 10);
        }
    }

    function hideMyChat() {
        sendCMD([mcConst._CMD_.ce_hide_program], true);
    }

    function logout() {
        $rootScope.$broadcast(window._messages_.mainMenu.logoutMenu);
    }

    function toggleMinMaxScreen() {
        sendCMD([mcConst._CMD_.ce_toggle_min_max], true);
    }

    function toggleKioskScreen(value) {
        sendCMD([mcConst._CMD_.ce_toggle_kiosk, value], true);
    }

    function registerHotKeys() {
        $rootScope.hotKeyDispatcher.addPreset(SYSTEM_PRESET, [{
            key   : mcConst.keyCodes.x,
            altKey: true,
            func  : function () {
                if (mcConst.ClientSettings.GeneralConfirmExit){
                    $rootScope.$broadcast(window._messages_.main.confirmExit, [quitFromMyChat]);
                } else {
                    quitFromMyChat();
                }
            }
        }, {
            key   : mcConst.keyCodes.esc,
            func  : hideMyChat
        }, {
            key   : mcConst.keyCodes.f11,
            func  : toggleMinMaxScreen
        }, {
            key   : mcConst.keyCodes.a,
            altKey: true,
            func  : logout
        }], document);

        sendCMD([
            mcConst._CMD_.ce_hide_or_close_by_x,
            false // hide window by click close btn
        ], true);
    }

    function removeHotKeys() {
        $rootScope.hotKeyDispatcher.removePreset(SYSTEM_PRESET);
    }

    function getClientConnectInfo(cb) {
        sendCMD([
            mcConst._CMD_.ce_get_client_settings,

            function (data) {
                mcConst.ClientSettings     = mcService.Marge(mcConst.ClientSettings, mcService.StringToObj(data.client_settings) || {});
                mcConst.ClientDbVer        = data.verdb;
                mcConst.ClientSettingsData = data;
                mcConst.settingsCRC32      = data.settings_crc32;

                $rootScope.UNIT.ctrlServersManager.setCurrentServerByID($rootScope.UNIT.ctrlServersManager.getServerIdByServID(mcConst.ClientSettings.ServID));

                if (mcConst.ClientSettings.ServID === null) {
                    mcConst.LoginInfo.rm = false;
                }

                if (cb){
                    cb();
                }
            }
        ], true);
    }

    function applyClientSettings() {
        // --- SpecialMessagesFontSize ---

        var cssStyle  = document.styleSheets[document.styleSheets.length - 1];
        var styleName = "._messagesFontSize .messageText, ._messagesFontSize .messageUserName, ._messagesFontSize .messageKanban";

        if (cssStyle.cssRules.length > 1){
            cssStyle.removeRule(0);
        }

        switch (mcConst.ClientSettings.SpecialMessagesFontSize){
            case "0":
                cssStyle.addRule(styleName, "font-size: 85%", 0);
            break;

            case "1":
                cssStyle.addRule(styleName, "font-size: 100%", 0);
            break;

            case "2":
                cssStyle.addRule(styleName, "font-size: 110%", 0);
            break;
            
            case "3":
                cssStyle.addRule(styleName, "font-size: 120%", 0);
            break;
        }

        // --- GeneralShowSendButton ---

        var sendBtn = $$("btnSendText");

        if (sendBtn){
            sendBtn[mcConst.ClientSettings.GeneralShowSendButton ? "show" : "hide"]();
        }

        // --- GeneralSpellCheck ---

        if ($rootScope.spellCheckManager){
            if (mcConst.ClientSettings.GeneralSpellCheck){
                if (!$rootScope.spellCheckManager.stat()) {
                    $rootScope.spellCheckManager.start(mcConst.Lang);
                }
            } else {
                $rootScope.spellCheckManager.stop();
            }
        }

        // --- GeneralDoubleClickPagesClose ---


        // --- SysEventsImagesThumbsSize ---
        
        $rootScope.thumbsSize = mcConst.imageSize[mcConst.ClientSettings.SysEventsImagesThumbsSize];

        // --- SysEventsHistory_1_Num ---

        mcConst.countHistoryMessagesLoad = mcConst.ClientSettings.SysEventsHistory_1_Num;
    }

    // ==================================================

    var SYSTEM_PRESET = "SYSTEM_EVENTS";

    $rootScope.UNIT     = {
        ctrlServersManager : new CtrlServersManager($rootScope)
    };
    $rootScope.clientSysInfo = {};

    $rootScope.$broadcast('prepareElectron');

    //===================================================

    $scope.prepareActions = function (lang) {
        // == GET CLIENT SETTINGS ===============================
        var task = new mcService.TaskList();

        sendCMD([
            mcConst._CMD_.ce_set_language,
            lang
        ], true);

        if (!webix.storage.local.get(mcConst.storageFields.AutoRld)){
            task.AddTask(function () {
                sendCMD([
                    mcConst._CMD_.ce_load_autoconnect_server,
                    function (info) {
                        mcConst.LoginInfo.login   = info.nick || info.uin;
                        mcConst.LoginInfo.pwd     = info.pwd;
                        mcConst.LoginInfo.servPwd = info.srvpwd;
                        mcConst.LoginInfo.rm      = mcService.convertIntToBool(info.autoconnect);

                        task.Next();
                    }
                ], true)
            });
        } else {
            mcService.ClearSessionSettings(true);
        }

        task.AddTask(function () {
            sendCMD([
                mcConst._CMD_.ce_get_server_list,
                function (servers) {
                    for (var srv in servers) {
                        $rootScope.UNIT.ctrlServersManager.addServerInfo(servers[srv]);
                    }

                    task.Next();
                }
            ], true);
        });

        task.AddTask(function () {
            getClientConnectInfo(task.Next);
        });

        task.AddTask(function () {
            $scope.$broadcast('show' + mcConst.dataModels.Login, [lang]);

            applyClientSettings();
        });

        task.Run();
        // ======================================================
    };

    //===================================================

    var _msg = window._messages_.clientData = {
        sendCMDToElectron   : 'sendCMDToElectron',
        enableGlobalHotKeys : 'enableGlobalHotKeys',
        disableGlobalHotKeys: 'disableGlobalHotKeys',
        saveCurrentServerID : 'saveClientSettings',
        saveClientSettings  : 'saveClientSettings',
        quitFromProgram     : 'quitFromProgram',
        getSystemInfo       : 'getSystemInfo',
        getClientConnectInfo: 'getClientConnectInfo',
        toggleKioskMode      : 'toggleKioskMode'
    };

    $scope.$on(_msg.getClientConnectInfo, function (e, args) {
        var cb = args[0];

        getClientConnectInfo(cb);
    });

    $scope.$on(_msg.toggleKioskMode, function (e, args) {
        toggleKioskScreen.apply(null, args);
    });

    $scope.$on(_msg.sendCMDToElectron, function (e, args) {
        sendCMD(args, true);
    });

    $scope.$on(_msg.enableGlobalHotKeys, registerHotKeys);

    $scope.$on(_msg.disableGlobalHotKeys, function () {
        removeHotKeys();

        sendCMD([
            mcConst._CMD_.ce_hide_or_close_by_x,
            true // close program by click close btn
        ], true);
    });

    $scope.$on(_msg.saveCurrentServerID, function (e, args) {
        mcConst.ClientSettings.ServID = args && args.length ? args[0] : mcConst.ClientSettings.ServID;

        sendCMD([
            mcConst._CMD_.ce_set_client_settings,
            mcConst.ClientSettings
        ], true);

        applyClientSettings();
    });

    $scope.$on(_msg.getSystemInfo, function (e, cb) {
        sendCMD([
            mcConst._CMD_.ce_get_mc_client_info,
            function (info) {
                $rootScope.clientSysInfo = info;

                if (cb) {
                    cb();
                }
            }
        ], true);
    });

    $scope.$on(_msg.quitFromProgram, function (e, halt) {
        if (mcConst.ClientSettings.GeneralConfirmExit && !halt){
            $rootScope.$broadcast(window._messages_.main.confirmExit, [quitFromMyChat]);
        } else {
            quitFromMyChat();
        }
    } );
}/**
 * Created by Gifer on 25.09.2017.
 */
"use strict";

function McTextFinder($rootScope) {
    var textDiv   = "messageText";
    var openSpan  = '<fndel class="findItem" tabindex="0">';
    var openText  = '``open``';
    var closeSpan = '</fndel>';
    var closeText = '``close``';
    var hasResult = false;
    var currentText = "";
    var currentIdx  = 0;
    var findRes   = [];
    var pos       = 0;

    function focusElem(searchField) {
        pos = mcService.getCaretPosition(searchField.getInputNode());

        if (findRes[currentIdx]){
            findRes[currentIdx].focus();
            findRes[currentIdx].className += " findItemSelected";
        }

        searchField.focus();

        mcService.setCaretPosition(searchField.getInputNode(), pos);
    }

    function findText(frame, text, searchField){
        text = mcService.trim(text.toLowerCase());

        if (text !== "" && text !== currentText){
            if (hasResult) {
                clear(frame);
            }

            pos = 0;

            var msgDivList = frame.getElementsByClassName(textDiv);

            for (var idElm = 0; idElm < msgDivList.length; idElm ++ ) {
                var items = msgDivList[idElm].childNodes;
                var item;

                for (var chdID = 0; chdID < items.length; chdID ++ ){
                    item = items[chdID];

                    if (item.nodeName === "#text" || item.nodeName === "A"){
                        var byType   = item.nodeName === "A" ? "innerHTML" : "data";
                        var itemText = item[byType].toLowerCase();

                        if (itemText.length >= text.length && !(item.nodeName === "A" && item.innerText === "")){
                            var idx = itemText.indexOf(text);
                            var res = {};

                            if (idx !== -1) {
                                while (idx !== -1){
                                    res[idx] = openText;
                                    res[idx + text.length] = closeText;

                                    idx = itemText.indexOf(text, idx + 1);
                                }

                                item[byType] = item[byType].insertTextAtIndices(res);

                                hasResult = true;
                            }
                        }
                    }
                }

                if (hasResult){
                    msgDivList[idElm].innerHTML =
                        msgDivList[idElm].innerHTML
                            .replace(new RegExp(openText , "g"), openSpan)
                            .replace(new RegExp(closeText, "g"), closeSpan);
                }
            }

            currentText = text;

            findRes = document.getElementsByClassName("findItem");

            currentIdx = 0 ;

            focusElem(searchField);
        } else

        if (text === currentText && findRes[currentIdx]){
            findRes[currentIdx].className = findRes[currentIdx].className.replace(" findItemSelected", "");
            
            currentIdx ++;

            if (currentIdx === findRes.length){
                currentIdx = 0;
            }

            focusElem(searchField);
        }
    }

    function clear(frame) {
        var msgDivList = frame.getElementsByClassName(textDiv);

        if (findRes[currentIdx] && findRes[currentIdx].className) {
            findRes[currentIdx].className = findRes[currentIdx].className.replace(" findItemSelected", "");
        }

        for (var i = 0; i < msgDivList.length; i++){
            msgDivList[i].innerHTML = msgDivList[i].innerHTML.replace(new RegExp(openSpan, "g"), "").replace(new RegExp(closeSpan, "g"), "");
        }

        hasResult = false;

        currentText = "";
    }

    String.prototype.insertTextAtIndices = function(text) {
        return this.replace(/./g, function(character, index) {
            return text[index] ? text[index] + character : character;
        });
    };

    // ==================================

    var _msg = window._messages_.textFinder = {
        find_chat_text  : "find_chat_text",
        find_clear      : "find_clear"
    };

    $rootScope.$on(_msg.find_chat_text, function (e, args) {
        findText.apply(null, args);
    });

    $rootScope.$on(_msg.find_clear, function (e, args) {
        clear.apply(null, args);
    });
}

function McSpellChecker() {
    var webFrame           = require('electron').webFrame;
    var SpellCheckProvider = require('electron-spell-check-provider');
    var spellLang          = "";
    var _spellchecker      = null;
    var enabled            = false;

    this.start = function (Lang) {
        switch (Lang){
            case 'ru': spellLang = "ru_RU"; break;
            case 'en': spellLang = "en_US"; break;

            default: spellLang = "en_US";
        }

        if (spellLang){
            _spellchecker = new SpellCheckProvider(spellLang);

            webFrame.setSpellCheckProvider(spellLang, true,
                _spellchecker.on('misspelling', function(suggestions) {
                    var text = window.getSelection().toString();

                    if (text) {
                        _spellchecker.addMenuItems({
                            isMisspelled        : true,
                            spellingSuggestions : suggestions.slice(0, 4)
                        });
                    }
                })
            );

            enabled = true;
        }
    };

    this.stop = function () {
        if (enabled){
            webFrame.setSpellCheckProvider(spellLang, false, {
                spellCheck: function (txt) {
                    return true;
                }
            });
        }

        enabled = false;
    };

    this.stat = function () {
        return enabled;
    };
} "use strict";

 (function () {
     if (window.mcWidgets){
         window.mcWidgets.ButtonsListWithContext = function ButtonsListWithContext($rootScope){
             function show(btn, options, list, fillParams){
                 var wndId = mcService.RandomHash(7);

                 if (mcService.isString(list)) {
                     list = $$(list);
                 }

                 $rootScope.hotKeyDispatcher.addPreset(wndId, [{
                     key : mcConst.keyCodes.enter,
                     lockPrev: true,
                     func: function(){
                         var form = btn.dialog.getChildViews()[1];

                         if (btn.confirm.apply(form, [].concat(form.getChildViews()).concat(list ? list.getSelectedItem() : [])) !== true) {
                             // если возвращает true, то зыкрывать диалоговое окно не нужно, в поле для ввода текста есть ошибка и т.д.
                             btn.dialog.close();
                         }
                     }
                 }, {
                     key : mcConst.keyCodes.esc,
                     lockPrev: true,
                     func: function(){
                         btn.dialog.close();
                     }
                 }], document, true);

                 btn.dialog = webix.ui(mcService.Marge(options, {
                     view     : "window",
                     position : "center",
                     id       : wndId,
                     head     : btn.title,
                     body     : {
                         view : 'form',
                         rules:{
                             "Name"    : webix.rules.isNotEmpty
                         },
                         elements : [{
                             view       : "text",
                             label      : btn.editTitle,
                             name       : 'Name',
                             labelPosition : 'top',
                             required   : "true"
                         }]
                         .concat(btn.additionalItems ? btn.additionalItems : [])
                         .concat({
                             cols : [{
                                 view  : "button",
                                 value : btn.okTitle,
                                 click : function() {
                                     var form = this.getFormView();

                                     if (btn.confirm.apply(form, [].concat(form.getChildViews()).concat(list ? list.getSelectedItem() : [])) !== true) { // если возвращает true, то зыкрывать диалоговое окно не нужно, в поле для ввода текста есть ошибка и т.д.
                                         btn.dialog.close();
                                     }
                                 }
                             }, {
                                 view  : "button",
                                 type  : "danger",
                                 value : btn.cancelTitle,
                                 click : function(){
                                     btn.dialog.close();

                                     if (btn.abort){
                                         btn.abort();
                                     }
                                 }
                             }]
                         })
                     },
                     on : {
                         onShow : function(){
                             if (fillParams) {
                                 this.getChildViews()[1].getChildViews().forEach(function(item, id){
                                     if (btn.fillItems[id] != undefined) item.setValue(list.getSelectedItem()[btn.fillItems[id]]);
                                 });
                             }

                             this.getChildViews()[1].getChildViews()[0].focus();

                             // $rootScope.$broadcast('addShowedWindow', [wndId, this]); // сообщаем менеджеру переходов между экранами, что появилось новое окно и его нужно закрыть при изменении экрана
                         },
                         onDestruct : function(){
                             $rootScope.hotKeyDispatcher.removePreset(wndId);
                         }
                     }
                 }));

                 if (!btn.onBeforeShow || (btn.onBeforeShow && btn.onBeforeShow.apply(btn, [list.getSelectedItem(), list]))){
                     btn.dialog.show();
                 } else {
                     btn.dialog.close();
                 }
             }

             var self = this;
             var params = [];

             this.editButtons = function(_params){
                 var resButtons = {};

                 params = mcService.Marge({
                     buttons   : [{
                         additionalItems: [],
                         type           : 'add', // add, edit, del
                         confirm        : null,
                         abort          : null,
                         addToContext   : false,
                         showedInList   : true,
                         css            : '',
                         contextCss     : '',
                         label          : '',
                         icon           : '',
                         contextIcon    : '',
                         title          : '',
                         editTitle      : '',
                         fillItems      : [],
                         delName        : '',
                         onBeforeShow   : null,
                         onBeforeDelete : null
                     }],

                     fillItems : [],
                     list      : null,
                     vertical  : false,
                     onHideContext: null,
                     onShowContext: null,

                     options   : {
                         modal : true,
                         head  : '',
                         width : 300
                     },
                     contextOpt: {
                         width: 200
                     }
                 }, _params);

                 var btnsList  = [];
                 var direction = params.vertical ? "rows" : "cols";

                 params.buttons.forEach(function (btn) {
                     var _btn = {};

                     function closeContext() {
                         if (btn.addToContext && self.contextMenu){
                             if (self.contextMenu) {
                                 self.contextMenu.hide();
                             }
                         }
                     }

                     switch (btn.type){
                         case 'add':
                             _btn = { view: "button", click: function(){ // "50" : "Добавить",
                                 closeContext();

                                 show(btn, params.options, params.list);
                             }};
                         break;

                         case 'edit':
                             _btn = { view: "button", click: function(){ // "51" : "Изменить",
                                 closeContext();

                                 show(btn, params.options, params.list, true);
                             }};
                         break;

                         case 'del':
                             _btn = { view: "button", type: "danger", click: function(){ // "52" : "Удалить",
                                 closeContext();

                                 if (mcService.isString(params.list)) {
                                     params.list = $$(params.list);
                                 }

                                 var item = params.list.getSelectedItem();

                                 if (item && (!btn.onBeforeDelete || (btn.onBeforeDelete && btn.onBeforeDelete.apply(btn, [item, params.list])))){
                                     $rootScope.$broadcast('addShowedWindow', [mcService.RandomHash(4), webix.confirm({
                                         type  : "confirm-warning",
                                         text  : mcService.myReplace(btn.title, btn.delName ? item[btn.delName] : null), // "902":"Удалить должность \"%s\"?",
                                         ok    : btn.delTitle,
                                         cancel: btn.cancelTitle,
                                         callback:function(yes){
                                             if (yes){
                                                 btn.confirm(item);
                                             }
                                         }
                                     })]);
                                 }
                             }};
                         break;
                     }

                     if (!btn.fillItems || !btn.fillItems.length){
                         btn.fillItems = params.fillItems;
                     }

                     _btn._opt = btn;

                     btnsList.push(_btn);
                 });

                 resButtons[direction] = [];

                 btnsList.forEach(function (__btn) {
                     var btn = mcService.Marge({}, __btn);

                     if (btn._opt.confirm && btn._opt.showedInList){
                         if (btn._opt.icon){
                             btn.type  = 'icon';
                             btn.icon  = btn._opt.icon;
                             btn.label = btn._opt.label;
                         } else {
                             btn.value = btn._opt.label;
                         }

                         btn.css  = btn._opt.css || undefined;

                         resButtons[direction].push(mcService.Marge({}, btn));
                     }
                 });

                 function attachContext() {
                     if (!self.contextMenu){
                         var contextButtons = [];

                         btnsList.forEach(function (__btn) {
                             var btn = mcService.Marge({}, __btn);

                             if (btn._opt.confirm && btn._opt.addToContext){
                                 if (btn._opt.contextIcon){
                                     btn.type  = 'icon';
                                     btn.icon  = btn._opt.contextIcon;
                                     btn.label = btn._opt.label;
                                 } else {
                                     btn.value = btn._opt.label;
                                 }

                                 if (params.contextOpt.btnHeight){
                                     btn.height = params.contextOpt.btnHeight;
                                 }

                                 btn.css  = btn._opt.contextCss || undefined;
                                 btn._opt = mcService.Marge({
                                     okTitle        : mcLang(28), // "28" :"Сохранить",
                                     cancelTitle    : mcLang(29), // "29" :"Отмена",
                                     delTitle       : mcLang(581) // "581": "Удалить",
                                 }, btn._opt);

                                 contextButtons.push(mcService.Marge({}, btn));
                             }
                         });

                         var ctx = mcService.Marge(params.contextOpt, {
                             view  : "context",
                             master: mcService.isString(params.list) ? $$(params.list) : params.list,
                             body  : { rows: contextButtons },
                             on    : {}
                         });

                         if (params.onShowContext){
                             ctx.on.onShow = params.onShowContext;
                         }

                         if (params.onHideContext){
                             ctx.on.onHide = params.onHideContext;
                         }

                         if (contextButtons && contextButtons.length){
                             self.contextMenu = webix.ui(ctx);
                         }
                     }
                 }

                 if (!resButtons[direction].length) {
                     resButtons.width  = 1;
                     resButtons.height = 1;
                 }

                 return {
                     btnList   : resButtons,
                     emitAction: function(idx, edit){
                         var isString = mcService.isString(idx) && isNaN(parseInt(idx));

                         if (isString){
                             idx = mcService.findItemInArrayOfObj(params.buttons, idx, 'name');
                         }

                         if (params.buttons[idx]){
                             show(params.buttons[idx], params.options, edit);
                         }
                     },
                     hideContext : function () {
                         if (self.contextMenu) {
                             self.contextMenu.hide();
                         }
                     },
                     attachContext: attachContext
                 };
             };
         }

     } else {
         console.error('window.mcWidgets is not defined!');
     }
 })();
"use strict";

function __treeContacts($scope, title){
    var __view = $scope.__view || $$($scope.Name);

    if (!__view){
        var contacts = { id: $scope.Name + "_parent", rows: [
            { cols: [
                { hidden: !title, view: "label", label: title, align: 'center'},

                { view:"toggle", type:"iconButton", id: "pin" + $scope.Name, offIcon: "nezamok", onIcon: "lock", width: 30, css: "btnPaddingToggle4", paddingX: 3, on:{
                    onChange: $scope.pinTool
                }, tooltip: mcLang(511)} //  "511":"Закрепить/открепить",
            ]},

            new mcService.FilterFiled({
                listName     : $scope.Name,
                css          : "noBorderAll",
                noClearBtn   : true,
                placeholder  : mcLang(48), // "48" :"Поиск...",
                filterParams : ['DisplayName']
            }),

            { id: $scope.Name, view: "tree", type: "lineTree", select: true, scroll: isMobile, borderless: true, activeTitle: true,
                data    : $scope.data || [],
                css     : "myScroll noBGColor" + (!isMobile? " scrollMenuYX": ""),
                on      : { onItemClick: $scope.openPrivate },
                template: function(obj, common){
                    var name = "";

                    if (obj.folder) {
                        obj.fName = obj.fName || obj.DisplayName;
                        
                        if (obj.hasOwnProperty("DisplayName")) delete obj.DisplayName;

                        name = mcService.insertIco("fa-users", "smaller") + "<span style='color:#00720d;'>" + obj.fName + "</span>"
                    } else
                    if (obj.TeamLead) {
                        name = "<span class='webix_icon fa-user smaller " + mcConst.storageOpts.STATUSICO + obj.UIN + "' style='color:" + mcService.getColorForStatus(obj.State) + "'></span>" +
                               "<span style='color: rgb(12, 132, 228)'>" + obj.DisplayName + "</span>";
                    } else {
                        name = "<span class='webix_icon fa-user smaller " + mcConst.storageOpts.STATUSICO + obj.UIN + "' style='color:" + mcService.getColorForStatus(obj.State) + "'></span>" +
                               obj.DisplayName
                        ;
                    }

                    return common.icon(obj,common) + "<span style='cursor: pointer;'>" + name + "</span>";
                }
            }
        ]};

        $$($scope.container).addView(contacts);

        __view = $$($scope.Name);
        __view.parentContainer = $$($scope.Name + "_parent");
        $scope.__view = __view;

        mcService.disableContextMenu(__view);
    } else {
        __view.getParentView().show();

        $$("pin" + $scope.Name).setValue(false);
    }

    return __view;
}"use strict";

function initLogin($scope){
    var labelWidth = 140;
    var login = null;

    if ($$($scope.Name)) $$($scope.Name).destructor();

    var srvPwdPopup = webix.ui({
        view  : "popup",
        width : 300,
        height: 150,
        body  : { autoheight: true, css:"wrap", borderless: true,
            template: mcService.insertIco("fa-info-circle") + mcService.Lang(64)} // "64" : "Общий пароль, который проверяется перед авторизацией пользователя.<br><br>Устанавливается на сервере в разделе \"Настройки\" -&gt; \"Сетевые настройки\"",
    });

    var loginPopup = webix.ui({
        view  : "popup",
        width : 300,
        height: 120,
        body  : { autoheight: true, css:"wrap", borderless: true,
            template: mcService.insertIco("fa-info-circle") + mcService.Lang(175)} // "175":"Используйте для входа
    });

    var loginBody = {
        id   : 'loginForm',
        view : 'form',
        rules:{
            "loginField"    : webix.rules.isNotEmpty,
            "passwordField" : function (pass) {
                var login = $scope.loginField.getValue().toString().replace('\\', '/');

                return login.indexOf('/') !== -1 ? !!mcService.trim(pass) : true;
            }
        },
        elements:[ { rows: [
            { cols: [ // login
                { id: 'loginField', name: 'loginField', view: "text", labelWidth : labelWidth, value: $scope.login, required: true,
                    invalidMessage: "<span class='red h10'>" + mcService.Lang(66) + "</span>", // "66" : "Поле не может быть пустым",
                    placeholder: mcService.Lang(1), // "1" : "Логин"
                    on: {
                        onKeyPress : function (code) {
                            if (code === 13) {
                                if ($scope.passwordField.getValue() !== ""){
                                    $scope.loginBtnClick.call($scope.loginForm);
                                } else {
                                    $scope.passwordField.focus();
                                }

                                return false;
                            }
                        }
                    }
                },

                { view: "button", template : mcService.insertIco('fa-question'), width: 34, borderless: true, css: "finger webixBlue loginHelper", click: function(){
                    loginPopup.show(this.getNode());
                }}
            ]},

            { cols: [ // password
                { id: 'passwordField', name: 'passwordField', view: "text", labelWidth: labelWidth, type: 'password', /*required: true,*/ keyPressTimeout: 100,
                    invalidMessage: "<span class='red h10'>" + mcService.Lang(66) + "</span>", // "66" : "Поле не может быть пустым",
                    placeholder: mcService.Lang(2), // "2" : "Пароль"
                    on: {
                        onKeyPress      : $scope.keyLogin,
                        onTimedKeyPress : function() {
                            $scope.checkLangPass($scope.loginDispLang, $scope.passwordField);
                        }
                    }
                },

                { id: 'loginDispLang', template: 'EN', width: 34, css: 'loginHelper', borderless: true}
            ]},

            { height: 38}
        ]}]
    };

    var register = {
        id   : 'registrationForm',
        view : 'form',
        hidden: true,
        rules:{
            "regLoginField"    : webix.rules.registerLogin,
            "regPasswordField" : webix.rules.isNotEmpty,
            "regEmailField"    : webix.rules.isEmail
        },
        elements:[ { rows: [
            { id: 'regLoginField', name: 'regLoginField', view: "text", value: '', required: "true",
                placeholder: mcService.Lang(56), // "56" :"Ваш логин",
                invalidMessage: "<span class='red h10'>" + mcService.Lang(581) + "</span>", // "581":"Поле пустое или содержит недопустимые символы",
                on: {
                    onKeyPress: $scope.checkRegisterChars
                }
            },

            { id: 'regPasswordField', name: 'regPasswordField', view: "text", type: 'password', required: "true",
                placeholder: mcService.Lang(58), // "58" : "Введите ваш пароль",
                invalidMessage: "<span class='red h10'>" + mcService.Lang(66) + "</span>", // "66" : "Поле не может быть пустым",
                on: { onKeyPress : $scope.keyRegister }
            },

            { id: 'regEmailField', name: 'regEmailField', view: "text", type: 'email',
                placeholder: mcService.Lang(59), // "59" : "Введите ваш Email",
                invalidMessage: "<span class='red h10'>" + mcService.Lang(66) + "</span>", // "66" : "Поле не может быть пустым",
                on: { onKeyPress : $scope.keyRegister }
            }
        ]}]
    };

    var serverList = { view: "form",
        rows: []
        .concat(!$scope.isWebClient ? { cols: [
            { id: "loginSelectServer"  + $scope.Name, view: "richselect", options: $scope.serverList, value: $scope.serverList.length ? $scope.serverList[0].id : 0 ,
                placeholder   : mcLang(515), // "515":"Не найден сервер для подключения",
                on: {
                    onFocus    : function () {
                        $scope.loginSelectServer.blur();
                    },
                    onItemClick: $scope.checkEmptyList,
                    onChange   : $scope.changeServerHost
                }
            },

            { id: "toggleServerInfo", view: "button", type: "icon", icon: "gear", width: 34, css: "iconNoPadding", tooltip: mcLang(516), // "516":"Настроить сервер для подключения",
                click: $scope.showServerManager
            }
        ]} : {
            hidden: !$scope.isWebClient, cols: [ // server password
                { id: 'servPassField', view: "text", type: 'password', //labelWidth: labelWidth,
                    placeholder: mcService.Lang(3), // "3" : "Пароль к серверу"
                    on   : {
                        onKeyPress : $scope.keyLogin
                    }
                },

                { view: "button", template: mcService.insertIco('fa-question'), width: 34, borderless: true, css: "finger webixBlue loginHelper", click: function(){
                    srvPwdPopup.show(this.getNode());
                }}
            ]})
        .concat(
            { id: "rememberField", view : "checkbox", labelWidth: 0, value: $scope.remember, css: "finger",
                labelRight: $scope.isWebClient ? mcLang(4) : mcLang(533), // "4":"Запомнить меня на этом компьютере", "533":"Автоматически подключаться",
                on  : { onChange: function(newV){
                    $scope.remember = mcService.convertIntToBool(newV);
                }}
            },

            { view: "button", value: mcService.Lang(13), id: "loginBtn", click: function () { // "5" : "Войти" "13" :"Ок",
                var valid = this.getFormView().validate() || $scope.isWebClient;

                if (valid) {
                    if ($$("_loginType").getValue() == "loginForm"){
                        $scope.loginBtnClick.call($scope.loginForm);
                    } else {
                        $scope.registerBtnClick.call($scope.registrationForm);
                    }
                }
            }}
        )
    };

    if (isMobile){
        loginBody.maxWidth = 550;
        loginBody.minWidth = 300;
        register.maxWidth  = 550;
        register.minWidth  = 300;

        login = webix.ui({
            id       : $scope.Name,
            view     : "scrollview",
            css      : "noBGColor",
            body     : { rows: [
                { view: "tabview", id: "_loginType", borderless: true, cells: [
                    { header: mcLang(5),  body: loginBody}, // "5" : "Войти"
                    { header: mcLang(55), body: register }  // "55" : "Регистрация",
                ]},

                serverList
            ]}
        });
    } else {
        if (!$$("loginLang")){
            webix.ui({
                view    : "richselect",
                id      : "loginLang",
                container: "languageChanger",
                value   : $scope.lang,
                css     : "noBGColorAll",
                options : {
                    template : "#value#",
                    data     : [
                        { id : 'en', value : '<img src="' + mcConst.imagesPath.flags + 'en32.png" align="left">&nbsp; english'},
                        { id : 'uk', value : '<img src="' + mcConst.imagesPath.flags + 'uk32.png" align="left">&nbsp; українська'},
                        { id : 'ru', value : '<img src="' + mcConst.imagesPath.flags + 'ru32.png" align="left">&nbsp; русский'}
                    ]
                },
                on : {
                    onChange: $scope.changeLang
                }
            });
        }

        login = webix.ui({
            id       : $scope.Name,
            view     : "window",
            width    : 370,
            position : "center",
            head     : false,
            body     : { rows: [
                { view: "tabview", id: "_loginType", borderless: true, cells: [
                    { header: mcLang(5),  body: loginBody}, // "5" : "Войти"
                    { header: mcLang(55), body: register }  // "55" : "Регистрация",
                ]},

                serverList
            ]},
            on : {
                onHide: function () {
                    if (!$scope.doLogin) { // todo: mazafaka fix  окно прячется при нажатии на ESC баг вебикса
                        login.show();
                    }
                }
            }
        });
    }

    //webix.debug = true;

    $scope.loginForm     = $$('loginForm');
    $scope.passwordField = $$('passwordField');
    $scope.loginDispLang = $$('loginDispLang');
    $scope.loginField    = $$("loginField");
    $scope.servPassField = $$("servPassField");
    $scope.loginBtn      = $$("loginBtn");

    $scope.registrationForm = $$('registrationForm');
    $scope.regLoginField    = $$("regLoginField");
    $scope.regPasswordField = $$("regPasswordField");
    $scope.regEmailField    = $$("regEmailField");

    $scope.loginSelectServer = $$("loginSelectServer" + $scope.Name);

    setTimeout(function () {
        $scope.loginField.focus();
    }, 10);

    login.show();

    return login;
}
"use strict";

function loginController ($scope, $rootScope, $location){
    $scope.Name = mcConst.dataModels.Login;
    $scope.remember   = false;
    $scope.serverList = [];
    $scope.doLogin    = false;

    var serverManager = $rootScope.isWebClient ? null : $rootScope.UNIT.ctrlServersManager;
    var _view         = null;

    // ======= Error Actions ==========

    function restoreByError() {
        mcService.SaveSessionSettings(mcConst.LoginInfo.login, "", "", false);

        mcConst.LoginInfo.pwd     = "";
        mcConst.LoginInfo.servPwd = "";
        mcConst.LoginInfo.rm      = false;

        $scope.show($scope.lang);
    }

    $rootScope.ErrorActions[14] = function(){ // "14"  : "Неверный пароль пользователя",
        if ($rootScope.isWebClient){
            $rootScope.loginFormNotShowed = false;

            mcService.SaveSessionSettings(mcConst.LoginInfo.login, "", "", false);

            mcConst.LoginInfo.pwd     = "";
            mcConst.LoginInfo.servPwd = "";
            mcConst.LoginInfo.rm      = false;

            if (!_view){
                initLogin($scope);
            }

            webix.ready(function(){
                setTimeout(function(){
                    $scope.passwordField.focus();
                }, 100);
            });
        } else {
            restoreByError();
        }
    };

    $rootScope.ErrorActions[80] = function () {
        if ($rootScope.isWebClient){
            $rootScope.ErrorActions[14]();  // остался мусор в локал сторажде от предыдущего логина
        } else {
            restoreByError();
        }
    };

    $rootScope.ErrorActions[81] = function (params) {
        $rootScope.$broadcast('ErrorMsg', [81, mcConst.ErrorText[81], params, function(){
            $rootScope.ErrorActions[14]();
        }]);
    };

    // ===============================

    function selectCurrentServer() {
        var ID = serverManager.getCurrentServer().ID || serverManager.getServerIdByOrderPosition(0);

        if (ID) {
            $scope.loginSelectServer.setValue(ID);
        }
    }

    function addServerToList(info) {
        var idx = mcService.findItemInArrayOfObj($scope.serverList, info.ID, "id");

        info = serverManager.addServerInfo(info);

        if (info){
            $scope.serverList[idx === -1 ? $scope.serverList.length : idx] = {
                id   : info.ID,
                ord  : mcService.convertBool(!!info.ServerID),
                value: "<span class='" + (info.ServerID ? "green" : "linkColor") + "'>" + (info.ServName ? info.ServName + ", " : "") + info.ServHost + ": " + info.Port + "</span>"
            };

            if (idx === -1){
                $scope.loginSelectServer.getList().add($scope.serverList[$scope.serverList.length - 1]);
            } else {
                $scope.loginSelectServer.define('options', $scope.serverList);
                $scope.loginSelectServer.refresh();
            }

            $scope.loginSelectServer.getList().sort("ord", "dsc", "int");
        }
    }

    function hideLoginForm() {
        $scope.doLogin = true;

        _view = $$($scope.Name);

        if (_view && _view.isVisible && _view.isVisible()){
            _view.hide();
        }

        $rootScope.loginFormNotShowed = true;

        mcService.hideFrame("languageChanger");
    }

    function showLoginForm(args) {
        var lang = args ? args[0] : mcConst.Lang;
        var onlyChangeLang = $scope.lang != undefined && $scope.lang != lang;

        var token = $location.param('token');

        webix.storage.local.put('admLang', $scope.lang);

        if (token){
            $rootScope.SendCMDToServer([
                mcConst.lockInterface,
                mcConst._CMD_.cs_login_by_token,
                token
            ]);

            window.history.pushState(null, document.title, window.location.pathname + window.location.hash.replace("token=" + token, ""));
        } else

        if (_view && _view.show && !onlyChangeLang){
            $scope.doLogin = false;

            _view.show();

            $rootScope.loginFormNotShowed = false;
        } else

        if (!_view || (_view && _view.isVisible && !_view.isVisible()) || (args[0] && $scope.lang != args[0])){
            $scope.doLogin = false;

            $scope.isWebClient = $rootScope.isWebClient;

            var _login  = "";
            var _pwd    = "";
            var _rLogin = "";
            var _rPwd   = "";
            var _rEmail = "";

            if (_view){
                _login  = $scope.loginField      .getValue() || mcConst.LoginInfo.login;
                _pwd    = $scope.passwordField   .getValue();
                _rLogin = $scope.regLoginField   .getValue();
                _rPwd   = $scope.regPasswordField.getValue();
                _rEmail = $scope.regEmailField   .getValue();
            }

            $scope.show.apply(null, args);

            if ($scope.loginField){
                $scope.loginField      .setValue($scope.login || _login);
                $scope.passwordField   .setValue(_pwd   );
                $scope.regLoginField   .setValue(_rLogin);
                $scope.regPasswordField.setValue(_rPwd  );
                $scope.regEmailField   .setValue(_rEmail);
            }
        }
    }

    function acPreLogin(doLogin) {
        var ID = $scope.loginSelectServer.getValue();

        if (ID){
            var server  = serverManager.getServerInfoByID(ID);
            var needPwd = server ? server.ServPass : "";
            var srv_pwd = needPwd && mcService.isString(server.ServPass) ? server.ServPass : "";

            if (needPwd === true && srv_pwd == ""){
                webix.ui({
                    view    : "window",
                    width   : 240,
                    head    : false,
                    position: "center",
                    modal   : true,
                    body: { view  : "form",
                        rules : { "goServPwd" : webix.rules.isNotEmpty },
                        rows  : [
                            { view: "text", type: "password", placeholder: mcLang(3), name: "goServPwd", require: true}, // "3"  :"Пароль к серверу",
                            { cols: [
                                { view: "button", value: mcLang(13), hotkey: "enter", click: function () {// "13" :"Ок",
                                    if (this.getFormView().validate()){
                                        srv_pwd = this.getFormView().getValues()["goServPwd"];

                                        server.ServPass = srv_pwd;

                                        serverManager.addServerInfo(server);

                                        doLogin(srv_pwd);

                                        this.getTopParentView().close();
                                    }
                                }},

                                { view: "button", value: mcLang(33), click: function () {// "33" :"Отмена",
                                    this.getTopParentView().close();
                                }}
                            ]}
                        ]
                    },
                    on: {
                        onShow: function () {
                            this.getChildViews()[0].focus("goServPwd");
                        }
                    }
                }).show();
            } else {
                doLogin(srv_pwd);
            }
        } else {
            webix.alert(mcLang(530)); // "530":"Выберите сервер для подключение!",
        }
    }

    // ===============================

    $scope.checkRegisterChars = function (key, e) {
        return $rootScope.restrictedSymbols.indexOf(e.key) === -1;
    };

    $scope.keyLogin = function(code , e){
        if (code === 13 && !e.ctrlKey && !e.shiftKey && !e.altKey) {
            if ($$("_loginType").getValue() == "loginForm"){
                $scope.loginBtnClick.call($scope.loginForm);
            } else {
                $scope.registerBtnClick.call($scope.registrationForm);
            }

            return false;
        }
    };

    $scope.keyRegister = $scope.keyLogin;

    $scope.checkEmptyList = function () {
        if ($scope.loginSelectServer.getList().count() == 0){
            $scope.showServerManager();
        }
    };

    $scope.checkLangPass = function(displayLang, field){
        var lng      = displayLang;
        var lastChar = field.getValue()[field.getValue().length - 1];

        if (lastChar){
            if (lastChar.match(/[a-zA-Z]/)) {
                lng.define('template', 'EN');
                lng.refresh();
            } else
            if (lastChar.match(/[а-яА-Я]/)){
                lng.define('template', 'RU');
                lng.refresh();
            } else
            if (lastChar.match(/[їЇіІєЄ]/)){
                lng.define('template', 'UA');
                lng.refresh();
            }
        }
    };

    $scope.loginBtnClick = function (){
        function _go(srv_pwd) {
            var login = $scope.loginField   .getValue().toString().replace('\\', '/');
            var pass  = $scope.passwordField.getValue();

            if (login.indexOf('/') !== -1 && !pass){
                webix.message({ type:"error", text: mcService.Lang(7) , expire : mcConst.errMessageExpire}); // "7" : "Ошибка входа: неправильно введены данные"
            } else

            $rootScope.$broadcast('SendCMDToServer' , [
                mcConst.lockInterface,
                mcConst._CMD_.Login,

                login,
                pass,
                srv_pwd,

                mcConst.LoginInfo.rm  
            ]);
        }

        var isValid = this.validate();

        if (isValid) {
            if ($scope.isWebClient){
                mcConst.LoginInfo.servPwd = $scope.servPassField.getValue();

                _go(mcConst.LoginInfo.servPwd);
            } else {
                acPreLogin(function (pwd) {
                    _go(pwd);
                })
            }

            mcConst.LoginInfo.login = $scope.loginField.getValue();
            mcConst.LoginInfo.rm    = $scope.remember;
        } else {
            webix.message({ type:"error", text: mcService.Lang(7) , expire : mcConst.errMessageExpire}); // "7" : "Ошибка входа: неправильно введены данные"
        }
    };

    $scope.registerBtnClick = function(){
        function _go(pwd) {
            $rootScope.$broadcast('SendCMDToServer' , [
                mcConst.lockInterface,
                mcConst._CMD_.Register,

                $scope.regLoginField   .getValue(), //mcConst.LoginInfo.login  ,
                $scope.regPasswordField.getValue(), //mcConst.LoginInfo.pwd    ,
                //$scope.servPassField   .getValue(), //mcConst.LoginInfo.servPwd,
                pwd,

                mcConst.LoginInfo.rm,                //mcConst.LoginInfo.rm
                $scope.regEmailField   .getValue(),
                0
            ]);
        }

        var isValid = this.validate();

        if (isValid) {
            if ($scope.isWebClient){
                _go($scope.servPassField.getValue());
            } else {
                acPreLogin(function (pwd) {
                    _go(pwd);
                })
            }

            mcConst.LoginInfo.login = $scope.regLoginField.getValue();
            mcConst.LoginInfo.rm    = $scope.remember;
        }/*else {
            webix.message({ type:"error", text: mcService.Lang(580) , expire : mcConst.errMessageExpire}); // "580":"Логин не может быть пустым и не должен содержать символы: \"\/\\[]:;|=,+*?<>",
        }*/
    };

    $scope.changeLang = function(lang){
        $rootScope.$broadcast('ChangLanguage', mcService.detectLang(lang));
    };

    $scope.changeServerHost = function (val) {
        serverManager.setCurrentServerByID(val);
    };

    $scope.showServerManager = function () {
        hideLoginForm();

        $rootScope.$broadcast('show' + mcConst.dataModels.ServerManager, [function () {
            showLoginForm();

            mcService.showFrame("languageChanger");

            $scope.loginSelectServer.setValue(null);

            $scope.getMcList();
            //selectCurrentServer();
        }]);
    };

    $scope.show = function(lang, reconn){
        var onlyChangeLang = $scope.lang != undefined && $scope.lang != lang;

        $scope.lang  = lang || mcConst.Lang;
        $scope.login = mcConst.LoginInfo.login || "";

        $scope.remember = mcConst.LoginInfo.rm; 

        webix.storage.local.put(mcConst.storageFields.lang, $scope.lang);

        if (!onlyChangeLang && $scope.remember) {
            $rootScope.loginFormNotShowed = !_view || (_view && _view.isVisible && !_view.isVisible());

            if (reconn){
                // $rootScope.$broadcast('ErrorMsg', [-1, mcLang(18) + "<br><br>" + mcConst.loadGif, '', function(){ // "18" :"Обработка запроса",
                $rootScope.$broadcast('ErrorMsg', ['223', mcConst.ErrorText['223'] + "<br>" + mcLang(539) + "<br><br>" + mcConst.loadGif, '', function(){ // "539":"Восстанавливаем связь!",
                    $rootScope.$broadcast('show' + mcConst.dataModels.Login, []);
                }]);
            }

            setTimeout(function () {
                $rootScope.$broadcast('SendCMDToServer' , [
                    mcConst.lockInterface,
                    mcConst._CMD_.Login,
                    mcConst.LoginInfo.login  ,
                    mcConst.LoginInfo.pwd    ,
                    mcConst.LoginInfo.servPwd,
                    mcConst.LoginInfo.rm
                ]);
            }, reconn ? 500 : 10);
        } else {
            webix.ready(function () {
                _view = initLogin($scope);

                $scope.getMcList(); // reloadServersList

                $rootScope.loginFormNotShowed = false;
            });
        }
    };

    $scope.getMcList = function () { // reloadServersList
        if (!$scope.isWebClient){
            $scope.serverList = [];

            var saveCurrentServer = serverManager.getCurrentServer().ID;

            $scope.loginSelectServer.getList().clearAll();
            $scope.loginSelectServer.setValue();

            serverManager.mapServers(addServerToList);

            if (saveCurrentServer){
                $scope.loginSelectServer.setValue(saveCurrentServer);
            } else {
                var val= serverManager.getServerIdByServID(mcConst.ClientSettings.ServID);

                if (val){
                    $scope.loginSelectServer.setValue(val);
                } else {
                    $rootScope.$broadcast('sendCMDToElectron', [
                        mcConst._CMD_.ce_get_server_list
                    ]);
                }
            }
        }
    };

    // =============================================

    $scope.$on('addServerHostToList', function (e, args) {
        if (_view && $scope.loginSelectServer){
            for (var srv in args[0]){
                addServerToList.call(null, args[0][srv]);
            }

            selectCurrentServer();
        }
    });

    $scope.$on('enable' + $scope.Name, function enableForm (){
        if (_view) _view.enable();
    });

    // ====================================

    $scope.$on('hide' + $scope.Name, function () {
        hideLoginForm();
    });

    $scope.$on('show' + $scope.Name, function(e, args){
        showLoginForm(args);
    });

    $rootScope.$broadcast('windowResize', [function(){
        if (isMobile && _view){
            _view.resize();
        }
    }]);
}
"use strict";

function initServerManager($scope){
    var _view = null;
    var labelWidth = 160;

    if ($$($scope.Name)) $$($scope.Name).destructor();

    _view = webix.ui({
        id       : $scope.Name,
        view     : "window",
        width    : 370,
        position : "center",
        //modal    : true,
        head     : {
            view:"toolbar", margin: -4, cols:[
                { id: "managerTitle" + $scope.Name,  view: "label", label: $scope.mainTitle}, // "520":"Менеджер серверов",
                { view:"icon", icon:"times-circle", click: $scope.hideServerManager, tooltip: mcLang(528)} // "528":"Закрыть менеджер серверов",
            ]
        },
        body     : { id: "formServerManager" + $scope.Name, view: "form", padding: 4, rules:{
            "servHost" : mcService.isValidHostName,
            "servPort" : webix.rules.isNumber
        }, rows: [{ rows: [
            { id: "loginSelectServer" + $scope.Name, view: "richselect", options: $scope.serverList, placeholder: mcLang(531), // "531":"Нет серверов",
                value: $scope.serverList.length ? $scope.serverList[0].id : 0,
                on: {
                    onChange: $scope.changeServerHost,
                    onFocus : function () {
                        $scope.loginSelectServer.blur();
                    }
                }
            },

            { id: "mainServerInfo", padding: 4, hidden: true, rows: [
                { cols: [
                    { id: 'servHost', name: "servHost", view: "text", label: mcService.Lang(512), labelWidth: labelWidth,
                        invalidMessage: "<span class='red h10'>" + mcService.Lang(532) + "</span>", // "532":"Некорректный адрес сервера",
                        labelAlign: "right", required: true},// "512":"Адрес сервера",

                    { id: "checkConnect" + $scope.Name, view: "button", type: "icon", icon: "bolt", css: "iconNoPadding green byCenter",
                        width: 36, click: $scope.checkServerConnect, tooltip: mcLang(523)} // "523":"Тест",
                ]},

                { id: 'servPort', name: "servPort", view: "text", label: mcService.Lang(513), labelWidth: labelWidth, value: 2004,
                    invalidMessage: "<span class='red h10'>" + mcService.Lang(524) + "</span>", // "524":"Порт должен быть числом от 1 до 65535",
                    labelAlign: "right", required: true} // "513":"Порт сервера",
            ]},

            { id: "additionalServerInfo", padding: 4, hidden: true, rows: [
                { id: 'servName', view: "text", labelWidth: labelWidth, labelAlign: "right",
                    label: mcService.Lang(514)}, // "514":"Название сервера",

                { id: 'servPass', view: "text", type: 'password', labelWidth: labelWidth, labelAlign: "right",
                    label: mcService.Lang(3) }, // "3" : "Пароль к серверу"

                { id: "servSSL",  view : "checkbox", labelWidth: 0, value: $scope.remember, css: "finger",
                    labelRight: mcService.Lang(522)} // "522":"Использовать шифрование",
            ]},

            { id: "addAndDel", height: 40, cols: [
                { view: "button", type: "icon", icon: "plus-square", css: "iconNoPadding",
                    label: mcLang(518), click: function() { // "518":"Добавить",
                        $scope.editServer(526, true); // "526":"Добавление сервера",
                    }},

                { id: "addBtn" + $scope.Name, view: "button", type: "icon", icon: "pencil-square", css: "iconNoPadding", disabled: true,
                    label: mcLang(521), click: function() { // "521":"Изменить",
                        $scope.editServer(527); // "527":"Редактирование сервера",
                    }},

                { id: "delBtn" + $scope.Name, view: "button", type: "icon", icon: "minus-square", css: "iconNoPadding", disabled: true,
                    label: mcLang(519), click: $scope.delServer} // "519":"Удалить",
            ]},

            { height: 1},

            { id: "logResult", view: "label", hidden: true, css: "red"},

            { id: "okAndCancel", hidden: true, height: 40, cols: [
                { id: "saveServer" + $scope.Name, view: "button", type: "icon", icon: "check-circle", css: "iconNoPadding green byCenter",
                    label: mcLang(77), click: $scope.saveServerEdit}, // "77" :"Сохранить",

                { view: "button", type: "icon", icon: "times-circle", css: "iconNoPadding red byCenter",
                    label: mcLang(33), click: $scope.cancelServerEdit} // "33" :"Отмена",
            ]},

            { height: 3 }
        ]}]},
        on : {
            onHide: function () {
                if (!$scope.needHide) { // todo: mazafaka fix  окно прячется при нажатии на ESC баг вебикса
                    _view.show();
                }
            }
        }
    });

    // =============================

    $scope.servHost = $$("servHost");
    $scope.servPort = $$("servPort");
    $scope.servName = $$("servName");
    $scope.servPass = $$("servPass");
    $scope.servSSL  = $$("servSSL");

    $scope.addBtn = $$("addBtn" + $scope.Name);
    $scope.delBtn = $$("delBtn" + $scope.Name);

    $scope.checkConnect = $$("checkConnect" + $scope.Name);
    $scope.saveServer   = $$("saveServer" + $scope.Name);

    $scope.logResult = $$("logResult");

    $scope.addAndDel   = $$("addAndDel");
    $scope.okAndCancel = $$("okAndCancel");

    $scope.loginSelectServer = $$("loginSelectServer"  + $scope.Name);
    $scope.formServerManager = $$("formServerManager" + $scope.Name);

    $scope.additionalServerInfo = $$("additionalServerInfo");
    $scope.mainServerInfo       = $$("mainServerInfo");

    $scope.managerTitle = $$("managerTitle" + $scope.Name);

    _view.show();

    return _view;
}
"use strict";

function serverManagerController ($scope, $rootScope){
    $scope.Name = mcConst.dataModels.ServerManager;
    $scope.serverList  = [];
    $scope.runCallBack = null;

    var serverManager = $rootScope.UNIT.ctrlServersManager;
    var _view        = null;
    var isNewServer  = false;

    var KP_EDIT_SERVER_INFO = 'edit_server_info';

    // == Electron Errors Handlers ===

    $rootScope.ElectronErrors[mcConst._CMD_.errElectron.eDuplicateServer] = function (error) {
        webix.alert(error.msg); // "1" : "Сервер с таким IP: \"%s\" и Port: \"%s\" уже существует!"

        // очищаем калбек на неудачное изменение или добавление сервера, сцуконах...
        $rootScope.customCallBack[isNewServer ? mcConst._CMD_.ce_add_server : mcConst._CMD_.ce_modify_server].shift();
    };

    $rootScope.ElectronErrors[mcConst._CMD_.errElectron.eUnknownServerID] = function (error) {
        webix.alert(error.msg); // "2" : "Неизвестный ServerID: %s, сервер не сохранен!"

        // очищаем калбек на неудачное изменение или добавление сервера, сцуконах...
        $rootScope.customCallBack[mcConst._CMD_.ce_modify_server].shift();
    };

    // ===============================

    function clearServerInfo() {
        $scope.servHost.setValue("");
        $scope.servPort.setValue(2004);
        $scope.servName.setValue("");
        $scope.servPass.setValue("");
        $scope.servSSL .setValue(false);
    }

    function fillServerInfo(id) {
        var info = serverManager.getServerInfoByID(id);

        if (info && !isNewServer) {
            $scope.servHost.setValue(info.ServHost);
            $scope.servPort.setValue(info.Port);
            $scope.servName.setValue(info.ServName || "");
            $scope.servPass.setValue(mcService.isString(info.ServPass) ? info.ServPass : "");
            $scope.servSSL .setValue(mcService.convertIntToBool(info.Secured));
        }
    }

    function hideOkAndCancel() {
        if ($scope.okAndCancel.isVisible()){
            $scope.okAndCancel.hide();
            $scope.addAndDel.show();
            $scope.mainServerInfo.hide();

            hideAdditionalInfo();

            $scope.loginSelectServer.show();
            $scope.logResult.hide();

            $scope.managerTitle.define("label", $scope.mainTitle);
            $scope.managerTitle.refresh();

            $rootScope.hotKeyDispatcher.removePreset(KP_EDIT_SERVER_INFO);
        }
    }

    function showOkAndCancel() {
        if ($scope.addAndDel.isVisible()){
            $scope.addAndDel.hide();
            $scope.okAndCancel.show();
            $scope.mainServerInfo.show();

            var bak =   $scope.loginSelectServer.getValue(); // webix при спрятывании списка фокусит предыдущий элемент списка, факиншыт
                        $scope.loginSelectServer.hide();
                        $scope.loginSelectServer.setValue(bak);

            $scope.logResult.hide();

            if ($scope.loginSelectServer.getList().isVisible()){
                $scope.loginSelectServer.getList().hide();
            }

            $rootScope.hotKeyDispatcher.addPreset(KP_EDIT_SERVER_INFO, [{
                key : mcConst.keyCodes.esc,
                func: $scope.cancelServerEdit
            }, {
                key : mcConst.keyCodes.enter,
                func: $scope.saveServerEdit
            }], document, true);
        } else {
            return true;
        }
    }

    function showAdditionalInfo() {
        if (!$scope.additionalServerInfo.isVisible()){
            $scope.additionalServerInfo.show();
        }
    }

    function hideAdditionalInfo() {
        if ($scope.additionalServerInfo.isVisible()){
            $scope.additionalServerInfo.hide();
        }
    }

    function addServerToList(info) {
        var idx = mcService.findItemInArrayOfObj($scope.serverList, info.ID, "id");

        info = serverManager.addServerInfo(info);

        if (info){
            $scope.serverList[idx === -1 ? $scope.serverList.length : idx] = {
                id   : info.ID,
                ord  : mcService.convertBool(!!info.ServerID),
                value: "<span class='" + (info.ServerID ? "green" : "linkColor") + "'>" + (info.ServName ? info.ServName + ", " : "") + info.ServHost + ": " + info.Port + "</span>"
            };

            if (idx === -1){
                $scope.loginSelectServer.getList().add($scope.serverList[$scope.serverList.length - 1]);
            } else {
                $scope.loginSelectServer.define('options', $scope.serverList);
                $scope.loginSelectServer.refresh();
            }

            $scope.loginSelectServer.getList().sort("ord", "dsc", "int");

            $scope.addBtn.enable();
            $scope.delBtn.enable();
        }
    }

    function getHost() {
        return mcService.trim($scope.servHost.getValue()).toLocaleLowerCase();
    }

    function getName() {
        return mcService.trim($scope.servName.getValue());
    }

    function getPwd() {
        return mcService.trim($scope.servPass.getValue());
    }

    function getPort(){
        var port = parseInt(mcService.trim($scope.servPort.getValue()));

        if (isNaN(port)){
            port = 2004;
        }

        if (port <=0 || port > 65535){
            port = 2004;
        }

        return port;
    }

    function getSSL() {
        return $scope.servSSL.getValue();
    }

    // ===============================

    $scope.changeServerHost = function (id) {
        serverManager.setCurrentServerByID(id);
    };

    $scope.editServer = function (langCode, clear) {
        showOkAndCancel();
        showAdditionalInfo();

        isNewServer = clear;

        clearServerInfo();

        fillServerInfo($scope.loginSelectServer.getValue());

        $scope.managerTitle.define("label", "<div style='text-align: center'>" + mcLang(langCode).toUpperCase() + "</div>"); // "526":"Добавление сервера", // "527":"Редактирование сервера",
        $scope.managerTitle.refresh();

        $scope.servHost.focus();
    };

    $scope.cancelServerEdit = function () {
        hideOkAndCancel();
    };

    $scope.saveServerEdit = function () {
        var newInfo  = mcService.Marge({}, isNewServer ? {} : serverManager.getServerInfoByID($scope.loginSelectServer.getValue()), {
            ServPass : getPwd(),
            ServName : getName(),
            Port     : getPort(),
            ServHost : getHost(),
            Secured  : getSSL()
        });

        if ($scope.formServerManager.validate()){
            $rootScope.$broadcast('sendCMDToElectron', [
                !newInfo.ServerID || isNewServer
                    ? mcConst._CMD_.ce_add_server
                    : mcConst._CMD_.ce_modify_server,

                newInfo.ServHost,
                newInfo.Port,
                newInfo.ServName,
                "",
                newInfo.ServPass,
                "",
                "",
                newInfo.Secured,
                newInfo.ServerID,

                function (data) { // если есть data, то был добавлен сервер, иначе - обновлен
                    if (data && data.ServerID){
                        newInfo.ServerID = data.ServerID;
                        newInfo.ID       = data.ID;
                        newInfo.id       = data.ID;
                    }

                    addServerToList(newInfo);

                    $scope.loginSelectServer.setValue(newInfo.ID);

                    $scope.cancelServerEdit();
                }
            ]);
        }
    };

    $scope.checkServerConnect = function () {
        var host = getHost();
        var port = getPort();

        if ($scope.formServerManager.validate()){
            $rootScope.$broadcast('sendCMDToElectron', [
                mcConst.lockInterface,
                mcConst._CMD_.ce_test_server_ip,
                host,
                port,
                function (_data) {
                    var err  = mcService.isObject(_data[0]) ? _data[0].message || _data[0].code : "";

                    $scope.logResult.show();
                    $scope.logResult.define('label', "<div style='text-align: center; color: " + (err ? "red" : "green") + ";'>" + (err ? "Error: " + err : mcLang(529)) + "</div>"); // "529":"Тест прошел успешно!
                    $scope.logResult.refresh();
                }
            ]);
        }
    };

    $scope.delServer = function () {
        var ID   = $scope.loginSelectServer.getValue();
        var text = $scope.loginSelectServer.getText();

        webix.confirm({
            type  : "confirm-warning",
            text  : mcLang(525, text), // "525":"Удалить сервер<br><b>%s</b>?",
            ok    : mcService.Lang(519), // "519":"Удалить",
            cancel: mcService.Lang(33),  // "33" :"Отмена",
            callback:function(yes){
                if (yes){
                    var list     = $scope.loginSelectServer.getList();
                    var serverID = serverManager.getServerInfoByID(ID).ServerID;

                    list.remove(ID);

                    if (list.count() == 0){
                        $scope.addBtn.disable();
                        $scope.delBtn.disable();
                    }

                    if (serverID){ // если удаляется сервер, который есть базе - отправляем команду
                        $rootScope.$broadcast('sendCMDToElectron', [
                            mcConst._CMD_.ce_del_server,
                            serverID
                        ]);
                    }

                    serverManager.removeServerByID(ID);

                    if (list.count() != 0){
                        $scope.loginSelectServer.setValue(serverManager.getServerIdByOrderPosition(0));
                    } else {
                        $scope.loginSelectServer.setValue(null);
                    }
                }
            }
        });
    };

    $scope.show = function(){
        _view = initServerManager($scope);
    };

    $scope.getMcList = function () {
        $scope.serverList = [];

        var saveCurrentServer = serverManager.getCurrentServer().ID;

        $scope.loginSelectServer.getList().clearAll();
        $scope.loginSelectServer.setValue();

        serverManager.mapServers(addServerToList);

        if (saveCurrentServer){
            $scope.loginSelectServer.setValue(saveCurrentServer);
        }

        $rootScope.$broadcast('sendCMDToElectron', [
            mcConst._CMD_.ce_get_server_list
        ]);
    };

    $scope.hideServerManager = function () {
        $scope.needHide = true;

        $$($scope.Name).hide();

        $rootScope.hotKeyDispatcher.removePreset(KP_EDIT_SERVER_INFO);

        if ($scope.runCallBack) {
            $scope.runCallBack();
        }
    };

    // =============================================

    var _msg = window._messages_.serversManager = {
        addServerHostToList         : 'addServerHostToList',
        addServerOnSuccessConnect   : 'addServerOnSuccessConnect'
    };

    $scope.$on(_msg.addServerHostToList, function (e, args) {
        if ($scope.loginSelectServer){
            for (var srv in args[0]){
                addServerToList.call(null, args[0][srv]);
            }

            if (mcConst.ServerInfo.ID) {
                $scope.loginSelectServer.setValue(mcConst.ServerInfo.ID);
            }

            $scope.changeServerHost(serverManager.getCurrentServer().ID || serverManager.getServerIdByOrderPosition(0));
        }
    });

    $scope.$on(_msg.addServerOnSuccessConnect, function (e, id) {
        var sInfo = serverManager.getServerInfoByID(id);

        if (sInfo && !sInfo.ServerID){
            $rootScope.$broadcast(window._messages_.clientData.sendCMDToElectron, [
                mcConst._CMD_.ce_add_server,

                sInfo.ServHost,
                sInfo.Port,
                sInfo.ServName,
                "",
                sInfo.ServPass,
                "",
                "",

                function (info) {
                    serverManager.addServerInfo(info);

                    $rootScope.$broadcast(window._messages_.clientData.saveCurrentServerID, [info.ServerID]);
                }
            ]);
        }
    });

    // ====================================

    $scope.$on('hide' + $scope.Name, function(){
        $scope.needHide = true;

        $$($scope.Name).destructor();
    });

    $scope.$on('show' + $scope.Name, function(e, args){
        $scope.needHide = false;

        $scope.mainTitle = "<div style='font-size: 11pt; text-align: center'>" + mcLang(520).toUpperCase() + "</div>";

        $scope.show();

        $scope.getMcList();

        $scope.runCallBack = args[0] || null;
    });
}"use strict";

function initCommonContacts($scope){
    return __treeContacts($scope, mcLang(10)); // "10" :"Общие контакты",
}"use strict";

function commonContactsController($scope, $rootScope){
    $scope.Name = mcConst.dataModels.CommonContacts;

    var _view = null;
    var state = null;
    var userStatuses = null;

    function fillContacts(data){
        _view.clearAll();
        _view.parse(mcService.convertDataToTree(data));

        $scope.data = _view.data;

        if (userStatuses){
            mcService.updateStatuses(userStatuses, $scope.data);
        }

        if (state) {
            _view.setState(state);
        } else {
            state = _view.getState();
        }
    }

    // ==================================

    $scope.openPrivate = function(id){
        var uin = $$(this).getItem(id).UIN;

        if (uin){
            $rootScope.$broadcast('OpenPrivate', [uin]);
        }
    };

    $scope.pinTool = function(on){
        $rootScope.$broadcast( on ? 'pinTool' : 'unPinTool', [$scope.Name]);
    };

    $scope.getData = function(){
        $rootScope.$broadcast('SendCMDToServer' , [
            mcConst._CMD_.cs_get_common_contacts_list,
            mcConst.SessionID,
            fillContacts
        ]);
    };

    $scope.show = function(){
        $rootScope.setTool($scope.Name);

        _view = initCommonContacts($scope);
    };

    // ==================================

    $scope.$on('allUsersOnlineStatusesChanged', function(e, args){
        userStatuses = args[0];

        mcService.updateStatuses(userStatuses, $scope.data);

        if (_view){
            _view.refresh();
        }
    });

    $scope.$on('newCommonContactList', function(e, args){
        if (_view){
            state = _view.getState();

            fillContacts.apply(null, args);
        }
    });

    $scope.$on('hide' + $scope.Name, function(){
        state = _view.getState();
        
        _view.getParentView().hide();
    });

    $scope.$on('show' + $scope.Name, function(e, args){
        $scope.container = args[0];

        $scope.show();
        $scope.getData();
    });
}
"use strict";

function initPersonalContacts($scope){
    var view = __treeContacts($scope, mcLang(17)); // "17" :"Личные контакты",

    var addNewGroup = $$("addNewGroup" + $scope.Name);

    if (!addNewGroup){
        view.parentContainer.addView({
            view : "button",
            id   : "addNewGroup" + $scope.Name,
            value: mcLang(561), // "561":"Добавить группу",
            click: function () {
                $scope.contextPersonalContacts.emitAction('createGroup');
            }
        });
    }

    if (!$scope.contextPersonalContacts){
        $scope.contextPersonalContacts = $scope._contextMenuList.editButtons({
            buttons : []
                .concat([{
                    name           : 'createGroup',
                    type           : 'add', // add, edit, del
                    confirm        : $scope.contextMenu.addGroup,
                    addToContext   : true,
                    showedInList   : false,
                    contextCss     : 'byCenter whiteAll noUpperCase',
                    label          : mcLang(561), // "561":"Добавить группу",
                    title          : mcLang(561), // "561":"Добавить группу",
                    editTitle      : mcLang(35),  // "35" :"Название",
                    okTitle        : mcLang(77),  // "77" :"Сохранить",
                    cancelTitle    : mcLang(33)   // "33" :"Отмена",
                }])
                .concat([{
                    name           : 'addContact',
                    type           : 'add', // add, edit, del
                    confirm        : $scope.contextMenu.addUser,
                    addToContext   : true,
                    showedInList   : false,
                    contextCss     : 'byCenter whiteAll noUpperCase',
                    label          : mcLang(562), // "562":"Добавить контакт",
                    title          : mcLang(562), // "562":"Добавить контакт",
                    editTitle      : mcLang(564), // "564":"Укажите UIN",
                    okTitle        : mcLang(77),  // "77" :"Сохранить",
                    cancelTitle    : mcLang(33)   // "33" :"Отмена",
                }])
                .concat([{
                    name           : 'editGroup',
                    type           : 'edit', // add, edit, del
                    confirm        : $scope.contextMenu.renameGroup,
                    addToContext   : true,
                    showedInList   : false,
                    contextCss     : 'byCenter whiteAll noUpperCase',
                    label          : mcLang(563), // "563":"Переименовать",
                    title          : mcLang(563), // "563":"Переименовать",
                    editTitle      : mcLang(35),  // "35" :"Название",
                    okTitle        : mcLang(77),  // "77" :"Сохранить",
                    cancelTitle    : mcLang(33)   // "33" :"Отмена",
                }])
                .concat([{
                    name           : 'delItem',
                    type           : 'del', // add, edit, del
                    confirm        : $scope.contextMenu.del,
                    addToContext   : true,
                    showedInList   : false,
                    contextCss     : 'byCenter whiteAll noUpperCase',
                    delName        : "DisplayName",
                    label          : mcLang(519), // "519":"Удалить",
                    cancelTitle    : mcLang(33),   // "33" :"Отмена",
                    title          : mcLang(565)   // "565":"Удалить <br>%s?",
                }]),

            fillItems     : ["DisplayName"],
            list          : $scope.Name,
            onShowContext : $scope.onShowPopMenu,
            onHideContext : $scope.removeHotKeys,
            contextOpt    : {
                width: 170,
                padding: 0,
                btnHeight: 30
            }
        });

        $scope.contextPersonalContacts.attachContext();
    }

    return view;
}"use strict";

function personalContactsController($scope, $rootScope){
    $scope.Name = mcConst.dataModels.PersonalContacts;

    var _view = null;
    var state = null;
    var userStatuses = null;

    $scope._contextMenuList = window.mcWidgets.ButtonsListWithContext ? new window.mcWidgets.ButtonsListWithContext($rootScope) : null;
    // =======================================================

    function fillContactList(data){
        _view.clearAll();
        _view.parse(mcService.convertDataToTree(data));

        $scope.data = _view.data;

        if (userStatuses){
            mcService.updateStatuses(userStatuses, $scope.data);
        }

        if (state) {
            _view.setState(state);
        } else {
            state = _view.getState();
        }
    }

    // =======================================================

    $scope.registerHotKeys = function () {
        $rootScope.hotKeyDispatcher.addPreset($scope.Name, [{
            lockPrev: true,
            key   : mcConst.keyCodes.esc,
            func  : function hidePopupPersonalContacts() {
                $scope.contextPersonalContacts.hideContext();
            }
        }], document, true);
    };

    $scope.removeHotKeys = function () {
        setTimeout(function () {
            $rootScope.hotKeyDispatcher.removePreset($scope.Name);
        }, 10);
    };
    
    $scope.onShowPopMenu = function () {
        var context = this.getContext();

        context.obj.select(context.id);

        var uu = context.obj.getItemNode(context.id);

        $scope.registerHotKeys();

        this.getChildViews()[0].getChildViews()[2][context.obj.getItem(context.id).IsGroup ? "enable" : "disable"]();

        this.blockEvent();

        this.show(uu, {y: 12}, "bottom");

        this.unblockEvent();
    };

    $scope.contextMenu = {
        addGroup: function (edit) {
            var form  = this;
            var value = mcService.trim(edit.getValue());

            if (form.validate() && value){
                state = _view.getState();

                $rootScope.SendCMDToServer([
                    mcConst._CMD_.cs_add_personal_contact_group,
                    mcConst.SessionID,
                    
                    value
                ]);
            } else {
                return true;
            }
        },
        addUser : function (edit, btns, item) {
            var form = this;
            var uin  = parseInt(edit.getValue());

            if (form.validate() && !isNaN(uin)){
                state = _view.getState();

                $rootScope.SendCMDToServer([
                    mcConst._CMD_.cs_add_new_contact,
                    mcConst.SessionID,

                    uin,
                    item.ParentID
                ]);
            } else {
                webix.message(mcLang(566)); // "566":"Укажите числовой UIN пользователя",

                setTimeout(function(){
                    edit.focus();
                }, 20);

                return true;
            }
        },
        del     : function (item) {
            state = _view.getState();

            $rootScope.SendCMDToServer([
                mcConst._CMD_.cs_delete_id_from_personal_contacts,
                mcConst.SessionID,

                item.id
            ]);
        },
        renameGroup: function (edit, btns, item) {
            var form  = this;
            var value = mcService.trim(edit.getValue());

            if (form.validate() && value){
                state = _view.getState();

                $rootScope.SendCMDToServer([
                    mcConst._CMD_.cs_rename_contacts_group,
                    mcConst.SessionID,

                    item.GroupID,
                    value
                ]);
            } else {
                return true;
            }
        }
    };

    $scope.openPrivate = function(id){
        var uin = $$(this).getItem(id).UIN;

        if (uin){
            $rootScope.$broadcast('OpenPrivate', [uin]);
        }
    };

    $scope.pinTool = function(on){
        $rootScope.$broadcast( on ? 'pinTool' : 'unPinTool', [$scope.Name]);
    };

    $scope.getData = function(){
        $rootScope.$broadcast('SendCMDToServer' , [
            mcConst._CMD_.cs_get_contacts_list,
            mcConst.SessionID,

            fillContactList
        ]);
    };

    $scope.show = function(){
        $rootScope.setTool($scope.Name);

        _view = initPersonalContacts($scope);
    };

    // =============================================

    var _msg = _messages_.personalContacts = {
        allUsersOnlineStatusesChanged   : 'allUsersOnlineStatusesChanged',
        fillPersonalContactList         : 'fillPersonalContactList'
    };

    $rootScope.$on(_msg.allUsersOnlineStatusesChanged, function(e, args){
        userStatuses = args[0];

        mcService.updateStatuses(userStatuses, $scope.data);

        if (_view){
            _view.refresh();
        }
    });

    $rootScope.$on(_msg.fillPersonalContactList, function(e, args){
        fillContactList.apply(null, args);
    });

    $scope.$on('hide' + $scope.Name, function(){
        state = _view.getState();

        _view.getParentView().hide();
    });

    $scope.$on('show' + $scope.Name, function(e, args){
        $scope.container = args[0];

        $scope.show();
        $scope.getData();
    });
}
"use strict";

function initConfUserList($scope){
    var __view = $$($scope.Name);

    if (!__view){
        var contacts = { id: $scope.Name, rows: [
            { cols: [
                { view: "label", label: mcLang(26), align: 'center'}, // "26" :"Люди в конференции",
                { view:"button", type:"icon", icon: "sign-out", width: 30, css: "btnPaddingToggle4", paddingX: 1,
                    click: $scope.leaveConf,
                    tooltip: mcLang(28)} // "28" :"Выйти из конференции",
            ]},

            new mcService.FilterFiled({
                listName     : "userList" + $scope.Name,
                css          : "noBorderAll",
                noClearBtn   : true,
                placeholder  : mcLang(48), // "48" :"Поиск...",
                filterParams : ['DisplayName']
            }),

            {
                view    : "list",
                id      : "userList" + $scope.Name,
                data    : $scope.data,
                css     : "myScroll noBGColor lineHeight20" + (isMobile ? "" : " scrollMenu"),
                select  : true,
                scroll  : isMobile,
                borderless: true,
                template: function(obj){
                    return mcService.myReplaceFormated(
                        "<span class='webix_icon fa-user smaller #{status}' style='#{statusColor}'></span>#{name}",
                        {
                            status     : mcConst.storageOpts.STATUSICO + obj.UIN,
                            statusColor: "color:" + mcService.getColorForStatus(obj.State),
                            name       : obj.DisplayName
                        }
                    )
                },
                type    : {
                    height: 24
                },
                on : {
                    onItemClick: $scope.openPrivate
                }
            }
        ]};

        $$($scope.container).addView(contacts);

        __view = $$($scope.Name);

        $scope.confUserList = $$("userList" + $scope.Name);

        mcService.disableContextMenu(__view);
    } else {
        __view.show();

        $scope.confUserList.clearAll();
        $scope.confUserList.parse($scope.data);
    }

    $scope.confUserList.sort('DisplayName', 'asc');

    return __view;
}"use strict";

function confUserListController($scope, $rootScope){
    $scope.Name = mcConst.dataModels.ConfUserList;

    var _view = null;

    $scope.data = [];

    function removeUsers(uins) {
        uins = mcService.isArray(uins) ? uins : uins.toString().split(',');

        uins.forEach(function (uin) {
            if ($scope.confUserList.getItem(uin)) {
                $scope.confUserList.remove(uin);
            }

            mcService.delArrayItem($scope.data, mcService.findItemInArrayOfObj($scope.data, uin, "UIN"));
        });
    }

    function clearUser() {
        if ($scope.confUserList){
            $scope.confUserList.clearAll();
        }
    }

    // =============================================================

    $scope.openPrivate = function(id){
        var uin = $$(this).getItem(id).UIN;

        if (uin != mcConst.UserInfo.UIN){
            $rootScope.$broadcast('OpenPrivate', [uin]);
        }

        return false;
    };

    $scope.leaveConf = function () {
        $rootScope.$broadcast('leaveConf', [$rootScope.GetChatID()]);
    };

    $scope.getData = function(){
        $rootScope.$broadcast('getConfUsersList', [
            $rootScope.GetChatID(),
            function(data){
                $scope.data = data;
                
                // console.log(data);

                $scope.show();
            }
        ]);
    };

    $scope.show = function(){
        if ($rootScope.GetChatType() === 'UID'){
            $rootScope.setTool($scope.Name);

            _view = initConfUserList($scope);
        }
    };

    // =====================================================

    var _msg = window._messages_.confUsers = {
        removeUserFromConf  : 'removeUserFromConf',
        addUserToConf       : 'addUserToConf',
        clearUserForUID     : 'clearUserForUID',
        allUsersOnlineStatusesChanged: 'allUsersOnlineStatusesChanged'
    };

    $scope.$on(_msg.clearUserForUID, function () {
        clearUser();
    });

    $rootScope.$on(_msg.allUsersOnlineStatusesChanged, function(e, args){
        var forRemove = [];
        var newState  = args[0];

        $scope.data.forEach(function (user) {
            if (user.UIN != mcConst.UserInfo.UIN && (user.State == mcConst.states.offline || user.State === undefined)){
                forRemove.push(user.UIN);
            }
        });

        removeUsers(forRemove);

        mcService.updateStatuses(newState, $scope.data);
    });

    $scope.$on(_msg.addUserToConf, function(e, args){
        if (_view){
            var users = args[0];

            $scope.confUserList.parse(users);
            $scope.confUserList.sort('DisplayName', 'asc');
        }
    });

    $scope.$on(_msg.removeUserFromConf, function(e, args){
        removeUsers.apply(null, args);
    });

    $scope.$on('hide' + $scope.Name, function(){
        if (_view){
            _view.hide();
        }
    });

    $scope.$on('show' + $scope.Name, function(e, args){
        $scope.container = args[0];

        $scope.getData();
    });
}
"use strict";

function initPrivateInfo($scope){
    var __view = $$($scope.Name);
    var uAct = "userActions";

    if (!__view){
        $$($scope.container).addView({ id: $scope.Name, rows: [
            { id: uAct + "SwitchTool", view: "segmented", css:"yellowSelect noBorderAll noCurve", value: 2, options: [
                { id: "1", value: mcLang(538)}, // "538":"Действия",
                { id: "2", value: mcLang(537)}  // "537":"Информация",
            ], on: { onChange: $scope.changeView }},

            { id: "userInfo" + $scope.Name, rows: [
                { id: 'uFoto', template: ' ', height: 175, css: "byCenter noBGColor framePaddingW10 fotoLineHeight", borderless: true},
                { height: 5 },

                { cols: [
                    { width: 4, css: "noBGColor"},

                    { view: "button", type: "icon", id: "startShareCall", click: function() {$scope.startShareCall()}, icon: "desktop", css: "icoButton byCenter button_primary icnBtnPd03", width: 35},
                    { view: "button", type: "icon", id: "startVoiceCall", click: function() {$scope.startVoiceCall()}, icon: "phone", label: mcService.Lang(21), css: "icoButton byCenter button_primary icnBtnPd03"}, // "21" : "Позвонить",
                    { view: "button", type: "icon", id: "startVideoCall", click: function() {$scope.startVideoCall()}, icon: "video-camera", label: mcService.Lang(22), css: "icoButton byCenter button_success icnBtnPd03"}, // "22" : "Видеозвонок",
                    { view: "button", type: "icon", id: "stopCall",       click: function() {$scope.stopCall()},       icon: "times", label: mcService.Lang(23), css: "icoButton byCenter button_danger button_raised icnBtnPd03", hidden: true}, // "23" : "Завершить звонок",

                    { width: 4, css: "noBGColor"}
                ]},

                {id: 'uPrivateInfo', template: 'User Info', scroll: "y", css: "myScroll noBGColor selectable", borderless: true},

                { height: 40, cols: [
                    { template: "<div id='uPrivateTypingNotify'><img id='animateTypingNotify' class='hidden' src='" + mcConst.imagesPath.all + "pero.gif' ></div>", width: 32, height: 30, padding: 0, borderless: true, css: "noBGColor"},
                    { rows: [
                        { id: 'uPrivateState', template: mcService.Lang(29), css: "noBGColor framePaddingW10", height: 18, borderless: true}, // "29" : "Не в сети",
                        { id: 'uPrivateTypingTextNotify', template: ' ', borderless: true, css: "noBGColor framePaddingW10", height: 24}
                    ]}
                ]}
            ]},

            { id: uAct + $scope.Name, hidden: true, rows:[
                { id: uAct + "DisplayName", view: "template", template: " ", borderless: true, autoheight: true},
                { height: 1, css: "borderBottom"},
                { height: 2 },

                { view: "scrollview", borderless: true, css: "noBGColor myScroll", body: { rows: [
                    { view: "button", type: "icon", icon: "exchange", label: mcLang(582), click: $scope.directSend,   css: "noUpperCase byCenter", height: 30}, // "582":"Передать файлы",
                    { id: uAct + "RedirectBtn", view: "button", type: "icon", icon: "reply",    label: mcLang(618), on: {onItemClick: $scope.showRedirect}, css: "noUpperCase byCenter", height: 30}, // "618":"Перенаправить",

                    { id: uAct + "RedirectUserWrap", hidden: true, rows: [
                        new mcService.FilterFiled({
                            listName     : uAct + "RedirectUserList",
                            css          : "noBorderAll",
                            clearID      : "RedirectUser",
                            id           : "FilterRedirectUser",
                            // noClearBtn   : true,
                            placeholder  : mcLang(48), // "48" :"Поиск...",
                            filterParams : ['DisplayName', 'UIN'],
                            keyEvents    : {
                                13: function (_item) {
                                    var item = _item || $scope.RedirectUserList.getSelectedItem() || $scope.RedirectUserList.getItem($scope.RedirectUserList.getFirstId());

                                    if (item){
                                        $scope.doRedirect(item);

                                        return true;
                                    }
                                },
                                27: function () {
                                    $scope.hideRedirectList();
                                }
                            }
                        }),

                        { id: uAct + "RedirectUserList", view: "list", css: "myScroll noBGColor",
                            template: function (obj) {
                                return obj.DisplayName;
                            },
                            on: {
                                onItemDblClick: function (id) {
                                    $scope.doRedirect($scope.RedirectUserList.getItem(id));
                                }
                            }
                        },
                        { view: "button", value: mcLang(33), click: function () { // "33" :"Отмена",
                            $scope.hideRedirectList();
                        }}
                    ]},

                    { height: 1, css: "borderBottom"},

                    { id: uAct + "ReceiveFiles", view: "checkbox", value: $scope.userConfig.autoReceive, opt: "autoReceive",
                        labelRight: mcLang(602), labelWidth: 0, css: "finger font14l", click: $scope.changeOptions}, // "602":"Принимать файлы не задавая вопросов",

                    {gravity:0},
                ]}},

                { view: "button", value: mcLang(552), click: $scope.removeUserFromDialogs} // "552":"Закрыть диалог",
            ]}
        ]});

        __view = $$($scope.Name);

        $scope.uPrivateInfo = $$("uPrivateInfo");
        $scope.uFoto = $$("uFoto");

        $scope.callBTN.startVoiceCall = $$("startVoiceCall");
        $scope.callBTN.startVideoCall = $$("startVideoCall");
        $scope.callBTN.startShareCall = $$("startShareCall");
        $scope.callBTN.stopCall       = $$("stopCall");
        $scope.userActionsDisplayName = $$("userActionsDisplayName");
        $scope.chckReceiveFiles       = $$(uAct + "ReceiveFiles");
        $scope.RedirectUserWrap       = $$(uAct + "RedirectUserWrap");
        $scope.RedirectUserList       = $$(uAct + "RedirectUserList");
        $scope.RedirectBtn            = $$(uAct + "RedirectBtn");
        $scope.SwitchTool             = $$(uAct + "SwitchTool");

        $scope.PrivateState = $$("uPrivateState");
        $scope.PrivateTypingTextNotify = $$("uPrivateTypingTextNotify");

        $scope.userActions  = $$("userActions" + $scope.Name);
        $scope.userInfo     = $$("userInfo" + $scope.Name);

        $scope.callBTN.startShareCall.getNode().title = mcLang(604); // "604":"Демонстрация экрана",
        $scope.callBTN.startVideoCall.getNode().title = mcLang(606); // "606":"Видео звонок",
        $scope.callBTN.startVoiceCall.getNode().title = mcLang(605); // "605":"Голосовой звонок",

        // mcService.disableContextMenu(__view);
    } else {
        __view.show();
    }

    return __view;
}"use strict";

function privateInfoController($scope, $rootScope, mcMedia, mcSound){
    $scope.Name = mcConst.dataModels.PrivateInfo;

    var view       = null;
    var what       = "DISPLAYNAME,SEX,UIN,EMAIL,WORK_PHONE,WORK_DIVDEPT,HOME_BIRTHDAY,WORK_POSITION,WORK_COMPANYNAME,CLIENTVERSION,ROLE";
    var currentUIN = 0;
    var fieldInfo  = {
        UIN             : '<i class="fa fa-asterisk"></i>&nbsp;',
        EMAIL           : '<i class="fa fa-envelope-o"></i>&nbsp;',
        WORK_PHONE      : '<i class="fa fa-phone"></i>&nbsp;',
        WORK_DIVDEPT    : '<i class="fa fa-sitemap"></i>&nbsp;',
        HOME_BIRTHDAY   : '<i class="fa fa-birthday-cake"></i>&nbsp;',
        WORK_POSITION   : '<i class="fa fa-briefcase"></i>&nbsp;',
        WORK_COMPANYNAME: '<i class="fa fa-building-o"></i>&nbsp;',
        CLIENTVERSION   : '<i class="fa fa-comments"></i>&nbsp;',
        ROLE            : '<i class="fa fa-users"></i>&nbsp;',
        IGNORE          : '<i class="fa fa-ban red"></i>&nbsp;'
    };
    var sexIcon    = {
        0: "<span class='fa fa-user'></span>",
        1: "<span class='fa fa-male'></span>",
        2: "<span class='fa fa-female'></span>"
    };

    var timerTypingNotify = null;
    var isWebSupportUser = false;

    $scope.PrivateTypingTextNotify = null;
    $scope.noImage      = '<img id="uFotoCanvas" src="' + mcConst.imagesPath.all + 'noimage.png" border="0">';
    $scope.uPrivateInfo = null;
    $scope.uFoto        = null;
    $scope.PrivateState = null;
    $scope.userConfig   = {};
    $scope.callBTN      = {
        startVoiceCall: null,
        startVideoCall: null,
        stopCall      : null
    };

    window._userActions.openUserProfile = function (uin, name){
        $rootScope.$broadcast("changeCenterView", [mcConst.dataModels.UserProfile, uin]);
        $rootScope.$broadcast("selectTool");
    };

    webix.ready(function(){
        mcMedia.prepare();

        mcMedia.onShowMedia = function(data){
            $rootScope.$broadcast('showVideoFrame', [data]);
        };

        mcMedia.onCloseCall = function(data){
            $scope.hideStopCall();

            $rootScope.$broadcast('hideVideoFrame',  [data]);
            $rootScope.$broadcast('SendCMDToServer', [ mcConst._CMD_.cs_media_exit_from_mid, mcConst.SessionID, data.MID]);
        };

        mcMedia.infoMessage = function(txt){
            $rootScope.$broadcast('addCustomMSG', [txt])
        };
    });

    //=======================================

    function fillUserInfo(data, uin){
        $scope.data = data;

        var list = $scope.data.What.split(',');
        var res = [
            mcService.myReplaceFormated(
                '<div class="byCenter bolder brown lHeight30 finger" onclick="window._userActions.openUserProfile(#{uin},\'#{name}\')">#{sex}#{name}</div>',
                {
                    uin         : currentUIN,
                    name        : $scope.data.DISPLAYNAME,
                    sex         : sexIcon[$scope.data.SEX]
                }
            ),

            fieldInfo.UIN + uin
        ];

        $scope.userActionsDisplayName.define('template', res[0]);
        $scope.userActionsDisplayName.refresh();

        $scope.data.HOME_BIRTHDAY = mcService.toNormalDate($scope.data.HOME_BIRTHDAY);

        for (var i = 2; i < list.length; i++)
            if ( $scope.data[list[i]] !== ''){
                if ((list[i] === "HOME_BIRTHDAY" && $scope.data[list[i]] !== "01.01.1900") || (list[i] !== "HOME_BIRTHDAY"))
                    res.push("&nbsp;" + fieldInfo[list[i]] + $scope.data[list[i]]);
            }

        $scope.uPrivateInfo.setHTML(res.join('<br>'));
    }

    function fillPrivateInfo (data, uin){
        $rootScope.$broadcast('getUserIgnoreInfo', [uin, function(ignores){
            if (ignores && ignores.Ignores[1] == '1'){
                data.What += ',IGNORE';

                data.IGNORE = mcService.Lang(50); // "50" : "В игноре",
            }
        }]);

        fillUserInfo(data, uin);

        $rootScope.$broadcast('getUserState', [uin, changeState]);

        $scope.userConfig = $rootScope.customUserOptions.getUser(uin);

        $scope.chckReceiveFiles.setValue($scope.userConfig.autoReceive);
    }

    function startDrawTypingNotify(){
        if (view && view.isVisible()){
            var notifyView = mcService.getFrame('uPrivateTypingNotify');

            if (notifyView && notifyView.className.indexOf('noBG') === -1) {
                notifyView.className += ' noBG';
            }
            mcService.showFrame('animateTypingNotify');

            $scope.PrivateTypingTextNotify.define('template', mcService.Lang(49)); // "49" : "пишет...",
            $scope.PrivateTypingTextNotify.refresh();
        }
    }

    function stopDrawTypingNotify(){
        // var notifyView = mcService.getFrame('uPrivateTypingNotify');

        clearTimeout(timerTypingNotify);

        timerTypingNotify = null;

        mcService.hideFrame('animateTypingNotify');

        if (view && view.className && view.className.indexOf('noBG') !== -1) {
            view.className = view.className.replace(' noBG', "");
        }

        $scope.PrivateTypingTextNotify.define('template', ' ');
        $scope.PrivateTypingTextNotify.refresh();
    }

    function changeState(state){
        if ($scope.PrivateState){
            switch (parseInt(state)){
                case mcConst.states.offline:
                    $scope.PrivateState.define('template', mcService.Lang(29)); break; // "29" : "Не в сети",

                case mcConst.states.online:
                    $scope.PrivateState.define('template', '<span class="green">' + mcService.Lang(30) + '</span>'); break; // "30" : "В сети",

                case mcConst.states.webOnline:
                    $scope.PrivateState.define('template', '<span class="green">' + mcService.Lang(30) + '</span>'); break; // "30" : "В сети",

                case mcConst.states.away:
                    $scope.PrivateState.define('template', '<span class="blue">' + mcService.Lang(31) + '</span>'); break; // "31" : "Нет на месте",

                case mcConst.states.dnd:
                    $scope.PrivateState.define('template', '<span class="red">' + mcService.Lang(32) + '</span>'); break; // "32" : "Не беспокоить",
            }

            $scope.PrivateState.refresh();

            if (mcConst.states.offline == state){
                $scope.callBTN.startShareCall.disable();
                $scope.callBTN.startVideoCall.disable();
                $scope.callBTN.startVoiceCall.disable();
            } else {
                $scope.callBTN.startShareCall.enable();
                $scope.callBTN.startVideoCall.enable();
                $scope.callBTN.startVoiceCall.enable();
            }
        }
    }

    // ======================================

    $scope.showStopCall   = function() {
        if ($scope.callBTN.startVideoCall){
            $scope.callBTN.startShareCall.hide();
            $scope.callBTN.startVideoCall.hide();
            $scope.callBTN.startVoiceCall.hide();

            $scope.callBTN.stopCall.show();
        }
    };

    $scope.hideStopCall   = function() {
        if ($scope.callBTN.stopCall){
            $scope.callBTN.stopCall.hide();

            $scope.callBTN.startShareCall.show();
            $scope.callBTN.startVideoCall.show();
            $scope.callBTN.startVoiceCall.show();
        }
    };

    $scope.startVoiceCall = function() {
        $scope.showStopCall();

        mcMedia.myCall(currentUIN, false, false, $scope.hideStopCall);
    };

    $scope.startVideoCall = function() {
        $scope.showStopCall();

        mcMedia.myCall(currentUIN, true, false, $scope.hideStopCall);
    };

    $scope.startShareCall = function() {
        $scope.showStopCall();

        mcMedia.myCall(currentUIN, false, true, $scope.hideStopCall);
    };

    $scope.stopCall       = function(){
        if (mcMedia.nowCalling()){
            $rootScope.$broadcast('SendCMDToServer', [ mcConst._CMD_.cs_media_call_close, mcConst.SessionID, mcMedia.getUIN()]);

            mcMedia.CloseCall(mcMedia.callStates.stopCall, { DisplayName: $scope.data.DISPLAYNAME });

            mcSound.PlaySound(mcSound.Sounds.End);

            if (!$rootScope.isWebClient) {
                $rootScope.$broadcast(window._messages_.clientData.toggleKioskMode, [false]);
            }
        }
    };

    // -----------------------

    $scope.showRedirect = function(){
        isWebSupportUser = false;
        
        if ($rootScope.GetChatType() === $rootScope.chatAliases.UIN && $rootScope.GetChatID()){
            $scope.RedirectBtn.disable();

            $rootScope.$broadcast('SendCMDToServer', [
                mcConst.lockInterface,
                mcConst._CMD_.cs_get_users_for_redirect_dialog,
                mcConst.SessionID,
                $rootScope.GetChatID(),

                function (list) {
                    // "UIN"        : 8517,                    // пользователь, которого будем редиректить
                    // "WebSupport" : true,                    // true, если это список людей из websupport-а, false - если полный список людей с сервера, кроме Web Guests
                    // "Users"      :                          // список пользователей для редиректа. Массив объектов, в массиве может быть UIN отправителя запроса, его следует пропустить при рендеринге
                    // [{
                    //         "UIN"         : 17,               // UIN пользователя
                    //         "DisplayName" : "Terminator",     // отображаемое в чате имя
                    //         "Avatar"      : 21,               // аватар пользователя
                    //         "Sex"         : 1,                // пол пользователя
                    //         "State"       : 0                 // текущий статус пользователя (0 - свободен)
                    // }]
                    isWebSupportUser = list.WebSupport;

                    $scope.RedirectUserWrap.show();
                    $scope.RedirectUserList.parse(list.Users);
                    
                    $$("FilterRedirectUserEditor").focus();
                }
            ]);
        }
    };

    $scope.hideRedirectList = function(){
        $$("clearBtnRedirectUser").callEvent("onItemClick");

        $scope.RedirectUserWrap.hide();
        $scope.RedirectUserList.clearAll();
        $scope.RedirectBtn.enable();
    };

    $scope.doRedirect = function(userTo){
        if (userTo && $rootScope.GetChatType() === $rootScope.chatAliases.UIN){
            $scope.hideRedirectList();

            $rootScope.$broadcast('SendCMDToServer', [
                mcConst._CMD_.cs_redirect_private_talk,
                mcConst.SessionID,
                
                $rootScope.GetChatID(),
                userTo.UIN
            ]);

            if (isWebSupportUser){
                $rootScope.$broadcast(_messages_.dialogsList.removeDialogFromList, [$rootScope.GetChatID()]);
            }
        }
    };

    $scope.changeOptions  = function() {
        var val = this.getValue();
        var opt = this.config.opt;

        $scope.userConfig[opt] = val;

        $rootScope.customUserOptions.setUserOption(currentUIN, opt, val);
    };

    $scope.directSend     = function() {
        $rootScope.$broadcast(window._messages_.downloadUpload.sendFilesToUser);
    };

    $scope.drawFoto       = function(fotoData){
        if (fotoData && fotoData.CRC32){
            $scope.uFoto.define('template', '<img id="uFotoCanvas" src="data:image/jpg;base64,' + fotoData.Foto +'">');
            $scope.uFoto.refresh();
        }
    };

    $scope.changeView     = function (newView) {
        if (newView === '1'){
            $scope.userInfo.hide();
            $scope.userActions.show();
        } else {
            $scope.userActions.hide();
            $scope.userInfo.show()
        }
    };

    $scope.removeUserFromDialogs = function () {
        $rootScope.$broadcast('removeDialogFromList', [$rootScope.GetChatID()]);
    };

    $scope.getData        = function(uin){
        if (currentUIN != uin){
            $rootScope.$broadcast('SendCMDToServer', [
                mcConst._CMD_.cs_get_uin_foto,
                mcConst.SessionID,
                uin,
                $scope.drawFoto
            ]);

            $rootScope.$broadcast('SendCMDToServer' , [
                mcConst._CMD_.cs_get_private_info,
                mcConst.SessionID,
                uin,
                what,
                function( data ){
                    fillPrivateInfo(data, uin);
                }
            ]);

            $rootScope.setTool($scope.Name);
        }
    };

    $scope.show           = function(uin){
        view = initPrivateInfo($scope);

        if (currentUIN != uin){
            $scope.uPrivateInfo.define('template', "");
            $scope.uPrivateInfo.refresh();

            $scope.uFoto.define('template', ($rootScope.needFoto == 0) ? $scope.noImage : ' ');
            $scope.uFoto.refresh();
        }
    };

    // ===== RECEIVE ====

    $rootScope.$on('sc_media_call',         function Receive_Call(e, args) {
        var obj = args[0];

        mcSound.PlaySound(mcSound.Sounds.Receive);

        if (!$rootScope.isWebClient){
            $rootScope.$broadcast(window._messages_.clientData.sendCMDToElectron, [
                mcConst._CMD_.ce_show_on_top
            ]);
        }

        mcMedia.callQuestions(obj, function () {
            $rootScope.$broadcast('OpenPrivate', [obj.UIN]);

            $scope.showStopCall();
        });
    });
    $rootScope.$on('sc_media_call_accept',  function Receive_Accept(e, args) { // my call
        var obj = args[0];

        mcMedia.setInfo(obj, obj.Video, false);
        mcMedia.preShow(obj.Video);

        // $rootScope.$broadcast('showVideoFrame', [mcMedia.withVideo(), mcMedia.withSharing()]);
    });
    $rootScope.$on('sc_media_call_reject',  function Receive_Reject(e, args) {
        var obj = args[0];

        if (obj.UIN == mcMedia.getUIN()){
            mcMedia.CloseCall(mcMedia.callStates.reject);
        }
    });
    $rootScope.$on('sc_media_call_close',   function Receive_Close(e, args){
        var obj = args[0];

        if (obj.UIN == mcMedia.getUIN() && mcMedia.nowCalling()){
            mcMedia.CloseCall(mcMedia.callStates.close, { DisplayName: $scope.data.DISPLAYNAME });

            mcSound.PlaySound(mcSound.Sounds.End);
        }
    });
    $rootScope.$on('sc_media_call_error',   function Receive_Error(e, args){
        var _data = args[0];
        var err   = mcService.isObject(_data) ? JSON.stringify(_data) : _data;

        console.warn('Media error code: ' + err);

        if (mcMedia.nowCalling()){
            mcMedia.CloseCall(mcMedia.callStates.error);

            mcSound.PlaySound(mcSound.Sounds.End);
        }
    });
    $rootScope.$on('sc_media_call_busy',    function Receive_Busy() {
        mcMedia.CloseCall(mcMedia.callStates.busy);
    });
    $rootScope.$on('sc_media_ready',        function Receive_Ready(e, args) {
        if (args[0].UIN == mcMedia.getUIN()){    // irrorContainer undefined! Use "setMirror" first!
            mcMedia.recvReady(args[0].UIN);
        }
    });
    $rootScope.$on('sc_media_offer',        function Receive_Offer(e, args) { // call to me
        mcMedia.preShow();
        mcMedia.recvOffer(args[0]);

        // $rootScope.$broadcast('showVideoFrame', [mcMedia.withVideo(), mcMedia.withSharing()]);
    });
    $rootScope.$on('sc_media_answer',       function Receive_Answer(e, args) {
        mcMedia.recvAnswer(args[0]);
    });
    $rootScope.$on('sc_media_ice_candidate',function Receive_Ice_Candidate(e, args) {
        mcMedia.recvCandidate(args[0]);
    });
    $rootScope.$on('sc_media_incoming_call_missed',function Receive_Incoming_Call_Missed(e, args) {
        
    });

    // ================================================

    var _msg = _messages_.privateInfo = {
        stopCurrentCall             : "stopCurrentCall",
        addIgnoreInPrivateInfo      : "addIgnoreInPrivateInfo",
        removeIgnoreInPrivateInfo   : "removeIgnoreInPrivateInfo",
        fillPrivateInfo             : "fillPrivateInfo",
        onlineOfflineUsers          : "onlineOfflineUsers",
        onTypingNotify              : "onTypingNotify",
        HideStopCall                : "HideStopCall",
        redirectUserTo              : "redirectUserTo"
    };

    $scope.$on(_msg.stopCurrentCall, function(){
        $scope.stopCall();
    });

    $scope.$on(_msg.addIgnoreInPrivateInfo, function(e, args){
        var uin = args[0];

        if (uin == currentUIN){
            $scope.data.What += ',IGNORE';
            $scope.data.IGNORE = mcService.Lang(50); // "50" : "В игноре",

            fillUserInfo($scope.data, currentUIN);
        }
    });

    $scope.$on(_msg.removeIgnoreInPrivateInfo, function(e, args){
        var uin = args[0];

        if (uin == currentUIN){
            $scope.data.What = $scope.data.What.toString().replace(',IGNORE', '');

            if ($scope.data.IGNORE) delete $scope.data.IGNORE;

            fillUserInfo($scope.data, currentUIN);
        }
    });

    $scope.$on(_msg.fillPrivateInfo, function(e, args){
        fillPrivateInfo(args[0], currentUIN);
    });

    $scope.$on(_msg.onlineOfflineUsers, function(e, args){
        var Statuses = mcService.getStateStatuses(args[0]);

        if (mcService.inArrayNoStrict(currentUIN, Statuses.Online) >= 0){
            changeState(mcConst.states.online);
        } else
        if (mcService.inArrayNoStrict(currentUIN, Statuses.Offline) >= 0){
            changeState(mcConst.states.offline);

            $scope.stopCall();
        }
    });

    $scope.$on(_msg.onTypingNotify, function(e, args){
        var uin = args[0].UIN;

        if (uin == currentUIN){
            if (!timerTypingNotify){
                startDrawTypingNotify();

                timerTypingNotify = setTimeout(function(){
                    stopDrawTypingNotify();
                }, 5800);
            }
        }
    });

    $scope.$on(_msg.HideStopCall, function(){
        $scope.hideStopCall();
    });

    $scope.$on(_msg.redirectUserTo, function(){
        if ($rootScope.GetChatType() === $rootScope.chatAliases.UIN && $rootScope.GetChatID){
            $rootScope.$broadcast("selectTool", [mcConst.dataModels.PrivateInfo, !$rootScope.$broadcast(_messages_.chatWrapper.isVisibleRightSide)]);

            $scope.SwitchTool.setValue('1');

            $scope.RedirectBtn.callEvent("onItemClick");
        }
    });

    $scope.$on('hide' + $scope.Name, function(){
        view.hide();
        currentUIN = -1;
    });

    $scope.$on('show' + $scope.Name, function(e, args){
        $scope.container = args[0];

        var uin = $rootScope.GetChatID();

        if (uin != currentUIN || $rootScope.getTool() != $scope.Name) {
            $scope.show(uin);
            $scope.getData(uin);

            currentUIN = uin;

            if (mcMedia.nowCalling()){
                $scope.showStopCall();
            }
        }
    });
}
"use strict";

function initCommonFiles($scope){
    var view = $$($scope.Name);

    function filesTemplate(obj) {
        return obj.name;
    }

    if (!view) {
        $$($scope.container).addView({
            id   : $scope.Name,
            rows : [
                { view: "list", id: "ftpList" + $scope.Name, template: filesTemplate, select: true}
            ]
        });

        view = $$($scope.Name);

        $scope.fileList = $$("ftpList" + $scope.Name);
    } else {
        view.show();
    }

    return view;
}"use strict";

function commonFilesController($scope, $rootScope){
    $scope.Name = mcConst.dataModels.CommonFiles;

    var iFrame = null;

    function setFtpUrl(url) {
        if (iFrame && url.indexOf(mcService.getLocalHostPath($rootScope.isWebClient) === 0)){
            iFrame.define("src", url);
        } else {
            console.error("Wrong URL for iFrame:" + url);
        }
    }

    // ==================================

    $scope.pinTool = function(on){
        $rootScope.$broadcast( on ? 'pinTool' : 'unPinTool', [$scope.Name]);
    };

    $scope.getData = function(){
        var task = new mcService.TaskList();

        task.AddTask(function () {
            $rootScope.SendCMDToServer([
                mcConst._CMD_.cs_get_public_ftp_info,
                mcConst.SessionID,

                function (info) {
                    mcConst.FTP.CommonUser = info.Login;
                    mcConst.FTP.CommonPWD  = info.Pass;

                    task.Next();
                }
            ]);
        });

        task.AddTask(function () {
            $rootScope.$broadcast("sendCMDToElectron", [
                mcConst._CMD_.ce_ftp_login,
                mcConst.FTP.CommonUser,
                mcConst.FTP.CommonPWD,

                function () {
                    task.Next();
                }
            ]);
        });

        task.AddTask(function () {
            $rootScope.$broadcast(window._messages_.clientData.sendCMDToElectron, [
                mcConst._CMD_.ce_ftp_list,
                './',
                function (data) {
                    console.log(data);

                    $scope.fileList.clearAll();
                    $scope.fileList.parse(data);
                }
            ]);
        });

        task.Run();
    };

    $scope.show = function(){
        $rootScope.setTool($scope.Name);

        iFrame = initCommonFiles($scope);
    };

    // ==================================

    var _msg = _messages_.commonFiles = {
        openCommonFilesUrl  : 'openCommonFilesUrl'
    };

    $scope.$on(_msg.openCommonFilesUrl, function (e, args) {
        setFtpUrl.apply(null, args);
    });

    $scope.$on('hide' + $scope.Name, function(){
        iFrame.hide();
    });

    $scope.$on('show' + $scope.Name, function(e, args){
        $scope.container = args[0];

        $scope.pathFTP = mcService.getLocalHostPath(true);

        $scope.show();
        $scope.getData();
    });
}
"use strict";

function initHistoryDialogs($scope){
    var __view = $$($scope.Name);

    if (!__view){
        var filter = new mcService.FilterFiled({
            listName     : "historyList" + $scope.Name,
            css          : "noBorderAll",
            noClearBtn   : true,
            placeholder  : mcLang(48), // "48" :"Поиск...",
            filterParams : ['DisplayName']
        });

        $$($scope.container).addView({ id: $scope.Name, rows: [
            { cols: [
                { view: "label", label: mcLang(578), align: 'center'}, //  "578":"История диалогов",

                { view:"toggle", type:"iconButton", id: "pin" + $scope.Name, offIcon: "nezamok", onIcon: "lock", width: 30, css: "btnPaddingToggle4", paddingX: 3, on:{
                    onChange: $scope.pinTool
                }, tooltip: mcLang(511)} //  "511":"Закрепить/открепить",
            ]},

            filter,

            { view: "unitlist", css: "myScroll lineHeight20 noBGColor" + (!isMobile? " scrollMenuYX": ""),
                scroll: false,
                id: "historyList" + $scope.Name,
                uniteBy: function(obj){
                    return obj.date;
                },
                type: {
                    headerHeight:25,
                    height: 25
                },
                scheme:{
                    $sort: function(a, b){
                        return mcService.sortAB(b.sortDate, a.sortDate);
                    }
                },
                template: function (obj) {
                    return obj.DisplayName + " <span class='messageKanbanTime toRight'>(" + obj.time + ")</span>";
                },
                data: $scope.data,
                on: { onItemClick: $scope.openPrivate }
            }
        ]});

        __view = $$($scope.Name);

        $scope.historyList = $$("historyList" + $scope.Name);
    } else {
        __view.show();

        $$("pin" + $scope.Name).setValue(false);
    }

    return __view;
}"use strict";

function historyDialogsController($scope, $rootScope){
    $scope.Name = mcConst.dataModels.HistoryDialogs;

    var _view = null;

    $scope.data = [];

    // =======================================================

    function historyUser(_user) {
        var dt = _user.dtLastMessage.split('.');

        if (dt){
            _user.date = mcService.myReplaceFormated(
                "#{day} #{month}, #{year}",
                {
                    day  : dt[0],
                    month: webix.i18n.calendar.monthShort[dt[1] - 1],
                    year : dt[2]
                }
            );

            _user.time = mcService.myReplaceFormated(
                "#{hour}:#{min}:#{sec}",
                {
                    hour: dt[3],
                    min : dt[4],
                    sec : dt[5]
                }
            );
        }

        _user.sortDate = mcService.sortableDate(_user.dtLastMessage);

        return _user;
    }

    function fillDialogsHistory(data){
        $scope.data = mcService.convertObjToArray(data || $scope.data);

        $scope.data.forEach(function (val) {
            historyUser(val);

            val.id = "hs_" + val.UIN;
        });

        if ($scope.historyList){
            $scope.historyList.clearAll();
            $scope.historyList.parse($scope.data);
        }
    }

    function addOrMove(user) {
        if (user && user.UIN !== undefined){
            var __id = "hs_" + user.UIN;

            user.id = __id;

            if ($scope.historyList){
                var item = $scope.historyList.getItem(__id);

                if (item) {
                    item = mcService.Marge(item, historyUser(user));

                    $scope.historyList.updateItem(__id, item);
                    $scope.historyList.moveTop(__id);
                } else {
                    $scope.historyList.add(historyUser(user), 0);
                }
            } else {
                var idx = mcService.findItemInArrayOfObj($scope.data, user.UIN, "UIN");

                if (idx === -1){
                    $scope.data.unshift(historyUser(user));
                } else {
                    $scope.data[idx] = historyUser(user);
                }
            }
        }
    }

    function removeUser(uin) {
        // todo: если нужно добавить возможность удалять пользователей из истории
    }

    // =======================================================

    $scope.openPrivate = function(id){
        var user = $scope.historyList.getItem(id);

        if (user) {
            $rootScope.$broadcast('OpenPrivate', [user.UIN]);
        }
    };

    $scope.pinTool = function(on){
        $rootScope.$broadcast( on ? 'pinTool' : 'unPinTool', [$scope.Name]);
    };

    $scope.show = function(){
        $rootScope.setTool($scope.Name);

        _view = initHistoryDialogs($scope);
    };

    // =============================================

    var _msg = _messages_.historyDialogs = {
        dListAddOrModifyUser    : 'dListAddOrModifyUser',
        dListFillHistory        : 'dListFillHistory',
        dListHistoryRemoveUser  : 'dListHistoryRemoveUser',
    };

    $scope.$on(_msg.dListHistoryRemoveUser, function (e, args) {
        removeUser.apply(null, args);
    });

    $scope.$on(_msg.dListAddOrModifyUser, function (e, args) {
        addOrMove.apply(null, args);
    });

    $scope.$on(_msg.dListFillHistory, function (e, args) {
        fillDialogsHistory.apply(null, args);
    });

    $scope.$on('hide' + $scope.Name, function(){
        _view.hide();
    });

    $scope.$on('show' + $scope.Name, function(e, args){
        $scope.container = args[0];

        $scope.show();
    });
}
"use strict";

function initReceiveFiles($scope){
    var __view = $$($scope.Name);

    if (!__view){
        $$($scope.container).addView({ id: $scope.Name, rows: [
            { cols: [
                { view: "label", label: mcLang(588), align: 'center'}, //  "588":"Прием файлов",

                { view:"toggle", type:"iconButton", id: "pin" + $scope.Name, offIcon: "nezamok", onIcon: "lock", width: 30, css: "btnPaddingToggle4", paddingX: 3, on:{
                    onChange: $scope.pinTool
                }, tooltip: mcLang(511)} //  "511":"Закрепить/открепить",
            ]},


            { id: "receiveInfo" + $scope.Name, view: "template", template: "&nbsp;", borderless: true, padding: 2, css: "noBGColor", autoheight: true},

            { height: 5},

            { id: "filesList" + $scope.Name, view: "list", css: "lineHeight20 noBGColor borderBottom",
                type: {
                    height: "auto"
                },
                template: function (obj) {
                    return obj.fileName + " <span class='messageKanbanTime'>(" + mcService.formatFileSize(obj.size) + ")</span>";
                },
                data: $scope.data
            },

            { height: 5},

            { css: "borderBottom", rows: [
                { view: "button", type: "icon", icon: "folder", label: mcLang(595), click: $scope.changeReceiveFolder, tooltip: mcLang(596), css: "noUpperCase"}, // "596":"Сменить папку для приема фалов",
                { id: "receiveFolder" + $scope.Name, view: "template", template: "&nbsp;", borderless: true, autoheight: true, css: "noBGColor brown"},
                { height: 5}
            ]},

            { height: 5},

            { height: 30, cols: [
                { view: "button", value: mcLang(592), click: $scope.startReceive}, // "592":"Принять",
                { view: "button", value: mcLang(33),  click: $scope.cancelReceive, type: "danger"}, // "33" :"Отмена",
            ]},

            { height: 5}
        ]});

        __view = $$($scope.Name);

        $scope.pinFiles      = $$("pin" + $scope.Name);
        $scope.filesList     = $$("filesList" + $scope.Name);
        $scope.receiveInfo   = $$("receiveInfo" + $scope.Name);
        $scope.receiveFolder = $$("receiveFolder" + $scope.Name);
    } else {

    }

    __view.show();

    return __view;
}"use strict";

function receiveFilesController($scope, $rootScope){
    $scope.Name = mcConst.dataModels.ReceiveFiles;

    var _view = null;

    $scope.data = null;

    // =======================================================
    
    function setData(data) {
        // FilesList
        // DisplayName
        // UIN
        // Size
        // Count

        $scope.data = data;

        $scope.receiveInfo.define('template', mcService.myReplaceFormated(
            "<div class='borderBottom lHeight28'>" +
                "#{tFrom} <span class='bolder brown'>#{from}</span><br>" +
                "#{tSize} <span class='bolder brown'>#{size}</span><br>" +
            "</div>",
            {
                tFrom : mcLang(593), // "593":"От:",
                tSize : mcLang(594), // "594":"Объем:",

                from  : $scope.data.DisplayName,
                size  : mcService.formatFileSize($scope.data.Size),
                count : $scope.data.Count
            }
        ));
        $scope.receiveInfo.refresh();

        $scope.receiveFolder.define("template", $scope.data.DownloadPath);
        $scope.receiveFolder.refresh();

        $scope.filesList.clearAll();
        $scope.filesList.parse($scope.data.FilesList);
    }
    
    // =======================================================

    $scope.pinTool = function(on){
        $rootScope.$broadcast( on ? 'pinTool' : 'unPinTool', [$scope.Name]);
    };

    $scope.changeReceiveFolder = function () {
        $rootScope.$broadcast(window._messages_.clientData.sendCMDToElectron, [
            mcConst._CMD_.ce_file_set_new_folder_for_user,
            $scope.data.DownloadPath,
            
            function (newPath) {
                $scope.data.DownloadPath = newPath;
                
                $scope.receiveFolder.define("template", $scope.data.DownloadPath);
                $scope.receiveFolder.refresh();
            }
        ]);
    };

    $scope.startReceive = function () {
        $rootScope.$broadcast(window._messages_.downloadUpload.acceptReceiveFiles, [$scope.data.DownloadPath]);
    };

    $scope.cancelReceive = function () {
        $rootScope.$broadcast(window._messages_.downloadUpload.rejectReceiveFiles);
    };

    $scope.show = function(){
        $rootScope.setTool($scope.Name);

        _view = initReceiveFiles($scope);

        if (!$scope.pinFiles.getValue()){
            $scope.pinFiles.callEvent("onItemClick");
        } else {
            $scope.pinTool(true);
        }
    };

    // =============================================

    var _msg = _messages_.receiveFiles = {
        setReceiveFilesInfo : 'setReceiveFilesInfo',
    };

    $scope.$on(_msg.setReceiveFilesInfo, function (e, args) {
        setData.apply(null, args);
    });

    $scope.$on('hide' + $scope.Name, function(){
        _view.hide();
    });

    $scope.$on('show' + $scope.Name, function(e, args){
        $scope.container = args[0];

        $scope.show();
    });
}
"use strict";

function initDialogs($scope){
    function chView(obj){
        var badge = mcService.myReplaceFormated(
            "<span class='webixtype_base webix_badge' id='badge#{id}' style='#{show};'>#{value}</span>",
            {
                id   : obj.id,
                show : "display:" + (!obj.badge ? "none" : "block"),
                value: obj.badge
            }
        );

        return "<span style='margin-left: -5px; margin-right: -5px'>" +
                    (obj.userCount ? "<span class='userCount'>(" + obj.userCount + ")</span> " : "") + obj.Name + badge +
               "</span>";
    }

    function cnView(obj){
        var badge = mcService.myReplaceFormated(
            "<span class='webixtype_base webix_badge' id='badge#{id}' style='#{show};'>#{value}</span>",
            {
                id   : obj.id,
                show : "display:" + (!obj.badge ? "none" : "block"),
                value: obj.badge
            }
        );

        var privateIcon = mcService.myReplaceFormated(
            "<span class='webix_icon fa-user smaller #{icon}' style='#{color}'></span>",
            {
                icon : mcConst.storageOpts.STATUSICO + obj.UIN,
                color: "color:" + mcService.getColorForStatus(obj.State)
            }
        );

        return "<span style='margin-left: -5px; margin-right: -5px'>" +
                    privateIcon + obj.Name + badge +
               "</span>";
    }

    function hideShowResizer(id, check1, check2) {
        switch (id){
            case "arcToolsList" + $scope.Name:
                check1(id, true);
            break;

            case "arcChannelsList" + $scope.Name:
            case "arcDialogsList" + $scope.Name:
                check1(id);
                
                check2(id);
            break;
        }
    }

    function check1Expand(id) {
        if (!$scope.resizer_1.config.opened.hasOwnProperty(id)) {
            $scope.resizer_1.config.opened[id] = true;
        }

        if (Object.keys($scope.resizer_1.config.opened).length >= 2 && $scope.resizer_1.config.opened.hasOwnProperty("arcToolsList" + $scope.Name)) {
            $scope.resizer_1.show();

            $scope.setHeightTool($scope.sizes.tool);
        }
    }

    function check2Expand(id) {
        if (!mcService.checkRights(mcConst._CMD_.RS.QMessengerStyle)){
            if (!$scope.resizer_2.config.opened.hasOwnProperty(id)) {
                $scope.resizer_2.config.opened[id] = true;
            }

            if (Object.keys($scope.resizer_2.config.opened).length === 2) {
                $scope.resizer_2.show();

                $scope.setHeightConf($scope.sizes.conf);
            }
        }
    }

    function check1Collapse(id) {
        if ($scope.resizer_1.config.opened.hasOwnProperty(id)) {
            delete $scope.resizer_1.config.opened[id];
        }

        if (Object.keys($scope.resizer_2.config.opened).length <= 1 || !$scope.resizer_1.config.opened.hasOwnProperty("arcToolsList" + $scope.Name)) {
            $scope.resizer_1.hide();

            $scope.setHeightTool();
        }
    }

    function check2Collapse(id) {
        if (!mcService.checkRights(mcConst._CMD_.RS.QMessengerStyle)) {
            if ($scope.resizer_2.config.opened.hasOwnProperty(id)) {
                delete $scope.resizer_2.config.opened[id];
            }

            $scope.resizer_2.hide();

            $scope.setHeightConf();
        }
    }

    var __view = $$($scope.Name);
    var hHeight = 24;

    if (!__view){
        var contacts = {
            id        : "arcDialogsList" + $scope.Name,
            view      : "accordionitem",
            css       : "lineHeight24 accordionListHeader",
            header    : mcLang(20), // "20" : "Мои диалоги",
            minHeight : 100,
            borderless: true,
            headerHeight: hHeight,
            headerAltHeight: hHeight,
            body      : { rows: [{
                id      : "dialogsList" + $scope.Name,
                view    : "list",
                data    : $scope.data || [],
                css     : "noBGColor listColorWhite lineHeight20 myScroll scrollMenu",
                borderless: true,
                select  : true,
                template: cnView,
                scroll  : "y",
                type    : {
                    headerHeight:30,
                    height: 24
                },
                on: {
                    onItemClick   : $scope.clickOnDialogItem,
                    onAfterSelect : $scope.openPrivateDialog,
                    onBeforeSelect: $scope.beforeSelect,
                    onItemDblClick: $scope.removePrivateDialog
                }
            }, { height: 10}]}
        };

        var tools    = {
            id        : "arcToolsList" + $scope.Name,
            view      : "accordionitem",
            css       : "lineHeight24 accordionListHeader",
            borderless     : true,
            headerHeight   : hHeight,
            headerAltHeight: hHeight,
            collapsed : true,
            header    : mcLang(541), // "541":"Инструменты",
            body      : {
                id      : "toolsList" + $scope.Name,
                view    : "list",
                css     : "noBGColor listColorWhite lineHeight20 myScroll scrollMenu",
                borderless: true,
                select  : true,
                scroll  : "y",
                data    : [
                    { Name: "Kanban",    badge: 0, id: mcConst.dataModels.Kanban + '-tool'},
                    { Name: mcLang(556), badge: 0, id: mcConst.dataModels.BBS + '-tool'} // "556":"Доска объявлений",
                    // { Name: "Forum",  badge: 0, id: mcConst.dataModels.Forum + '-tool'}
                ],
                template: "<span style='margin-left: -5px; margin-right: -5px'>#Name#</span>",
                type    : {
                    headerHeight:30,
                    height: 24
                },
                on: {
                    onAfterSelect: $scope.selectTools
                }
            }
        };

        var channels = {
            id        : "arcChannelsList" + $scope.Name,
            view      : "accordionitem",
            css       : "lineHeight24 accordionListHeader",
            minHeight : 90,
            borderless: true,
            headerHeight: hHeight,
            headerAltHeight: hHeight,
            collapsed : true,
            hidden    : !!mcService.checkRights(mcConst._CMD_.RS.QMessengerStyle),
            header    : mcLang(24), // "24" : "Конференции",
            body      : { rows: [{
                id      : "channelsList" + $scope.Name,
                view    : "list",
                css     : "noBGColor listColorWhite lineHeight20 myScroll scrollMenu",
                borderless: true,
                select  : true,
                scroll  : "y",
                type    : {
                    headerHeight:30,
                    height: 24
                },
                template: chView,
                on: {
                    onItemClick  : $scope.clickOnDialogItem,
                    onAfterSelect: $scope.openChannelDialog
                }
            }, {
                id    : "channelManager",
                view  : "button",
                css   : "imgBtn icoButton noBorderAll button_transparent textUnderline",
                value : mcLang(25), // "25" : "Создать конференцию...",
                click : $scope.openChannelsManager
            }]},
            on: {
                onViewResize: function () {
                    $scope.sizes.conf = this.getNode().offsetHeight;

                    $scope.saveOptions();

                    $scope.arcDialogsList.refresh();
                }
            }
        };

        $$($scope.container).addView({
            id  : $scope.Name,
            minHeight: 80,
            rows: [
            { id: "_accor1",
                view      : "accordion",
                multi     : true,
                borderless: true,
                rows      :[
                    tools
                ],
                on: {
                    onViewResize: function () {
                        $scope.sizes.tool = this.$getSize()[3];

                        $scope.saveOptions();
                    }
                }
            },

            { id: "resizer_1" + $scope.Name, view: "resizer", borderless: true, hidden: true, opened: {}},

            { id: "_accor2",
                view      : "accordion",
                multi     : true,
                borderless: true,
                rows      :[
                    channels,

                    { id: "resizer_2" + $scope.Name, view: "resizer", borderless: true, hidden: true, opened: {}},

                    contacts
                ]
            }]
        });

        __view = $$($scope.Name);

        $scope.dialogsList     = $$("dialogsList" + $scope.Name);
        $scope.arcDialogsList  = $$("arcDialogsList" + $scope.Name);

        $scope.toolsList       = $$("toolsList" + $scope.Name);
        $scope.arcToolsList    = $$("arcToolsList" + $scope.Name);

        $scope.channelsList    = $$("channelsList" + $scope.Name);
        $scope.arcChannelsList = $$("arcChannelsList" + $scope.Name);

        $scope.resizer_1       = $$("resizer_1" + $scope.Name);
        $scope.resizer_2       = $$("resizer_2" + $scope.Name);

        $scope._accor1         = $$("_accor1");
        $scope._accor2         = $$("_accor2");

        $scope._accor1.attachEvent("onAfterExpand", function (id) {
            $scope.sizes.open.tool = true;

            hideShowResizer(id, check1Expand, check2Expand);

            $scope.saveOptions();
        });

        $scope._accor1.attachEvent("onAfterCollapse", function (id) {
            $scope.sizes.open.tool = false;

            hideShowResizer(id, check1Collapse, check2Collapse);

            $scope.saveOptions();
        });

        $scope._accor2.attachEvent("onAfterExpand", function (id) {
            switch (id){
                case "arcChannelsList" + $scope.Name:
                    $scope.sizes.open.conf = true;
                break;

                case "arcDialogsList" + $scope.Name:
                    $scope.sizes.open.priv = true;
                break;
            }

            hideShowResizer(id, check1Expand, check2Expand);

            $scope.saveOptions();
        });

        $scope._accor2.attachEvent("onAfterCollapse", function (id) {
            switch (id){
                case "arcChannelsList" + $scope.Name:
                    $scope.sizes.open.conf = false;
                break;

                case "arcDialogsList" + $scope.Name:
                    $scope.sizes.open.priv = false;
                break;
            }

            hideShowResizer(id, check1Collapse, check2Collapse);

            $scope.saveOptions();
        });

        mcService.disableContextMenu(__view);
    } else {
        __view.show();
    }

    hideShowResizer("arcDialogsList" + $scope.Name, check1Expand, check2Expand);
    hideShowResizer("arcChannelsList" + $scope.Name, check1Expand, check2Expand);

    return __view;
}"use strict";

function dialogsController($scope, $rootScope, mcPlaySound){
    $scope.Name = mcConst.dataModels.Dialogs;
    $scope.data = [];

    var contacts       = null;
    var confList       = {};
    var privatList     = {};
    var privateSequence= [];
    var prevID         = 0;
    var userStatuses   = null;
    var toolSuffix     = "-tool";
    var saveTimerOption= null;

    var tabList        = [];
    var tabSelect      = null;
    var tabTimer       = null;
    // var idRemove       = -1;

    $scope.sizes = {
        conf : 120,
        tool : 120,

        open: {
            conf: true,
            tool: false,
            priv: true
        }
    };

    //=================================================

    window._userActions.openUserPrivate = function () {
        var uin = this.getAttribute('uin');

        if (uin != mcConst.UserInfo.UIN){
            $rootScope.$broadcast(window._messages_.dialogsList.OpenPrivate, [uin]);
        }
    };

    //=================================================

    var Badges = new function () {
        var list = {};

        this.update = function updateBadge(view, count){
            if (!count){
                mcService.hideFrame('badge' + view);

                if (list[view]){
                    delete list[view];
                }

                if (!$rootScope.isWebClient && Object.keys(list).length === 0){
                    $rootScope.$broadcast('sendCMDToElectron', [
                        mcConst._CMD_.ce_break_blink
                    ]);
                }
            } else {
                var itm = mcService.getFrame('badge' + view);

                if (itm){
                    itm.innerHTML = count;
                    mcService.showFrame('badge' + view);
                }

                list[view] = count;
            }
        };

        this.checkBadges = function (clearBlink) {
            var count = Object.keys(list).length;

            if (!count && clearBlink && !$rootScope.isWebClient){
                $rootScope.$broadcast('sendCMDToElectron', [
                    mcConst._CMD_.ce_break_blink
                ]);
            }

            return count
        };

        this.clearAll = function () {
            Object.keys(list).forEach(function (view) {
                mcService.hideFrame('badge' + view);
            });

            list = {};
        }
    };

    //=================================================

    function getPrivateSequence(){
        var list = $scope.dialogsList.serialize();
        var res  = [];

        for (var i = 0; i < list.length; i++){
            res.push(list[i].UIN);
        }

        return res;
    }

    function fillTabList() {
        tabList = []
            .concat($scope.sizes.open.conf ? $scope.channelsList.serialize() : [])
            .concat($scope.sizes.open.priv ? $scope.dialogsList.serialize()  : []);
    }

    function addPrivate(uin, nick, state, badge){
        var UIN = 'dUIN-' + uin;
        var item = $scope.dialogsList.getItem(UIN);

        if (!item && uin){
            var user = {
                isPrivate: true,
                id    : UIN,
                UIN   : uin,
                Name  : nick,
                badge : badge || 0,
                State : state //(userStatuses && userStatuses.hasOwnProperty(UIN)) ? userStatuses[UIN] : '-1',
            };

            $scope.data.push(user);

            $scope.dialogsList.add(user, 0);
            $scope.dialogsList.refresh();

            privatList[UIN] = user;

            privateSequence = getPrivateSequence();

            fillTabList();
        } else

        if (badge){
            item.badge = badge;

            $scope.dialogsList.updateItem(UIN, item);
            // $scope.dialogsList.refresh();
        }
    }

    function removePrivate(_uin){
        var uin = 0;
        
        if (!isNaN(parseInt(_uin))){
            uin = "dUIN-" + _uin;
        }

        var selected = $scope.dialogsList.getItem(uin);
        var position = $scope.dialogsList.getIndexById(uin);

        if (privatList.hasOwnProperty(uin) && selected){
            delete privatList[uin];

            $scope.dialogsList.remove(selected.id);
            $scope.dialogsList.refresh();

            privateSequence = getPrivateSequence();

            fillTabList();

            $rootScope.$broadcast('removeFrameChat', [$rootScope.chatAliases.UIN, _uin]);
        }

        var count = $scope.dialogsList.count();

        if (count === 0){
            $scope.$broadcast(window._messages_.dialogsList.OpenPrivate, ['0']);
        } else {
            if (position === count) {
                position--;
            }

            if (position !== -1){
                position = 0
            }

            setTimeout(function () {
                $scope.dialogsList.select($scope.dialogsList.getIdByIndex(position));
            }, 100);
        }

        // idRemove = -1;
    }

    function addConf(UID, name){
        var uid = 'dUID-' + UID;
        var data = {};

        data.id     = uid;
        data.UID    = UID;
        data.badge  = 0;
        data.isConf = true;
        // data.dType  = mcService.Lang(24); // "24" : "Конференции",
        data.Name   = name;

        confList[uid] = data;

        $scope.channelsList.add(confList[uid], 0);

        fillTabList();
    }

    function removeConf(UID){
        var uid = 'dUID-' + UID;

        if (confList[uid]){
            delete confList[uid];

            $scope.channelsList.remove(uid);
            $rootScope.$broadcast('removeFrameChat', [$rootScope.chatAliases.UID, UID]);

            fillTabList();

            var id = $scope.channelsList.getFirstId(uid);

            if (id){
                $scope.channelsList.select(id);
            } else {
                var uin = $scope.dialogsList.getFirstId();
                
                if (uin) {
                    $scope.dialogsList.select(uin);
                } else {
                    $rootScope.SetPrivate(0);
                    $rootScope.$broadcast('fillChatFrame', ['Elisa']);
                }

                $rootScope.$broadcast('selectTool', [mcConst.dataModels.CommonContacts]);
            }
        }
    }

    function selectDialogByType(dialog) {
        if (dialog.indexOf('UIN') === 0 && $scope.arcDialogsList) {
            $scope.arcDialogsList.expand();

            if ($scope.dialogsList.getItem('d' + dialog)){
                var selected = $scope.dialogsList.getSelectedItem();

                if (selected && selected.id === ('d' + dialog)) {
                    $rootScope.$broadcast('OpenPrivate', [$rootScope.GetChatID()]);
                } else {
                    $scope.dialogsList.select('d' + dialog);
                }
            }
        } else
            
        if (dialog.indexOf('UID') === 0 && $scope.arcChannelsList) {
            $scope.arcChannelsList.expand();
            
            $scope.channelsList.select('d' + dialog);
        } else

        if ($scope.arcToolsList) {
            $scope.arcToolsList.expand();

            $scope.toolsList.select(dialog.split("-")[0] + toolSuffix);
        }
    }

    function selectNextTab(id) {
        if (tabList.length){
            $scope.channelsList.unselectAll();
            $scope.dialogsList. unselectAll();
            $scope.toolsList.   unselectAll();

            if (tabList[id].isConf) {
                $scope.channelsList.select(tabList[id].id);
            } else

            if (tabList[id].isPrivate){
                $scope.dialogsList.select(tabList[id].id);
            }

            $scope.clickOnDialogItem(tabList[id].id);
        }
    }

    function nextDialog(revert) {
        if (!tabTimer){
            var tab = revert ? (tabList.length ? tabList.length - 1 : 0) : 0;

            if (tabSelect) {
                switch ($rootScope.GetChatType()) {
                    case $rootScope.chatAliases.UIN:
                    case $rootScope.chatAliases.UID:
                        tab = mcService.findItemInArrayOfObj(tabList, tabSelect, "id");

                        if (revert) {
                            tab = tab > 0 ? tab - 1 : tabList.length - 1;
                        } else {
                            tab = tab < tabList.length - 1 ? tab + 1 : 0;
                        }
                    break;

                    case $rootScope.chatAliases.BBS:
                    case $rootScope.chatAliases.Kanban:
                        tab = revert ? (tabList.length ? tabList.length - 1 : 0) : 0;
                    break;
                }
            }

            selectNextTab(tab);

            tabTimer = setTimeout(function () {
                tabTimer = null;
            }, 70);
        }
    }

    function updateChUserCount(uid, count) {
        var conf = 'dUID-' + uid;

        if (confList.hasOwnProperty(conf)){
            var item = $scope.channelsList.getItem(conf);

            item.userCount = count;
            confList[conf].userCount = count;

            $scope.channelsList.updateItem(conf, item);
        }
    }

    //===================================================

    $scope.registerHotKeys = function () {
        $rootScope.hotKeyDispatcher.addPreset($scope.Name, [{
            key   : mcConst.keyCodes.tab,
            ctrlKey: true,
            func  : function () { nextDialog(); }
        }, {
            key   : mcConst.keyCodes.pagedown,
            ctrlKey: true,
            func  : function () { nextDialog(); }
        }, {
            key   : mcConst.keyCodes.pageup,
            ctrlKey: true,
            func  : function () { nextDialog(true); }
        }, {
            key   : mcConst.keyCodes.tab,
            shiftKey: true,
            func  : function () { nextDialog(true); }
        }], document);
    };

    $scope.removeHotKeys = function () {
        $rootScope.hotKeyDispatcher.removePreset($scope.Name);
    };

    $scope.saveOptions = function () {
        if (!saveTimerOption) {
            saveTimerOption = setTimeout(function () {
                $rootScope.Storage.dialogs.save(null, null, mcConst.storageOpts.DIALOGOPT, JSON.stringify({
                    sizes: $scope.sizes
                }), function () {
                    saveTimerOption = null;
                });

                fillTabList();
            }, 300);
        }
    };

    $scope.setHeightConf = function (height) {
        $scope.arcChannelsList.define("height", height);
        $scope.arcChannelsList.resize();

        $scope._accor2.resizeChildren();
    };

    $scope.setHeightTool = function (height) {
        $scope._accor1.define("height", height);
        $scope._accor1.resize();

        $scope._accor1.resizeChildren();
    };

    $scope.beforeSelect = function(){
        prevID = $scope.dialogsList.getSelectedId();
    };

    $scope.openChannelsManager = function () {
        $rootScope.$broadcast('show' + mcConst.dataModels.ConfManager, []);
    };

    $scope.selectTools = function(id){
        $scope.dialogsList.unselectAll();
        $scope.channelsList.unselectAll();

        switch (id){
            case mcConst.dataModels.Forum + toolSuffix:

            break;

            case mcConst.dataModels.BBS + toolSuffix:
                $rootScope.SetBBS();
            break;

            case mcConst.dataModels.Kanban + toolSuffix:
                $rootScope.SetKanban();
            break;
        }

        tabSelect = null;

        $rootScope.$broadcast("changeCenterView", [id.replace(toolSuffix, '')]);
        $rootScope.$broadcast('selectTool');
    };

    $scope.clickOnDialogItem = function (id) {
        var item   = $scope.dialogsList.getItem(id);

        if (item/* && idRemove === -1*/) {
            $rootScope.$broadcast("changeCenterView", [mcConst.dataModels.ChatFrame, id]);
        }
    };

    $scope.openPrivateDialog = function(id){
        var item   = $scope.dialogsList.getItem(id);

        if (item/* && idRemove === -1*/){
            var _badge = privatList[id] ;

            if (_badge.badge !== 0) {
                _badge.badge = 0;

                Badges.update(id, _badge.badge);
            }

            $scope.channelsList.unselectAll();
            $scope.toolsList.unselectAll();

            tabSelect = id;

            $rootScope.$broadcast('OpenPrivate', [item.UIN]);
        }
    };

    $scope.openChannelDialog = function(id){
        var item = $scope.channelsList.getItem(id);

        var _badge = confList[id];

        if (_badge.badge !== 0) {
            _badge.badge = 0;

            Badges.update(id, _badge.badge);
        }

        tabSelect = id;

        $scope.dialogsList.unselectAll();
        $scope.toolsList.unselectAll();

        $rootScope.$broadcast('OpenConf', [item.UID]);
    };

    $scope.updateCounter = function(msg, dontInc){
        var UID  = msg.UID;
        var UIN  =(msg.UINFrom || msg.UIN).toString();
        var nick = msg.Nick || msg.DisplayName;

        if (mcConst.UserInfo.UIN != UIN){
            var itemID = UID !== undefined ? 'dUID-' + UID : 'dUIN-' + UIN;
            var list   = UID !== undefined ? $scope.channelsList : $scope.dialogsList ;

            if (UIN && !msg.UID){
                // "IDMsgLast"   : 4567,                  // ID последнего отправленного сообщения
                // "IDMsgGot"    : 4560,                  // ID последнего полученного сообщения
                // "IDMsgRead"   : 4560,                  // ID последнего прочитанного сообщения
                addPrivate(UIN, nick, msg.State, msg.hasOwnProperty("IDMsgLast") ? msg.IDMsgLast - msg.IDMsgRead : 0);
            }

            list.moveTop(itemID);

            privateSequence = getPrivateSequence();

            if (list.getSelectedId() !== itemID){
                var dialogItem = privatList[itemID] || confList[itemID];

                if (dialogItem){
                    if (!dontInc) dialogItem.badge ++;

                    Badges.update(itemID, dialogItem.badge);

                    fillTabList();
                }
            }
        }
    };

    $scope.show = function(){
        mcService.updateStatuses(userStatuses, $scope.data);

        contacts = initDialogs($scope);

        $scope.registerHotKeys();
    };

    $scope.removePrivateDialog = function (id) {
        if (id && ($rootScope.isWebClient || mcConst.ClientSettings.GeneralDoubleClickPagesClose)) {
            // idRemove = id;
            
            $rootScope.$broadcast('removeDialogFromList', [id.split('-')[1]]);
        }
    };

    //==================================================

    var _msg = _messages_.dialogsCtrl = {
        allUsersOnlineStatusesChanged   : 'allUsersOnlineStatusesChanged',
        getUserSequence                 : 'getUserSequence',
        isConfOpen                      : 'isConfOpen',
        addNewConfToDialogs             : 'addNewConfToDialogs',
        removePrivateFromDialogs        : 'removePrivateFromDialogs',
        removeConfFromDialogs           : 'removeConfFromDialogs',
        addNewPrivateDialog             : 'addNewPrivateDialog',
        selectDialog                    : 'selectDialog',
        updateCounter                   : 'updateCounter',
        receiveBBS                      : 'receiveBBS',
        updateChUserCount               : 'updateChUserCount',
        on_mainWindowFocused            : 'on_mainWindowFocused',
        clearDialogsList                : 'clearDialogsList'
    };

    $scope.$on(_msg.allUsersOnlineStatusesChanged, function(e, args){
        userStatuses = args[0];

        mcService.updateStatuses(userStatuses, $scope.data);

        if ($scope.dialogsList){
            $scope.dialogsList.refresh();
        }
    });

    $scope.$on(_msg.on_mainWindowFocused, function(){
        if (mcConst.LoggedIn){
            Badges.checkBadges(true);

            selectDialogByType($rootScope.GetChatTypeID());
        }
    });

    $scope.$on(_msg.getUserSequence, function(e, args){
        var callback = args[0];

        if (callback) {
            callback(privateSequence);
        }
    });

    $scope.$on(_msg.isConfOpen, function(e, args){
        var uid = args[0];
        var callback = args[1];

        if (callback) callback(confList.hasOwnProperty(uid));
    });

    $scope.$on(_msg.addNewConfToDialogs, function(e, args){
        addConf.apply(null, args);
    });

    $scope.$on(_msg.clearDialogsList, function(){
        privatList     = {};
        privateSequence= [];
        prevID         = 0;
        userStatuses   = null;
        tabList        = [];

        $scope.dialogsList.clearAll();

        $rootScope.$broadcast(_messages_.dialogsList.clearPrivatesOnReconnect);
    });

    $scope.$on(_msg.removePrivateFromDialogs, function(e, args){
        removePrivate.apply(null, args);
    });

    $scope.$on(_msg.removeConfFromDialogs, function(e, args){
        removeConf.apply(null, args);
    });

    $scope.$on(_msg.addNewPrivateDialog, function(e, args){
        addPrivate.apply(null, args);
    });

    $scope.$on(_msg.receiveBBS, function(){
        if (!$rootScope.isWebClient && mcConst.ClientSettings.EventsPopupOnNewBBS){
            $rootScope.$broadcast(window._messages_.clientData.sendCMDToElectron, [
                mcConst._CMD_.ce_show_on_top
            ]);
        }

        mcPlaySound.Play(mcPlaySound.Sounds.BBS);

        setTimeout(function () {
            $scope.arcToolsList.expand();
            $scope.toolsList.select(mcConst.dataModels.BBS + toolSuffix);
            
            $rootScope.$broadcast(window._messages_.BBS.refreshBBS, [mcConst.ClientSettings.EventsTrayBBSMsg]);
        }, 10);
    });

    $scope.$on(_msg.selectDialog, function(e, args){
        selectDialogByType.apply(null, args);
    });

    $scope.$on(_msg.updateCounter, function(e, args){
        $scope.updateCounter.apply(null, args);
    });

    $scope.$on(_msg.updateChUserCount, function(e, args){
        updateChUserCount.apply(null, args);
    });

    $scope.$on('hide' + $scope.Name, function(){
        contacts.hide();

        $scope.removeHotKeys();
    });

    $scope.$on('show' + $scope.Name, function(e, args){
        $scope.container = args[0];

        $scope.wndSize = $rootScope.wndSize;

        $scope.show();

        $rootScope.Storage.dialogs.load(null, null, mcConst.storageOpts.DIALOGOPT, function (data) {
            var info = mcService.StringToObj(data);

            if (mcService.isObject(info)) {
                $scope.sizes = info.sizes;

                $scope.setHeightConf($scope.sizes.conf);
                $scope.setHeightTool($scope.sizes.tool);

                $scope.arcDialogsList [$scope.sizes.open.priv ? "expand" : "collapse"]();
                $scope.arcToolsList   [$scope.sizes.open.tool ? "expand" : "collapse"]();
                $scope.arcChannelsList[$scope.sizes.open.conf ? "expand" : "collapse"]();
            }
        });
    });
}
"use strict";

function initMainMenu($scope){
    var __view = $$($scope.Name);

    if (!__view){
        var statuses = [
            { id: "0", value: "<span class='green'>" + mcLang(534) + "</span>" }, // "534":"В сети",
            { id: "1", value: "<span class='red'>" + mcLang(535) + "</span>" }  // "535":"Не беспокоить",
        ];

        var menu = { id: $scope.Name, css: "darkenNavBG", rows: [
            { view: "button", label: mcLang(45), click: $scope.profile, css: "imgBtn icoButton button_transparent", type: "icon", icon: "book"}, // "45" : "Профиль",
            //{ view: "segmented", options: statuses, value: mcConst.UserInfo.Status, css: "whiteBG yellowSelect", on: { onChange: $scope.changeStatus }, autowidth: true },
            //{ view: "button", label: mcLang(15), click: $scope.settings, css: "imgBtn icoButton button_transparent", type: "icon", icon: "gear"}, // "15" :"Настройки",

            { view: "button", label: mcLang(586), click: $scope.logs, css: "imgBtn icoButton button_transparent", hidden: $scope.isWebClient, type: "icon", icon: "file-text-o"}, // "586":"Протоколы",

            { view: "button", label: mcLang(15), click: $scope.settings, css: "imgBtn icoButton button_transparent", hidden: $scope.isWebClient, type: "icon", icon: "cog"}, // "15" :"Настройки",

            {},

            { view: "button", label: mcLang(536), click: $scope.logout, css: "imgBtn icoButton button_transparent", type: "icon", icon: "sign-out"}, // "536":"Сменить пользователя",
            { view: "button", label: mcLang(47), hidden: $scope.isWebClient, click: $scope.quit, css: "imgBtn icoButton button_warning button_transparent", type: "icon", icon: "power-off"} // "47" : "Выйти",
        ]};

        $$($scope.container).addView(menu);

        __view = $$($scope.Name);

        mcService.disableContextMenu(__view);
    } else {
        __view.show();
    }

    return __view;
}"use strict";

function mainMenuController($scope, $rootScope){
    $scope.Name = mcConst.dataModels.MainMenu;

    var variants = {
        PROFILE  : 1,
        SETTINGS : 2,
        LOGS     : 3,
    };

    var view = null;
    var MAIN_MENU = 'MAIN_MENU';
    var currentMenu = 0;

    //===================================================

    $scope.profile = function(){
        $rootScope.$broadcast("changeCenterView", [mcConst.dataModels.UserProfile, mcConst.UserInfo.UIN]);

        currentMenu = variants.PROFILE;
    };

    $scope.logs = function () {
        $rootScope.$broadcast("changeCenterView", [mcConst.dataModels.ViewLogs, mcConst.UserInfo.UIN]);

        currentMenu = variants.LOGS;
    };

    $scope.settings = function () {
        $rootScope.$broadcast("changeCenterView", [mcConst.dataModels.Settings]);

        currentMenu = variants.SETTINGS;
    };

    // ------------

    $scope.registerHotKeys = function () {
        $rootScope.hotKeyDispatcher.addPreset(MAIN_MENU, [{
            key     : mcConst.keyCodes.esc,
            lockPrev: true,
            func    : function () {
                $rootScope.$broadcast('showHideMenu');
            }
        }], document);
    };

    $scope.changeStatus = function (newStatus) {

    };

    $scope.removeHotKeys = function () {
        $rootScope.hotKeyDispatcher.removePreset(MAIN_MENU);
    };

    $scope.logout = function(){
        mcService.ClearSessionSettings(true, true);

        $rootScope.$broadcast('SendCMDToServer' , [
            mcConst.lockInterface,
            mcConst._CMD_.cs_quit,
            mcConst.SessionID
        ]);

        setTimeout(function(){
            $rootScope.$broadcast('StopPingTimer');

            location.search = "";
            location.reload();
        }, 200);
    };

    $scope.quit = function(){
        $rootScope.$broadcast("quitFromProgram");
    };

    $scope.show = function(){
        $scope.isWebClient =  $rootScope.isWebClient;

        view = initMainMenu($scope);

        $scope.registerHotKeys();
    };

    //==================================================

    var _msg = _messages_.mainMenu = {
        logoutMenu  : 'logoutMenu'
    };

    $scope.$on(_msg.logoutMenu, $scope.logout);

    $scope.$on('hide' + $scope.Name, function(){
        $scope.removeHotKeys();

        view.hide();

        switch (currentMenu){
            case variants.PROFILE:
            break;

            case variants.LOGS: case variants.SETTINGS:
                $rootScope.$broadcast("changeCenterView", [mcConst.dataModels.ChatFrame, 'd' + $rootScope.GetChatTypeID()]);
            break;
        }
    });

    $scope.$on('show' + $scope.Name, function(e, args){
        $scope.container = args[0];

        $scope.wndSize = $rootScope.wndSize;

        $scope.show();
    });
}
"use strict";

function initConfManagerView($scope){
    var view = $$($scope.Name);

    if (!view){
        var filter = new mcService.FilterFiled({
            listName     : 'existingConfs' + $scope.Name,
            placeholder  : mcLang(35), // "35" : "Название конференции",
            css          : "noBorder",
            noClearBtn   : true,
            filterParams : ['Name', 'Topic'],
            id           : "conManagerFilterField",
            OnEnterText  : function(text){
                text === '' ? $scope.createNewConfBtn.disable() : $scope.createNewConfBtn.enable();

                $scope.confName = text;
            }
        });

        view = webix.ui({
            view    : "window",
            modal   : true,
            position: 'center',
            id      : $scope.Name,
            width   : isMobile ? $scope.wndSize.width : 400,
            height  : $scope.wndSize.height,
            head    : { cols:[
                { width: 42},
                { view: "label",  label:'<div class="byCenter toUpper">' + mcService.Lang(25) + "</div>"}, // "25" : "Добавить конференцию",
                { view: "button", type: 'icon', width: 42, icon: 'times', css: "button_transparent", click: function () {
                    view.hide();
                }}
            ]},
            body    : { rows: [
                filter,

                { view : 'list', id: 'existingConfs' + $scope.Name, maxHeight: 300, scroll: true, data: [],
                    template  : function(obj) {
                        return "<b>" + mcService.insertIco(obj.Secured ? "fa-key" : "fa-users", 12) + obj.Name + "</b>" +
                               (obj.Topic == "" ? "" : " (<i>" + obj.Topic + "</i>)");
                    },
                    on: { onItemClick: function(id){
                        $scope.selectedConf = id;

                        $scope.openConf(id, null, $scope.existingConfs.getItem(id).Secured);
                    }}
                },

                { view: "button", id: 'createNewConfBtn', value: mcLang(5), disabled: true, click: $scope.openOrCreate } // "5" : "Войти",
            ]},
            on: {
                onShow: $scope.registerHotKeys,
                onDestruct: $scope.hideWnd
            }
        });

        $scope.existingConfs    = $$("existingConfs" + $scope.Name);
        $scope.createNewConfBtn = $$("createNewConfBtn");
        $scope.confFilter       = $$(filter.EDITOR);
    } else {
        $scope.createNewConfBtn.disable();
        $scope.existingConfs.clearAll();
    }

    return view;
}/**
 * Created by Gifer on 11.08.2016.
 */

function confManagerController($scope, $rootScope) {
    $scope.Name = mcConst.dataModels.ConfManager;

    var viewConfManager  = null;
    var ZERO_CONF_RIGHTS = '0011101100';
    var confList = {};

    var PRESET_ENTER_PWD = 'preset_enter_pwd';

    //========================================================

    $scope.registerHotKeys = function () {
        $rootScope.hotKeyDispatcher.addPreset($scope.Name, [{
            key   : mcConst.keyCodes.esc,
            func  : function () {
                if ($scope.confFilter.getValue() === ""){
                    $scope.hideWnd();
                } else {
                    $scope.confFilter.$setValue("");
                }
            }
        }, {
            key  : mcConst.keyCodes.enter,
            func : function () {
                $scope.openOrCreate();
                
                $scope.confFilter.$setValue("");
            }
        }], document, true);
    };

    $scope.removeHotKeys = function () {
        $rootScope.hotKeyDispatcher.removePreset($scope.Name);
    };

    $scope.createNewConf = function(name){
        $rootScope.$broadcast('SendCMDToServer', [
            mcConst.lockInterface,
            mcConst._CMD_.cs_create_txt_channel,
            mcConst.SessionID,
            name,
            '',
            '',
            ZERO_CONF_RIGHTS,

            function (info) {
                $scope.openConf(info.UID, null, info.Secured);
            }
        ]);
    };

    $scope.openOrCreate = function(){
        if (!$scope.confName){
            $scope.confName = $scope.confFilter.getValue();
        }

        var id = mcService.findItemInArrayOfObj(confList, $scope.confName, 'Name');

        if (id === -1){
            $scope.createNewConf($scope.confName);
        } else {
            $scope.openConf(confList[id].id, null, confList[id].Secured);
        }

        $scope.hideWnd();
    };

    $scope.passEnter = function () {
        var pwdWindow = $$("confPassword" + $scope.Name);

        if (pwdWindow){
            pwdWindow.destructor();
        }

        pwdWindow = webix.ui({
            id      : "confPassword" + $scope.Name,
            view    : "window",
            modal   : true,
            position: 'center',
            head    : false,
            body    : { rows: [
                { view: "text", type: "password", placeholder: mcLang(2)}, // "2"  : "Пароль",
                { cols: [
                    { view: "button", value: mcLang(5), click: function() { // "5"  : "Войти",
                        $scope.openConf($scope.selectedConf, pwdWindow.getChildViews()[0].getChildViews()[0].getValue());

                        pwdWindow.closeWnd();
                    }},
                    { view: "button", value: mcLang(33), click: function(){ // "33" : "Отмена",
                        pwdWindow.closeWnd();
                    }}
                ]}
            ]},
            on: {
                onShow: function () {
                    var edit = pwdWindow.getChildViews()[0].getChildViews()[0];

                    $rootScope.hotKeyDispatcher.addPreset(PRESET_ENTER_PWD, [{
                        key: mcConst.keyCodes.enter,
                        func: function () {
                            var id   = mcService.findItemInArrayOfObj(confList, $scope.confName, 'Name');
                            var UID  = -1;
                            var password = edit.getValue();

                            if (id) {
                                UID = $scope.selectedConf || confList[id].id;
                            }

                            if (id && password){
                                $scope.openConf(UID, password);

                                pwdWindow.closeWnd();
                            }
                        }
                    }, {
                        key: mcConst.keyCodes.esc,
                        func: function () {
                            pwdWindow.closeWnd();
                        }
                    }], document, true);

                    edit.focus();
                },
                onDestruct: function () {
                    $rootScope.hotKeyDispatcher.removePreset(PRESET_ENTER_PWD);
                }
            }
        });

        pwdWindow.closeWnd = function () {
            pwdWindow.hide();
            pwdWindow.getChildViews()[0].getChildViews()[0].setValue('');
            pwdWindow.destructor();
        };

        pwdWindow.show();

        return pwdWindow;
    };

    $scope.openConf = function(uid, pass, secure){
        var UID = 'dUID-' + uid;

        $rootScope.$broadcast("changeCenterView", [mcConst.dataModels.ChatFrame, UID]);
        
        if (secure && !confList[UID]) {
            $rootScope.$broadcast("isConfOpen", [UID, function (here) {
                if (here){
                    $scope.hideWnd();

                    $rootScope.$broadcast('OpenConf', [uid]);
                } else {
                    $scope.passEnter();
                }
            }]);
        } else {
            $scope.hideWnd();

            $rootScope.$broadcast('OpenConf', [uid, pass]);
        }
    };

    $scope.getData = function(){
        $rootScope.$broadcast('SendCMDToServer', [
            mcConst._CMD_.cs_get_channels_list,
            mcConst.SessionID,
            function(data){
                confList = mcService.convertObjToArray(data, 'id');

                $scope.existingConfs.parse(confList);
            }
        ]);
    };

    $scope.hideWnd = function () {
        $scope.removeHotKeys();
        
        viewConfManager.hide();
    };

    $scope.show = function(){
        viewConfManager = initConfManagerView($scope);

        viewConfManager.show();

        setTimeout(function () {
            $scope.confFilter.focus();
        }, 800);
    };

    // ====================================================

    $scope.$on('hide' + $scope.Name, $scope.hideWnd);

    $scope.$on('show' + $scope.Name, function(){
        $scope.wndSize = $rootScope.wndSize;

        $scope.show();
        $scope.getData();
    });
}"use strict";

function initChatFrame($scope){
    var chatFrame = {
        id   : $scope.Name,
        rows : [
            // -- Header --
            { view: "button", type: "icon", icon: "chevron-down", id: "displayName" + $scope.Name, label: "Elisa", css: "imgBtn frameTopBtnCenter",
                click: $scope.titleMenu},

            // -- Search --
            { id: "searchWrapper" + $scope.Name, hidden: true, padding: 0, css: "noBorderAll borderTopBottom", height: 30,cols: [
                { id: "searchChatText" + $scope.Name, view: "text", css: "noBGColorAll", borderless: true, placeholder: mcService.Lang(579) }, // "579":"Найти текст в чате...",

                { id: "btnCloseSearchText" + $scope.Name, view: "button", type: "icon", icon: "close", width: 35, css: "noBG iconNoPadding byCenter",
                    click: $scope.hideFindChatText}
            ]},

            // -- DownloadUpload --
            $scope.duViews.progressWrapper,
            $scope.duViews.downloadFilesQuestion,

            // -- MediaCall --
            { id: "videoFrameWrapper", hidden: true, css: "relative noBGColor byCenter", borderless: true, gravity: 2, minHeight: 90,
                template: '<div id="' + mcConst.videoContainer + '" style="height: 100%;"></div>'},
            
            { view: "resizer", id: "videoResizer", hidden: true},

            // -- Main Chat --
            { id: "chatTextOutput" + $scope.Name, view: "template", minHeight: 100, borderless: true, css: "myScroll noBGColorAll selectable " + (!isMobile ? "scrollMenu" : ""),
                scroll: false,
                template: '<div id="loadMoreHistory" class="right loadHistory hidden"><a href="#" class="selected">' + mcLang(577) + '</a></div>' + // "577":"Загузить еще сообщения",
                          '<div id="UIN-0" class="framePaddingР30x10"></div>'
            },

            { view: "resizer", id: "inputResizer" + $scope.Name, css: "noBGColorAll noBorder"},

            // -- Input Text --
            { id: "inputWrapper", height: 57, minHeight: 57, hidden: true, cols: [
                { id: "clipPopupButton", view: "button", type: "icon", icon: "paperclip", css : "ico30 borderTop",  hidden: false, width: 56,
                    on: { onItemClick: function () {
                        var btn = this.getNode();

                        setTimeout(function () {
                            $scope.clipPopupWindow.show(btn, {pos: 'top', x: 0, y: -10});
                        }, 100);
                    }
                }},

                { id: "enterChatText"  + $scope.Name, view: "textarea", css: "noBGColorAll borderTop", borderless: true, placeholder: mcService.Lang(27), // "27" : "Введите ваше сообщение здесь",
                    on: { onKeyPress: $scope.typingNotify }},

                { id: "btnSendText", view: "button", type: "icon", icon: "send", width: 35, css: "noBG noBorderAll iconNoPadding byCenter borderTop", click: function () {
                    $scope.sendText();

                    setTimeout(function () {
                        $scope.enterChatText.focus();
                    }, 50);
                }}
            ], on: { onViewResize: $scope.saveTextInputSize}}
        ]
    };

    $scope.clipPopupWindow = webix.ui({
        view : "context",
        id   : "clipPopup",
        head : false,
        css  : "noUpperCase",
        padding: 0,

        body : { width: 200, rows: [
            { view: "button", type: "icon", icon: "file-image-o", css: "icoButton",
                label: mcService.Lang(53), click: $scope.popupInsertImage }, // "53" : "изображение",
            { view: "button", type: "icon", icon: "files-o", css: "icoButton",
                label: mcService.Lang(568), click: $scope.popupInsertFile },  // "568":"Файл",
            // { view:"menu",
            //     subMenuPos:"right",
            //     layout:"y",
            //     height: 40,
            //     data:[
            //         { value: mcService.Lang(619), submenu: "quickMsgTempSubMenu", icon: "list", css: "icoButton"} // "619":"Фраза",
            //     ]
            // }
            // { view: "button", type: "icon", icon: "list", css: "icoButton",
            //     label: mcService.Lang(619), click: $scope.popupInsertPhrase }
        ]}
    });

    // $scope.visualMsgTempList = webix.ui({
    //     view:"submenu", id:"quickMsgTempSubMenu", data:[
    //         { id:"1.1", value:"English"},
    //         { id:"1.3", value:"German"}
    //     ]
    // });

    $$($scope.container).addView(chatFrame);

    // -- Header --
    $scope.displayName       = $$("displayName"    + $scope.Name);
    // -- Main Chat --
    $scope.chatTextOutputW   = $$("chatTextOutput" + $scope.Name);
    $scope.chatTextOutput    = $$("chatTextOutput" + $scope.Name).$view.lastChild;
    // -- Input Text --
    $scope.inputResizer      = $$("inputResizer"   + $scope.Name);
    $scope.inputWrapper      = $$("inputWrapper");
    $scope.enterChatText     = $$("enterChatText"  + $scope.Name);
    $scope.btnSendText       = $$("btnSendText");
    $scope.clipPopupButton   = $$("clipPopupButton");
    // -- Search --
    $scope.searchWrapper     = $$("searchWrapper"  + $scope.Name);
    $scope.searchChatText    = $$("searchChatText" + $scope.Name);
    // -- MediaCall --
    $scope.videoResizer        = $$('videoResizer');
    $scope.videoFrameWrapper   = $$('videoFrameWrapper');

    $scope.chatTextOutputW.getNode().onmousedown = $scope.scrollControl;
    
    $scope.loadMoreHistory          = document.getElementById("loadMoreHistory");
    $scope.loadMoreHistory.onclick  = $scope.addHistoryMessages;

    $scope.chatTextOutput.style.position = 'relative';

    // -- DownloadUpload --
    $scope.initDU();

    if (isMobile) {
        $scope.chatTextOutput.style.height = 'initial';
        $scope.chatTextOutputW.$view.id = 'forMobile';

        new TouchScroll().init({
            id: 'forMobile',
            draggable: true,
            wait: false
        });
    }

    return $$($scope.Name);
}"use strict";

function chatFrameController($scope, $rootScope, mcPlaySound){
    $scope.Name = mcConst.dataModels.ChatFrame;
    
    $scope.displayName        = null;
    $scope.chatTextOutput     = null;
    $scope.enterChatText      = null;
    $scope.clipPopupButton    = null;
    $scope.clipPopupLoaderImg = null;
    $scope.videoFrameWrapper  = null;

    // ----------------------------------

    var pressNotifyCount  = 0;
    var prevFrame         = 'UIN-0';
    var currentFrame      = null;
    var view              = null;
    var titleValue        = [];
    var prevHeight        = 0;
    var inputSize         = 57;
    var scrollDownTimer   = null;
    var myMessages        = {
        UIN        : -1,
        IDMyMsgGot : 0,
        IDMyMsgRead: 0
    };
    var noScrollDownOnSync= false;
    var msgTemplateList   = {};

    // ----------------------------------

    var downloadUploadManager = null;
    var framesList            = new McFramesList();

    // ----------------------------------
    
    var userMenu = function() {
        return [{
            view: "button",
            value: mcService.Lang(41), // "41" : "Добавить в игнор",
            click: function(){
                this.getTopParentView().hide();

                webix.confirm({
                    title : mcService.Lang(42), // "42" : "Игнорировать приватные сообщения от:",
                    ok    : mcService.Lang(43), // "43" : "Да",
                    cancel: mcService.Lang(44), // "44" : "Нет",
                    type  :"confirm-error",
                    text  : titleValue[0],
                    width : 310,
                    callback:function(result){ //setting callback
                        if (result){
                            var uin = $rootScope.GetChatID();

                            $rootScope.$broadcast('SendCMDToServer', [
                                mcConst._CMD_.cs_set_custom_ignore,
                                mcConst.SessionID,
                                uin, // current UIN
                                mcConst.ignores.private
                            ]);

                            $rootScope.$broadcast('getIgnoreList', []);
                            $rootScope.$broadcast('addIgnoreInPrivateInfo', [uin]);
                        }
                    }
                });
            }
        }, {
            view: "button",
            value: mcService.Lang(51), // "51" : "Удалить из игноров",
            click: function(){
                var uin = $rootScope.GetChatID();

                this.getTopParentView().hide();

                $rootScope.$broadcast('SendCMDToServer', [
                    mcConst._CMD_.cs_del_custom_ignore,
                    mcConst.SessionID,
                    uin,
                    mcConst.ignores.private
                ]);

                $rootScope.$broadcast('getIgnoreList', []);
                $rootScope.$broadcast('removeIgnoreInPrivateInfo', [uin]);

                webix.message(mcService.Lang(52, titleValue[0])); //"52" : "С пользователя %s снят игнор!",
            }
        }];
    };
    var confMenu = function() {
        return [{
            view : "button",
            value: mcService.Lang(28), // "28" : "Выйти из конференции",
            click: function(){
                this.getTopParentView().hide();

                $rootScope.$broadcast('leaveConf', [getCurrentID()]);
            }
        }];
    };

    // =====================================

    window._userActions.deleteMessage = function(){
        var idx = this.getAttribute('Idx');
        var uinUID = getCurrentID();
        var elm   = "";
        var param = "";

        if (uinUID && getCurrentType() === $rootScope.chatAliases.UID){
            elm   = this.parentElement.getElementsByClassName("messageText")[0];
            param = mcService.copy(elm.innerText, 0, 20) + (elm.innerText.length > 20 ? "..." : "");

            if (!param){
                param = "<div style='margin-left: 20px'>" + elm.innerHTML + "</div>";
            }

            webix.confirm({
                type  : "confirm-warning",
                text  : mcLang(587, param),  // "587":"Удалить сообщение",
                ok    : mcService.Lang(519), // "519":"Удалить",
                cancel: mcService.Lang(33),  // "33" :"Отмена",

                callback:function(yes){
                    if (yes){
                        $rootScope.SendCMDToServer([
                            mcConst._CMD_.cs_moder_delete_conf_message,
                            mcConst.SessionID,

                            uinUID,
                            idx
                        ]);
                    }
                }
            });
        } else
        if (uinUID && getCurrentType() === $rootScope.chatAliases.UIN) {
            elm   = this.parentElement.getElementsByClassName("messageText")[0];
            param = mcService.copy(elm.innerText, 0, 20) + (elm.innerText.length > 20 ? "..." : "");

            if (!param){
                param = "<div style='margin-left: 20px'>" + elm.innerHTML + "</div>";
            }

            webix.confirm({
                type  : "confirm-warning",
                text  : mcLang(587, param),  // "587":"Удалить сообщение",
                ok    : mcService.Lang(519), // "519": "Удалить",
                cancel: mcService.Lang(33),  // "33": "Отмена",

                callback:function(yes){
                    if (yes){
                        $rootScope.SendCMDToServer([
                            mcConst._CMD_.cs_delete_private_message,
                            mcConst.SessionID,

                            uinUID,
                            idx
                        ]);
                    }
                }
            });
        }
    };

    window._userActions.downloadFile = function(){
        var link = this.parentElement.childNodes[1];
        var url  = link.href;
        var fileInfo = {
            uin        : link.getAttribute("uin"),
            displayName: link.getAttribute("nick"),
            filePath   : link.getAttribute("filepath"),
            fileDT     : link.getAttribute("filedt"),
            hash       : link.getAttribute("hash")
        };

        if ($rootScope.isWebClient){
            window.open(url);
        } else {
            downloadUploadManager.downloadUrl(url, fileInfo);
        }
    };

    window._userActions.openOrDownloadFile = function(e){
        var url = this.href;
        var fileInfo = {
            uin        : this.getAttribute("uin"),
            displayName: this.getAttribute("nick"),
            filePath   : this.getAttribute("filepath"),
            fileDT     : this.getAttribute("filedt"),
            hash       : this.getAttribute("hash")
        };
        
        if ($rootScope.isWebClient){
            // window.open(url);
        } else {
            e.preventDefault();

            downloadUploadManager.openDownloadUrl(url, fileInfo);
        }

        return false;
    };

    window._userActions.openInFolder = function(){
        var hash = this.parentElement.childNodes[1].getAttribute('hash');
        var uin  = this.parentElement.childNodes[1].getAttribute('uin');

        downloadUploadManager.openInFolder(hash, uin);
    };

    window._userActions.openFolder = function(){
        var path = this.getAttribute('filepath');

        downloadUploadManager.openFolder(path);
    };

    window._userActions.replyToUser = function(){
        var uin = this.getAttribute('uin');

        if (uin != mcConst.UserInfo.UIN){
            var txt = this.innerHTML;

            $scope.enterChatText.setValue($scope.enterChatText.getValue() + " @" + mcService.copy(txt, 0, txt.indexOf('<span')).replace(/\:$/, '') + " ");

            focusToEnterChat();
        }
    };

    window._userActions.userMenu = function(){
        var uin = this.getAttribute('uin');

        if (uin != mcConst.UserInfo.UIN){

            focusToEnterChat();
        }
    };

    window._userActions.hideStatus = function () {
        mcService.hideView(this.querySelector(".statusItem"));
    };

    window._userActions.showStatus = function () {
        mcService.showView(this.querySelector(".statusItem"));
    };

    // =====================================

    function showNotify(notI, text, nick, isConf, id){
        text = text || "";
        
        var textForNotify = text.slice(0, 100) + ((text.length > 100) ? '...' : "" );
        var itemID = (isConf ? 'UID-' : 'UIN-') + id;

        if (notI){
            if (($rootScope.isWebClient || mcConst.ClientSettings.SoundsSndChat) && isConf){
                mcPlaySound.PlaySound(mcPlaySound.Sounds.ConfMsg, true);
            } else
            if (($rootScope.isWebClient || mcConst.ClientSettings.SoundsSndPrivate) && !isConf){
                mcPlaySound.PlaySound(mcPlaySound.Sounds.Private, true);
            }

            if ($rootScope.isWebClient){
                if ($rootScope.GetChatTypeID() !== itemID){
                    mcService.CreateNotification({
                        title : nick.slice(0, 30) + ((nick.length > 30) ? '..' : "" ) + ":",
                        body  : textForNotify,
                        timeOut : 5000,
                        click : function onClickOnNotify(){
                            if (isConf){
                                $rootScope.$broadcast('OpenConf', [id]);
                            } else {
                                $rootScope.$broadcast('OpenPrivate', [id]);
                            }
                        }
                    });
                }
            } else

            if ((isConf && ($rootScope.isWebClient || mcConst.ClientSettings.EventsTrayChMsg)) || (!isConf && ($rootScope.isWebClient || mcConst.ClientSettings.EventsTrayPvMsg))){
                $rootScope.$broadcast('sendCMDToElectron', [
                    mcConst._CMD_.ce_show_notify,

                    nick.slice(0, 30) + ((nick.length > 30) ? '..' : "" ) + ":",
                    textForNotify,
                    itemID
                ]);
            }
        }
    }

    function parseLink(source) {
        return source ? mcService.ReplaceURLs(source, { callback: function(text, link){
                var res = "";

                if (/png|jpg|jpeg$/.test(link)){
                    res = '<br/><img class="thumbImage" src="' + link + '">';
                }

                return link ? '<a href="' + link + '" title="' + link + '" target="_blank">' + (res || text) + '</a>' : text;
            }}) : ""
    }

    function getCurrentID() {
        return (currentFrame.id || currentFrame).split('-')[1];
    }

    function getCurrentType() {
        return (currentFrame.id || currentFrame).split('-')[0];
    }

    // ======= DRAW MESSAGES =======================

    function removeMSG(msg) {
        setTimeout(function () {
            var Idx    = msg.Msg;
            var isConf = !!msg.UID;

            var message = document.getElementById(isConf ? "conf-" + msg.UID + "-" + Idx : "priv-" + Idx);

            if (message){
                message.innerHTML = "";
            }
        }, 100);
    }

    function addMSG (msg, frame){
        var target= framesList.get(frame);
        var div   = document.createElement('div');
        var text  = !msg.MsgType ? msg.Msg.split(mcConst.newLine) : msg.Msg.split(mcConst.CRLF);
        var notI  = (msg.UINFrom || msg.UIN) != mcConst.UserInfo.UIN;
        var uin   = msg.UINFrom || msg.UIN;
        var nick  = msg.Nick;
        var time  = (msg.dt) ? msg.dt.split('.') : "";
        var date  = '';
        var info  = msg.Msg.split(mcConst.CRLF);
        var hash  = info[0];
        var isConf= msg.UID !== undefined;
        var notifyText;
        var prevItem = msg.History ? target.firstChild : target.lastChild;
        var same     = prevItem ? prevItem.getAttribute('uin') == uin : false;
        var userName = "";
        var hasAlign = false;
        var loadThmb = false;

        if (time === '') {
            time = mcService.formatDate(new Date(), 'hh:nn:ss');
            date = mcService.formatDate(new Date(), 'dd.mm.yyyy');
        } else {
            date = (time.length >= 6) ? time[0] + "." + time[1] + "." + time[2] : time; // dt[0] + "." + dt[1] + "." + dt[2] + "&nbsp;" +
            time = (time.length >= 6) ? time[3] + ":" + time[4] + ":" + time[5] : time; // dt[0] + "." + dt[1] + "." + dt[2] + "&nbsp;" +
        }

        div.setAttribute('uin', uin);
        div.setAttribute('Idx', msg.Idx);
        div.setAttribute('postDate', date);
        div.setAttribute('id', isConf ? "conf-" + msg.UID + "-" + msg.Idx : "priv-" + msg.Idx);

        div.style.wordBreak = "break-word";
        div.className       = notI ? "messageUser " : 'messageMy ';
        div.className      += " _messagesFontSize";

        if (!same || msg.History || (!msg.History && target.lastChild && target.lastChild.getAttribute('postDate') !== date)){
            userName = mcService.myReplaceFormated(
                '<div id="__#{id}" class="grayBorderTop">' +
                    '<div class="messageUserName" uin="#{uin}" onclick="_userActions.replyToUser.apply(this)" oncontextmenu="window._userActions.userMenu.apply(this)">' +
                        '#{nick}<span class="messageTime messageTimeHistory">#{date}</span>' +
                    '</div>' +
                '</div>',
                {
                    uin  : uin,
                    id   : msg.Idx,
                    nick : nick,
                    date : ($rootScope.isWebClient || mcConst.ClientSettings.EventsTimeStamp) ? date : ""
                }
            );
        }

        switch (msg.MsgType){
            case mcConst._CMD_.msgType.OLD_SHIT:
            case mcConst._CMD_.msgType.INTEGRATION_API:
            case mcConst._CMD_.msgType.TEXT:
                for (var i = 0; i < text.length; i++){
                    text[i] = text[i].replace(/</ig, "&lt;");
                }

                text.forEach(function (txt, line) {
                    if (!msg.MsgType) {
                        if (txt.indexOf(mcConst.mcPara) === 0){
                            text[line] = txt.replace(mcConst.mcPara, "");
                        } else
                        if (txt.indexOf(mcConst.mcParaCenter) === 0){
                            hasAlign = true;
                            text[line] = "<div class='byCenter messageTextP60'>" + txt.replace(mcConst.mcParaCenter, "") + "</div>";
                        } else
                        if (txt.indexOf(mcConst.mcParaRight) === 0){
                            hasAlign = true;
                            text[line] = "<div class='byRight messageTextP60'>" + txt.replace(mcConst.mcParaRight, "") + "</div>";
                        }
                    }
                });

                text = text.join('<br/>');
                
                text = mcService.replaceMcComponents(text, $rootScope.isWebClient);

                text = mcService.ReplaceURLs(text, { callback: function(text, link){
                    var res = "";

                    if (link && link.indexOf(mcConst.myChatLinkTitle) > 0){ // parse special mychat link
                        link = link.split(mcConst.myChatLinkTitle);

                        res  = link[1];
                        link = link[0];
                    } else

                    // if (link && link.indexOf("local://") === 0) {
                    //     link = link.replace("local://", "");
                    // } else

                    if (/(\.png|\.jpg|\.jpeg)$/.test(link) && link.indexOf(mcService.getLocalHostPath($rootScope.isWebClient)) === 0){
                        res = '<br/><img class="thumbImage" src="' + link + '">';
                    }

                    return link ? '<a href="' + link + '" title="' + link + '" target="_blank">' + (res || text) + '</a>' : text;
                }});

                notifyText = text;
            break;

            case mcConst._CMD_.msgType.IMAGE:
                text = mcService.myReplaceFormated(
                    '<a id="link_#{idx}" href="noimage" target="_blank"><img id="img_#{idx}" src="#{loadImage}" dt="#{dt}" alt=""></a>',
                    {
                        idx      : info[0] + msg.Idx,
                        loadImage: mcConst.imagesPath.loadImage,
                        dt       : info[2]
                    }
                );

                downloadUploadManager.addImageToLoad(hash, msg.Idx);

                loadThmb = true;

                notifyText = mcLang(570); // "570":"Опубликовано изображение",
            break;

            case mcConst._CMD_.msgType.FILE:
                var filePath = info[1];
                var fileDT   = info[2];
                var fileSize = info[3];
                var fileName = mcService.extractFileName(filePath);

                text =  mcService.myReplaceFormated(
                    // icon
                    '<i class="fa fa-file-o" aria-hidden="true"></i>' +

                    // file name
                    '<a id="link_#{hash}#{id}" ' +
                        'hash="#{hash}" ' +
                        'filepath="#{filepath}" ' +
                        'filedt="#{filedt}" ' +
                        'filesize="#{filesize}" ' +
                        'href="#{href}" ' +
                        'nick="#{nick}" ' +
                        'uin="#{uin}" ' +
                        'target="_blank" ' +
                        'onclick="window._userActions.openOrDownloadFile.apply(this, arguments)" ' +
                        'class="font120 fileLink"' +
                    '>#{file}</a>&nbsp;&nbsp;' +

                    // download icon
                    '<i class="fa fa-download finger" aria-hidden="true" title="#{dTitle}" onclick="window._userActions.downloadFile.apply(this)"></i>&nbsp;' +

                    // open folder icon
                    ($rootScope.isWebClient ? '' : '<i class="fa fa-folder-open-o finger" onclick="window._userActions.openInFolder.apply(this, arguments)" title="#{oTitle}" aria-hidden="true"></i>&nbsp;') +
                    
                    // file size
                    '(#{formatedSize})</span>',
                    {
                        id      : msg.Idx,
                        nick    : nick,
                        uin     : uin,
                        hash    : hash,
                        href    : mcService.getLocalHostPath($rootScope.isWebClient) + "/" + mcConst.pathAliases.AliasFiles + "/" + hash + "/" + encodeURI(fileName),
                        file    : fileName,
                        time    : time,
                        filepath: filePath,
                        filedt  : fileDT,
                        filesize: fileSize,
                        dTitle  : mcLang(573), // "573":"Скачать",
                        oTitle  : mcLang(574), // "574":"Показать в папке",
                        formatedSize: mcService.formatFileSize(fileSize)
                    }
                );

                notifyText = mcLang(571, fileName); // "571":"Файл: %s",
            break;
        }

        div.innerHTML = mcService.myReplaceFormated(
            "#{userName}" +
            "<div id='hsMsg-#{Idx}' Idx='#{Idx}' class='showOnHover' uin='#{uin}' postDate='#{postDate}' onmouseover='window._userActions.hideStatus.apply(this)' onmouseout='window._userActions.showStatus.apply(this)' style='#{style}'>" +
                "<span id='#{Idx}-st-#{uin}' class='#{state} statusItem'></span>" +
                ((mcService.checkRights(mcConst._CMD_.RS.QAdmAccessToRemoveConfMessages) && isConf) || (!isConf && mcService.checkRights(mcConst._CMD_.RS.QAllowRemovePrivateMessages))
                    ? "<span class='webix_icon fa-trash-o fAwesome needShow messageTrash #{noTime}' Idx='#{Idx}' onclick='window._userActions.deleteMessage.apply(this)' title='#{delHint}'></span>"
                    : ""
                ) +
                "<span class='messageTime'> #{time} </span>" +
                "<span class='messageText #{w100}'>#{text}</span>" +
            "</div>",
            {
                userName : userName,
                w100     : hasAlign ? "width100" : "messageTextP60",
                uin      : uin,
                Idx      : msg.Idx,
                postDate : date,
                style    : "wordBreak: break-word",
                text     : text,
                time     : $rootScope.isWebClient || mcConst.ClientSettings.EventsTimeStamp ? time : "",
                delHint  : mcLang(519), // "519":"Удалить",
                noTime   : $rootScope.isWebClient || mcConst.ClientSettings.EventsTimeStamp ? "" : "messageTrashNoTime",
                state    : msg.UID ? "" : (notI ? "" : (myMessages.IDMyMsgRead >= msg.Idx ? "messageRead" : (myMessages.IDMyMsgGot >= msg.Idx ? "messageGot" : "messageSend" )))
            }
        );

        if (msg.History && !msg.UpSync){ // !msg.isOffline &&
            if (!same) {
                target.insertBefore(document.createElement('br'), target.firstChild);
            } else 
            if (target.firstChild && target.firstChild.getAttribute('postDate') === date ){
                target.firstChild.removeChild(target.firstChild.firstChild);
            } else {
                target.insertBefore(document.createElement('br'), target.firstChild);
            }

            target.insertBefore(div, target.firstChild);
        } else {
            if (!same) {
                target.appendChild(document.createElement('br'));
            }

            target.appendChild(div);

            if (!msg.noNotify) {
                showNotify(notI, notifyText, nick, isConf, isConf ? msg.UID : uin);
            }
        }

        if (loadThmb) {
            // setTimeout(function () {
                downloadUploadManager.loadThumbs([info[0], info[1], msg.Idx], function (){
                    scrollDown(false, !msg.History, msg.History && noScrollDownOnSync);
                });
            // }, 10);
        }
    }

    function addCustomMSG (msg, frame, noTimeStamp){
        if (mcService.isObject(msg)){
            msg.Text = msg.Text || msg.Msg;
        }

        var target = framesList.get(frame);
        var div    = document.createElement('div');
        var text   = msg.Text !== undefined ? msg.Text.split('L$') : msg.split('L$'); //msg.Msg.split('L$');
        var uin    = msg.UIN !== undefined ? msg.UIN : (msg.UINFrom !== undefined ? msg.UINFrom : $rootScope.GetChatID()); //msg.UINFrom || msg.UIN;
        var time   = mcService.formatDate(msg.dt || (new Date()), 'hh:nn:ss');
        var notI   = uin != mcConst.UserInfo.UIN;

        if (mcService.trim(text[0]) === "") text.shift();

        for (var i = 0; i < text.length; i++){
            text[i] = text[i].replace(/</ig, "&lt;");
            text[i] = text[i].replace(/\u000b/ig, "");
        }

        text = mcService.ReplaceURLs(text.join('<br/>'), { callback: function(text, link){
            var res = "";

            if (/png|jpg|jpeg$/.test(link)){
                res = '<br/><img class="thumbImage" src="' + link + '">';
            }

            return link ? '<a href="' + link + '" title="' + link + '" target="_blank">' + (res || text) + '</a>' : text;
        }});

        if (text.indexOf(mcConst.CRLF) >= 0) {
            text = text.replace(new RegExp(mcConst.CRLF, 'g'), "<br/>");
        }

        div.className = (msg.Type ? "" : "brown ") + "framePaddingW5";
        div.style.wordBreak = "break-word";

        switch (msg.MsgType){
            case mcConst._CMD_.msgType.CONF_TURN_OUT:
                
            break;
        }

        div.innerHTML += '<br><div class="borderTop relative _messagesFontSize">' +
                            (($rootScope.isWebClient || mcConst.ClientSettings.EventsTimeStamp) && !noTimeStamp ? '<span class="messageTime">' + time + '</span> ' : "") +
                            '<span class="messageText messageTextP60"><i class="fa fa-bullhorn" aria-hidden="true"></i> ' + text + '</span> ' +
                         '</div>';

        div.setAttribute('uin', uin);

        if (msg.Idx) {
            div.setAttribute('Idx', msg.Idx);
        }

        if (msg.History){
            target.insertBefore(div, target.firstChild);
        } else {
            target.appendChild(div);

            var isConf = msg.UID !== undefined;

            showNotify(notI, text, "", isConf, isConf ? msg.UID : uin);
        }
    }

    function addRedirectMSG (msg, frame, noTimeStamp){
        var target = framesList.get(frame);
        var div    = document.createElement('div');
        var text   = "";
        var uin    = msg.UIN !== undefined ? msg.UIN : (msg.UINFrom !== undefined ? msg.UINFrom : $rootScope.GetChatID()); //msg.UINFrom || msg.UIN;
        var time   = mcService.formatDate(msg.dt || (new Date()), 'hh:nn:ss');
        var notI   = uin != mcConst.UserInfo.UIN;
        var rdData = mcService.StringToObj(msg.Msg);

        if (rdData.UIN == mcConst.UserInfo.UIN){
            text = mcLang(615, [rdData.DisplayNameTo, rdData.DisplayNameFrom]); // "615":"Вы перенаправлены к пользователю <span class='blue'>%s</span>",
        } else
        if (rdData.UINFrom == mcConst.UserInfo.UIN){
            text = mcLang(616, [rdData.DisplayName, rdData.DisplayNameTo]); // "616":"Вы перенаправили пользователя <span class='blue'>%s</span> к <span class='blue'>%s</span>",
        } else
        if (rdData.UINTo == mcConst.UserInfo.UIN){
            text = mcLang(617, [rdData.DisplayName, rdData.DisplayNameFrom]); // "617":"Пользователь <span class='blue'>%s</span> перенаправлен к вам от <span class='blue'>%s</span>",
        }

        div.className = (msg.Type ? "" : "brown ") + "framePaddingW5";
        div.style.wordBreak = "break-word";

        div.innerHTML += '<br><div class="borderTop relative _messagesFontSize">' +
                            (($rootScope.isWebClient || mcConst.ClientSettings.EventsTimeStamp) && !noTimeStamp ? '<span class="messageTime">' + time + '</span> ' : "") +
                            '<span class="messageText messageTextP60"><i class="fa fa-bullhorn" aria-hidden="true"></i> ' + text + '</span> ' +
                         '</div>';

        div.setAttribute('uin', uin);

        if (msg.Idx) {
            div.setAttribute('Idx', msg.Idx);
        }

        if (msg.History){
            target.insertBefore(div, target.firstChild);
        } else {
            target.appendChild(div);

            var isConf = msg.UID !== undefined;

            showNotify(notI, text, "", isConf, isConf ? msg.UID : uin);
        }
    }

    function addKanbanMSG (msg, frame){
        var target = framesList.get(frame);
        var div    = document.createElement('div');
        var kMSG   = JSON.parse(msg.Msg);
        var uin    = msg.UIN !== undefined ? msg.UIN : (msg.UINFrom !== undefined ? msg.UINFrom : $rootScope.GetChatID()); //msg.UINFrom || msg.UIN;
        var time   = msg.dt ? mcService.formatDate(msg.dt, 'dd.mm.yyyy hh:nn:ss') : mcService.formatDate(new Date(), 'hh:nn:ss');
        var text   = "";
        var notifyText;

        if (!kMSG.TaskName) {
            return;
        }

        switch (kMSG.What){
            case mcConst.KanbanEvents.TASK_ADDED: case mcConst.KanbanEvents.TASK_PERFORMER_CHANGED:
                text = mcLang(543, [ // "543":"<a href='%s' target='_blank'>Новое задание</a> от %s<br>Задание:<br>%s<br>Описание:<br>%s",
                    mcService.createKanbanLink(kMSG.ProjectID, kMSG.TaskID),
                    kMSG.DisplayName,
                    parseLink(kMSG.TaskName),
                    parseLink(kMSG.Description)
                ]);

                notifyText = "KANBAN Task:<br>" + kMSG.TaskName;
            break;

            case mcConst.KanbanEvents.COMMENT_ADDED:
                text = mcLang(544, [ // "544":"<a href='%s' target='_blank'>Новый комментарий</a> от %s<br>Задание:<br>%s<br>Комментарий:<br>%s",
                    mcService.createKanbanLink(kMSG.ProjectID, kMSG.TaskID, kMSG.CommentID),
                    kMSG.DisplayName,
                    parseLink(kMSG.TaskName),
                    parseLink(kMSG.Comment)
                ]);

                notifyText = "KANBAN Comment:<br>" + kMSG.Comment;
            break;

            case mcConst.KanbanEvents.TASK_MOVED:
                text = mcLang(545, [ // "545":"<a href='%s' target='_blank'>Задание перемещено</a> пользователем %s<br>Задание:<br>%s<br>Откуда и куда:<br>%s",
                    mcService.createKanbanLink(kMSG.ProjectID, kMSG.TaskID),
                    kMSG.DisplayName,
                    parseLink(kMSG.TaskName),
                    kMSG.OldStageName + " &gt; " + kMSG.StageName
                ]);

                notifyText = "KANBAN Task:<br>" + kMSG.TaskName;
            break;

            case mcConst.KanbanEvents.TASK_CHANGED:
                text = mcLang(546, [ // "546":"<a href='%s' target='_blank'>Задание изменено</a> пользователем %s<br>Задание:<br>%s<br>Описание:<br>%s",
                    mcService.createKanbanLink(kMSG.ProjectID, kMSG.TaskID),
                    kMSG.DisplayName,
                    parseLink(kMSG.TaskName),
                    parseLink(kMSG.Description)
                ]);

                notifyText = "KANBAN Task:<br>" + kMSG.TaskName;
            break;

            case mcConst.KanbanEvents.TASK_DELETED:
                text = mcLang(547, [ // "547":"<a href='%s' target='_blank'>Задание удалено</a> пользователем %s<br>Задание:<br>%s<br>Описание:<br>%s<br>Проект:<br>%s",
                    mcService.createKanbanLink(kMSG.ProjectID, kMSG.TaskID),
                    kMSG.DisplayName,
                    parseLink(kMSG.TaskName),
                    parseLink(kMSG.Description),
                    kMSG.ProjectName
                ]);

                notifyText = "KANBAN Task:<br>" + kMSG.TaskName;
            break;

            case mcConst.KanbanEvents.PROJECT_CLOSED:
                text = mcLang(548, [ // "548":"<a href='%s' target='_blank'>Проект закрыт</a> пользователем %s<br>Проект:<br>%s",
                    mcService.createKanbanLink(kMSG.ProjectID, kMSG.TaskID),
                    kMSG.DisplayName,
                    kMSG.ProjectName
                ]);

                notifyText = "KANBAN Project:<br>" + kMSG.ProjectName;
            break;
        }

        div.className = "framePaddingW5";
        div.style.wordBreak = "break-word";

        div.innerHTML += '<div class="borderTop marginTop10 _messagesFontSize"><i class="fa fa-bullhorn" aria-hidden="true"></i>' +
                         '<span class="messageKanbanTime toRight lineHeight24">' + time + '</span> ' +
                         '<span class="messageKanban">' + text + '</span></div><br>';

        div.setAttribute('uin', uin);

        if (msg.Idx) {
            div.setAttribute('Idx', msg.Idx);
        }

        if (msg.History){
            target.insertBefore(div, target.firstChild);
        } else {
            target.appendChild(div);

            showNotify(true, notifyText, kMSG.DisplayName, false, uin);
        }
    }

    function addReceivedFilesMSG(msg, frame) {
        var target = framesList.get(frame);
        var div    = document.createElement('div');
        var uin    = msg.UIN;
        var time   = mcService.formatDate(new Date(), 'hh:nn:ss');
        var text   = "";
        var fileList  = msg.FilesList;
        var fileCount = msg.Count;
        var fileSize  = msg.Size;
        var filePath  = msg.Path;
        var count     = 0;
        var more      = false;
        var topText   = 597;

        switch (msg.MsgType){
            case mcConst._CMD_.msgType.SHOW_RECEIVED_FILES: topText = 597; break; // "597":"Принято %s файлов, общий рамер: %
            case mcConst._CMD_.msgType.SHOW_UPLOADED_FILES: topText = 599; break; // "599":"ОТправлено %s файлов, общий рамер: %s",
        }

        text = mcService.myReplaceFormated(
            "<span class='finger bolder #{addClass}'>#{msg}</span>",
            {
                msg  : mcLang(topText, [fileCount, mcService.formatFileSize(fileSize)]),
                addClass: "fileLink"
            }
        );

        fileList.forEach(function (file) {
            if ((file.received || file.sended) && count < 10){
                text += mcService.myReplaceFormated(
                    "<div><span class='brown'>#{name}</span> (#{size})</div>",
                    {
                        name: file.fileName,
                        size: mcService.formatFileSize(file.size)
                    }
                );
            } else {
                more = true;
            }

            count ++;
        });

        if (count > 10) {
            text += "<div>" + mcLang(598, count - 10) + "</div>"; // "598":"... еще %s файлов",
        }

        div.className = "framePaddingW5";
        div.style.wordBreak = "break-word";

        div.innerHTML += mcService.myReplaceFormated(
            '<br><div class="borderTop _messagesFontSize">' +
                '<span class="messageTime">#{time}</span> ' +
                '<span filepath="#{path}" class="messageText" title="#{oTitle}" onclick="window._userActions.openFolder.apply(this)"><i class="fa fa-folder-open-o" aria-hidden="true"></i> #{text}</span>' +
            '</div>',
            {
                time   : $rootScope.isWebClient || mcConst.ClientSettings.EventsTimeStamp ? time : "",
                text   : text,
                path   : filePath,
                oTitle : mcLang(574), // "574":"Показать в папке",
            }
        );

        div.setAttribute('uin', uin);

        target.appendChild(div);
    }

    // -----

    function chatMessage(msg) {
        var frame;

        if (!msg.hasOwnProperty('UID')){
            frame = $rootScope.createUIN(getUinWith(msg));
        } else {
            frame = $rootScope.createUID(msg.UID);
        }

        if (!framesList.hasFrame(frame)) {
            framesList.create(frame).hide();
        }

        msg.Idx = msg.Idx || msg.MsgIdx;

        if (!msg.History && msg.UINFrom == mcConst.UserInfo.UIN) {
            $rootScope.$broadcast(window._messages_.dialogsList.getUserState, [getUinWith(msg), function (state) {
                if (state === mcConst.states.offline) {
                    addCustomMSG(mcLang(572), frame, true); // "572":"Пользователь сейчас не в сети, ваше сообщение будет доставлено",
                }
            }]);
        }

        switch (msg.MsgType){
            case mcConst._CMD_.msgType.OLD_SHIT:
            case mcConst._CMD_.msgType.TEXT:
            case mcConst._CMD_.msgType.IMAGE:
            case mcConst._CMD_.msgType.INTEGRATION_API:
            case mcConst._CMD_.msgType.FILE:
                if (msg.Mod !== mcConst._CMD_.msgMods.DELETED){
                    addMSG(msg, frame);

                    noScrollDownOnSync = msg.History && !$scope.chatTextOutputW.getNode().scrollTop;
                }

                if (!msg.History && ((($rootScope.isWebClient || mcConst.ClientSettings.EventsPopupOnPrivateMessage) && !msg.hasOwnProperty('UID')) ||
                    (($rootScope.isWebClient || mcConst.ClientSettings.EventsPopupOnChannelMessage) && msg.hasOwnProperty('UID')))){

                    $rootScope.$broadcast(window._messages_.dialogsCtrl.selectDialog, [frame]);

                    if (!$rootScope.isWebClient) {
                        $rootScope.$broadcast(window._messages_.clientData.sendCMDToElectron, [
                            mcConst._CMD_.ce_show_on_top
                        ]);
                    }
                }
            break;

            case mcConst._CMD_.msgType.KANBAN_NOTIFY:
                addKanbanMSG(msg, frame);
            break;

            case mcConst._CMD_.msgType.CONF_ALERT:
            case mcConst._CMD_.msgType.CONF_PERSONAL:
                // мусорные команды - выкинуть нах с сервера
            break;

            case mcConst._CMD_.msgType.ADM_DELETE_MESSAGE:
                removeMSG(msg, frame);
            break;

            case  mcConst._CMD_.msgType.PRIVATE_REDIRECT:
                var redirectData = mcService.StringToObj(msg.Msg);

                if (!msg.History && redirectData.UIN == mcConst.UserInfo.UIN &&  redirectData.UINTo != $rootScope.GetChatID()) {
                    $rootScope.$broadcast('OpenPrivate', [redirectData.UINTo]);
                }

                addRedirectMSG(msg, frame);
            break;

            default:
                addCustomMSG(msg, frame);
        }

        if (currentFrame == frame || currentFrame.id == frame){
           scrollDown(false, !msg.History, msg.History && noScrollDownOnSync);
        }
    }

    function customMessage(msg) {
        var frame = null;

        if (msg.MsgType == mcConst._CMD_.msgType.KANBAN_NOTIFY){
            frame = 'UIN-0';
        } else {
            frame = msg.hasOwnProperty('UIN') ? "UIN-" + msg.UIN : "UID-" + msg.UID;
        }

        if (!framesList.hasFrame(frame)) {
            framesList.create(frame).hide();
        }

        if (msg.MsgType == mcConst._CMD_.msgType.KANBAN_NOTIFY) {
            $rootScope.$broadcast('updateCounter', [msg]);

            addKanbanMSG(msg, frame);
        } else
        if (msg.MsgType === mcConst._CMD_.msgType.SHOW_RECEIVED_FILES){
            addReceivedFilesMSG(msg, frame);
        } else
        if (msg.MsgType === mcConst._CMD_.msgType.SHOW_UPLOADED_FILES){
            addReceivedFilesMSG(msg, frame);
        } else {
            addCustomMSG(msg, frame);
        }

        noScrollDownOnSync = msg.History && !$scope.chatTextOutputW.getNode().scrollTop;
        
        if (currentFrame == frame || currentFrame.id == frame){
            scrollDown(false, !msg.History, msg.History && noScrollDownOnSync);
        }
    }

    // =============================================

    function transformRusText(text) {
        var listSymbols = {
            en : "qwertyuiop[]asdfghjkl;'zxcvbnm,.QWERTYUIOP{}ASDFGHJKL:ZXCVBNM<>`~\"",
            ru : "йцукенгшщзхъфывапролджэячсмитьбюЙЦУКЕНГШЩЗХЪФЫВАПРОЛДЖЯЧСМИТЬБЮёЁЭ",
            ua : "йцукенгшщзхїфівапролджєячсмитьбюЙЦУКЕНГШЩЗХЇФІВАПРОЛДЖЯЧСМИТЬБЮ`~Є"
        };
        var res = new Array(text.length);
        var idx = -1;

        for (var i = 0; i < text.length; i ++){
            idx = listSymbols.en.indexOf(text[i]);
            
            if (idx >= 0) {
                res[i] = listSymbols[mcConst.Lang][idx];
            } else {
                idx = listSymbols.ru.indexOf(text[i]);
                
                if (idx >= 0){
                    res[i] = listSymbols.en[idx];
                } else {
                    res[i] = text[i];
                }
            }
        }

        return res.join('');
    }

    function sendPrivate(UIN, text, msgType){
        var msg = mcService.trim(text || $scope.enterChatText.getValue());

        if (msg !== ''){
            msg = msgType === undefined || msgType === mcConst._CMD_.msgType.TEXT ? (msg.replace(/\n/gi, '\r\n')) : msg;

            if ($rootScope.isWebClient || mcConst.ClientSettings.SoundsSndChatRet) {
                mcPlaySound.PlaySound(mcPlaySound.Sounds.EnterBtn);
            }

            $rootScope.SendCMDToServer([
                mcConst._CMD_.cs_private_msg,
                mcConst.SessionID,

                JSON.stringify({
                    UIN : UIN || $rootScope.GetChatID(),
                    Msg : msg,
                    MsgType: msgType || mcConst._CMD_.msgType.TEXT
                })
            ]);
        }
    }

    function sendConf(UID, text, msgType){
        var msg = mcService.trim(text || $scope.enterChatText.getValue());

        if (msg !== ''){
            msg = msgType === undefined || msgType === mcConst._CMD_.msgType.TEXT ? (msg.replace(/\n/gi, '\r\n')) : msg;

            if ($rootScope.isWebClient || mcConst.ClientSettings.SoundsSndChatRet) {
                mcPlaySound.PlaySound(mcPlaySound.Sounds.EnterBtn);
            }

            $rootScope.$broadcast('SendCMDToServer' , [
                mcConst._CMD_.cs_put_msg2txt_channel,
                mcConst.SessionID,

                JSON.stringify({
                    UIN : mcConst.UserInfo.UIN,
                    UID : UID || $rootScope.GetChatID(),
                    Msg : msg,
                    MsgType: msgType || mcConst._CMD_.msgType.TEXT
                })
            ]);
        }
    }

    function getUinWith(msg){
        return ((mcConst.UserInfo.UIN == msg.UINFrom) ? msg.UINTo : msg.UINFrom);
    }

    function scrollDown(now, smooth, history){ // frame
        if (view){
            if (history){ // noScrollDownOnSync &&
                // scrollDownTimer = setTimeout(function () {
                if (scrollDownTimer){
                    clearTimeout(scrollDownTimer);

                    scrollDownTimer = null;
                }

                if ($scope.chatTextOutput.scrollHeight !== prevHeight){
                    $scope.chatTextOutputW.getNode().scrollTop += $scope.chatTextOutput.scrollHeight - prevHeight;

                    prevHeight = $scope.chatTextOutput.scrollHeight;
                }
                // }, 100);
            } else

            if (now ){ // && !noScrollDownOnSync
                prevHeight = $scope.chatTextOutput.scrollHeight;

                $scope.chatTextOutputW.getNode().scrollTop = prevHeight;
            } else
            if (!scrollDownTimer) { //  && !noScrollDownOnSync
                scrollDownTimer = setTimeout(function () {
                    scrollDownTimer = null;

                    prevHeight = $scope.chatTextOutput.scrollHeight;

                    if (smooth){
                        $scope.chatTextOutputW.getNode().scroll({top: prevHeight, left: 0, behavior: 'smooth'});
                    } else {
                        $scope.chatTextOutputW.getNode().scrollTop = prevHeight;
                    }
                }, 100);
            }
        }
    }

    function fillFrame(topBtnTitle, topTopic, hasHistory){
        var frame  = $rootScope.GetChatTypeID();

        if (view) {
            view.show();

            framesList.hide(prevFrame);

            titleValue   = [topBtnTitle, topTopic];
            currentFrame = framesList.get(frame);
            prevFrame    = frame;

            currentFrame.show();
            
            $rootScope.$broadcast('selectDialog',[frame]);

            $scope.displayName.show();
            $scope.displayName.define('label', topBtnTitle + (topTopic ? ': ' + topTopic : ''));
            $scope.displayName.refresh();

            scrollDown();

            if (hasHistory){
                mcService.showView($scope.loadMoreHistory);
            } else {
                mcService.hideView($scope.loadMoreHistory);
            }

            switch ($rootScope.GetChatType()){
                case $rootScope.chatAliases.UIN:
                    $scope.topLabelList = userMenu();  // private

                    $$($scope.container).getNode().className = "webix_view noMargin gradient2 webix_layout_line";

                    $scope.inputWrapper.show();
                    $scope.inputResizer.show();
                break;

                case $rootScope.chatAliases.UID:
                    $scope.topLabelList = confMenu();  // channel

                    $$($scope.container).getNode().className = "webix_view noMargin gradient webix_layout_line";

                    $scope.inputWrapper.show();
                    $scope.inputResizer.show();
                break;
            }

            focusToEnterChat();
        }
    }

    function focusToEnterChat(){
        if (mcConst.LoggedIn && $scope.enterChatText){
            var pos = mcService.getCaretPosition($scope.enterChatText.$view);
            
            $scope.displayName.focus();

            setTimeout(function () {
                $scope.enterChatText.focus();
                
                mcService.setCaretPosition($scope.enterChatText.$view, pos);
            }, 50);
        }
    }

    function _sendText(sendType, sendId, sendText, msgType){
        var id = sendId || $rootScope.GetChatID();

        switch (sendType || $rootScope.GetChatType()){
            case 'UIN': sendPrivate(id, sendText, msgType); break;
            case 'UID': sendConf(id, sendText, msgType);    break;
        }

        if (msgType !== mcConst._CMD_.msgType.IMAGE && msgType !== mcConst._CMD_.msgType.FILE){
            setTimeout(function(){
                $scope.enterChatText.setValue('');
                $scope.enterChatText.$setValue('');
            }, 10);
        }

        return false;
    }

    function minMax (isMax, callInfo) {
        var wrapper = $scope.videoFrameWrapper;
        var wrapNode = wrapper.getNode().firstChild;

        if (isMax){
            wrapNode.className = wrapNode.className.replace(" maxSize", "");
            wrapNode.style.position = "relative";

            if (callInfo.cPanel) {
                callInfo.cPanel.body.style.position = "absolute";
            }
        } else {
            wrapNode.className += " maxSize";
            wrapNode.style.position = "fixed";

            if (callInfo.cPanel) {
                callInfo.cPanel.body.style.position = "fixed";
            }
        }

        if (!$rootScope.isWebClient){
            $rootScope.$broadcast(window._messages_.clientData.toggleKioskMode, [!isMax]);
        }
    }

    function showVideoFrame(callInfo) {
        if (callInfo && (callInfo.useVideo || callInfo.receiveScreen)){
            var wrapper = $scope.videoFrameWrapper;
            var wrapNode = wrapper.getNode().firstChild;

            wrapper.show();

            $scope.videoResizer.show();

            $scope.videoFrameContainer = document.getElementById(mcConst.videoContainer);
            $scope.videoFrameContainer.appendChild(callInfo.video);

            if (callInfo.receiveScreen) {
                wrapNode.style.overflow = "auto";
                wrapNode.style.position = "relative";
            } else {
                wrapNode.style.overflow = "none";
                wrapNode.style.position = "";

                $scope.videoFrameContainer.appendChild(callInfo.mirror);

                callInfo.video.style.maxWidth = "100%";
            }

            view.getTopParentView().adjust();
            
            callInfo.cPanel.init(wrapNode);

            wrapNode.onmousemove = function () {
                callInfo.cPanel.onmousemove();
            };

            callInfo.cPanel.closeCall = function () {
                $rootScope.$broadcast(window._messages_.privateInfo.stopCurrentCall);
            };

            callInfo.cPanel.fitFill = function (isFit, videoContainer) {
                if (!isFit){
                    $scope.videoFrameContainer.style.height = "";
                    videoContainer.className = videoContainer.className.replace(" fit", "");
                } else {
                    $scope.videoFrameContainer.style.height = "100%";
                    videoContainer.className += " fit";
                }
            };

            callInfo.cPanel.minMax = function (isMax) {
                minMax(isMax, callInfo);
            };
            
            callInfo.cPanel.show();
        }
    }

    function hideVideoFrame(callInfo){
        var wrapNode = $scope.videoFrameWrapper.getNode();
        
        wrapNode.onmousemove = null;

        $scope.videoFrameWrapper.hide();
        
        $scope.videoResizer.hide();

        if ($scope.videoFrameContainer){
            $scope.videoFrameContainer.innerHTML = "";
        }

        $scope.videoFrameContainer = null;

        view.getTopParentView().adjust();

        if (!$rootScope.isWebClient && callInfo){
            minMax(true, callInfo);
        }
    }

    function markGotNotify(UIN, ID){
        var elem  = null;

        var firstIdx = $rootScope.$broadcast(window._messages_.dialogsList.getFirstLastMsg, [UIN, true]);

        for (var idx = ID; idx >= firstIdx; idx --){
            elem = document.getElementById(idx + "-st-" + mcConst.UserInfo.UIN);

            if (elem){
                if (elem.className.indexOf("messageGot") === 0 || elem.className.indexOf("messageRead") === 0){
                    break;
                } else {
                    elem.className = "messageGot statusItem";
                }
            }
        }
    }

    function markReadNotify(UIN, ID){
        var elem  = null;
        var firstIdx = $rootScope.$broadcast(window._messages_.dialogsList.getFirstLastMsg, [UIN, true]);

        for (var idx = ID; idx >= firstIdx; idx --){
            elem = document.getElementById(idx + "-st-" + mcConst.UserInfo.UIN);

            if (elem){
                if (elem.className.indexOf("messageRead") === 0){
                    break;
                } else {
                    elem.className = "messageRead statusItem";
                }
            }
        }
    }

    // =====================================
    // =====================================

    $scope.popupInsertPhrase = function(){

    };

    $scope.scrollControl = function (e) {
        if (e.clientX > $scope.chatTextOutputW.getNode().outerWidth){
            console.log('click on scroll');
        }
    };

    $scope.sendText = _sendText;

    $scope.popupInsertFile = function(){
        this.getTopParentView().hide();

        $scope.uploadFile(mcConst._CMD_.msgType.FILE, false, false);
    };

    $scope.popupInsertImage = function(){
        this.getTopParentView().hide();

        $scope.uploadFile(mcConst._CMD_.msgType.IMAGE, false, false);
    };

    $scope.addHistoryMessages = function () {
        noScrollDownOnSync = true;
        
        $rootScope.$broadcast(window._messages_.dialogsList.getHistoryMsgRange, [$rootScope.GetChatID(), $rootScope.GetChatType()]);
    };

    $scope.saveTextInputSize = function () {
        inputSize = $scope.inputWrapper.$getSize()[3];
        
        $rootScope.Storage.dialogs.save(null, null, mcConst.storageOpts.INPUTOPTS, inputSize);
    };

    $scope.loadTextInputSize = function () {
        $rootScope.Storage.dialogs.load(null, null, mcConst.storageOpts.INPUTOPTS, function (height) {
            if (height && !downloadUploadManager.isActive()) {
                $scope.inputWrapper.define('height', height);
                $scope.inputWrapper.resize();
                $scope.inputWrapper.resizeChildren();
            }
        });
    };

    $scope.registerHotKeys = function () {
        $rootScope.hotKeyDispatcher.addPreset(mcConst.dataModels.ChatFrame, [{
            key   : mcConst.keyCodes.enter,
            func  : function () {
                $scope.sendText();
            }
        }, {
            key   : mcConst.keyCodes.enter,
            ctrlKey: true,
            func  : function () {
                if ($rootScope.isWebClient || mcConst.ClientSettings.GeneralCtrlEnterSend) {
                    $scope.sendText();
                } else {
                    $scope.enterChatText.getInputNode().value += "\n";
                }
            }
        }, {
            key   : mcConst.keyCodes.f8,
            func  : function () {
                var node = $scope.enterChatText.getInputNode();
                var selectedText = mcService.getSelectedText(node);

                if (selectedText.infix){
                    $scope.enterChatText.setValue(selectedText.prefix + transformRusText(selectedText.infix) + selectedText.postfix);

                    mcService.setSelectionText(node, selectedText.selectionStart, selectedText.selectionEnd);
                } else {
                    $scope.enterChatText.setValue(transformRusText($scope.enterChatText.getValue()));
                    
                    mcService.setCaretPosition(node, selectedText.selectionEnd);
                }
            }
        }], $scope.enterChatText.getNode());

        $rootScope.hotKeyDispatcher.addPreset(mcConst.dataModels.ChatFrame + "global", [{
            key   : mcConst.keyCodes.f5,
            func  : function () {
                $scope.clipPopupWindow.hide();

                $scope.uploadFile(mcConst._CMD_.msgType.FILE, false, false);
            }
        },{
            key   : mcConst.keyCodes.f6,
            func  : function () {
                $rootScope.$broadcast(_messages_.privateInfo.redirectUserTo);
            }
        }, {
            key   : mcConst.keyCodes.f,
            ctrlKey: true,
            func  : function () {
                $scope.searchWrapper.show();
                $scope.searchChatText.focus();
            }
        }, {
            key     : mcConst.keyCodes.v,
            shiftKey: true,
            ctrlKey : true,
            func    : function () {
                downloadUploadManager.sendFilesToUser(true);
            }
        }, {
            key     : mcConst.keyCodes.f4,
            ctrlKey : true,
            func    : function () {
                $rootScope.$broadcast(_messages_.dialogsList.removeDialogFromList, [$rootScope.GetChatID()]);
            }
        }], document);

        $rootScope.hotKeyDispatcher.addPreset(mcConst.dataModels.ChatFrame + "find", [{
            key   : mcConst.keyCodes.enter,
            func  : function () {
                $rootScope.$broadcast("find_chat_text", [currentFrame, $scope.searchChatText.getValue(), $scope.searchChatText]);
            }
        }, {
            key     : mcConst.keyCodes.esc,
            lockPrev: true,
            func    : $scope.hideFindChatText
        }], $scope.searchChatText.getNode());
    };

    $scope.removeHotKeys = function () {
        $rootScope.hotKeyDispatcher.removePreset(mcConst.dataModels.ChatFrame);
        $rootScope.hotKeyDispatcher.removePreset(mcConst.dataModels.ChatFrame + "global");
        $rootScope.hotKeyDispatcher.removePreset(mcConst.dataModels.ChatFrame + "find");
    };

    $scope.hideFindChatText = function () {
        $scope.searchWrapper.hide();
        $scope.searchChatText.setValue("");

        $rootScope.$broadcast("find_clear", [currentFrame]);

        setTimeout(function () {
            $scope.enterChatText.focus();
        }, 50);
    };

    $scope.titleMenu = function(){
        switch ($rootScope.GetChatType()){
            case $rootScope.chatAliases.UIN:
                $rootScope.$broadcast("selectTool", [mcConst.dataModels.PrivateInfo,  true]);
            break;

            case $rootScope.chatAliases.UID:
                $rootScope.$broadcast("selectTool", [mcConst.dataModels.ConfUserList, true]);
            break;
        }
    };

    $scope.changeScrollPosition = function () {
        var scrView   = $scope.chatTextOutputW.getNode();
        var newHeight = scrView.scrollHeight;
        var delta     = newHeight - prevHeight;

        if ( delta >= 0){
            scrView.scrollTop += delta;
        } else {
            scrView.scrollTop -= delta;
        }

        prevHeight = newHeight;
    };

    $scope.typingNotify = function(code, e){ // code, e
        if (!e.altKey && !e.ctrlKey){
            if (mcConst.keyCodes.PrintSymbols.indexOf(code) !== -1){
                if ($rootScope.isWebClient || mcConst.ClientSettings.SoundsSndChatType) {
                    mcPlaySound.PlaySound(mcPlaySound.Sounds.Typing);
                }
            } else
            if ((code === mcConst.keyCodes.delete || code === mcConst.keyCodes.backspace) && $scope.enterChatText.getValue() && ($rootScope.isWebClient || mcConst.ClientSettings.SoundsSndChatBS)) {
                mcPlaySound.PlaySound(mcPlaySound.Sounds.DeleteAct);
            }
        }

        if ($rootScope.GetChatType() === 'UIN'){
            pressNotifyCount ++;

            if (pressNotifyCount === 10){
                pressNotifyCount = 0;

                $rootScope.$broadcast('SendCMDToServer', [
                    mcConst._CMD_.cs_typing_notify,
                    mcConst.SessionID,
                    $rootScope.GetChatID()
                ])
            }
        }
    };

    $scope.show = function(){
        if (!view){
            downloadUploadManager = new DownloadUploadManager($rootScope, _sendText);
            // framesList            = new McFramesList();

            $scope.uploadFile = downloadUploadManager.uploadFile;
            $scope.initDU     = downloadUploadManager.initViews;
            $scope.duViews    = downloadUploadManager.getViews();

            view = initChatFrame($scope);

            framesList.initView($scope.chatTextOutput);
            framesList.show(prevFrame);

            if (!currentFrame){
                currentFrame = framesList.get(prevFrame);
            }

            downloadUploadManager.onPasteItemFromClipboard($scope.enterChatText.$view);
        } else {
            view.show();
        }

        scrollDown();
        
        $scope.registerHotKeys();

        setTimeout(function () {
            downloadUploadManager.loadAllImages(function () {
                scrollDown();
            });
        }, 100);
    };

    //========================================

    var _msg = _messages_.chatFrame = {
        showMirrorVideoFrame    : 'showMirrorVideoFrame',
        blurChatTextOutput      : 'blurChatTextOutput',
        showVideoFrame          : 'showVideoFrame',
        hideVideoFrame          : 'hideVideoFrame',
        clearChatFrame          : 'clearChatFrame',
        fillChatFrame           : 'fillChatFrame',
        addChatMessage          : 'addChatMessage',
        addCustomMSG            : 'addCustomMSG',
        clearConfMessages       : 'clearConfMessages',
        clearPrivateMessages    : 'clearPrivateMessages',
        removeFrameChat         : 'removeFrameChat',
        on_mainWindowFocused    : 'on_mainWindowFocused',
        focusToEnterChat        : 'focusToEnterChat',
        scrollDownChat          : 'scrollDownChat',
        showNotifyMessage       : 'showNotifyMessage',
        updateMessagesState     : 'updateMessagesState',
        on_private_got_notify   : 'on_private_got_notify',
        on_private_read_notify  : 'on_private_read_notify',
        quickMessagesList       : 'quickMessagesList',

        '----':'----'
    };

    // ===================================================================

    $scope.$on(_msg.quickMessagesList, function (e, args){
        msgTemplateList  = args[0];

        // console.log(msgTemplateList);
    });

    $scope.$on(_msg.updateMessagesState, function (e, args) {
        var UIN  = args[0];
        var fUIN = $rootScope.createUIN(UIN);

        myMessages = {
            UIN        : -1,
            IDMyMsgGot : 0,
            IDMyMsgRead: 0
        };

        if (UIN != mcConst.UserInfo.UIN && $rootScope.GetChatTypeID() === fUIN && myMessages.UIN != UIN) {
            myMessages = mcService.Marge(myMessages, $rootScope.$broadcast(window._messages_.dialogsList.getMyMessagesState, [UIN]));

            if ($rootScope.GetChatTypeID() === fUIN){
                markReadNotify.apply(null, [UIN, myMessages.IDMyMsgRead]);

                if (myMessages.IDMyMsgGot > myMessages.IDMyMsgRead){
                    markGotNotify.apply(null, [UIN, myMessages.IDMyMsgGot]);
                }
            }
        }
    });

    $scope.$on(_msg.on_private_got_notify, function (e, args) {
        markGotNotify.apply(null, [args[0].UIN, args[0].ID]);
    });

    $scope.$on(_msg.on_private_read_notify, function (e, args) {
        markReadNotify.apply(null, [args[0].UIN, args[0].ID]);
    });

    $scope.$on(_msg.showNotifyMessage, function (e, args) {
        showNotify.apply(null, args);
    });

    $scope.$on(_msg.scrollDownChat, function (e, args) {
        scrollDown.apply(null, args);
    });

    $scope.$on(_msg.focusToEnterChat, focusToEnterChat);

    $scope.$on(_msg.on_mainWindowFocused, function(){
        focusToEnterChat();
    });

    $scope.$on(_msg.showMirrorVideoFrame, function(){
        mcService.showFrame(mcConst.myVideoStream);
    });

    $scope.$on(_msg.blurChatTextOutput, function(){
        $scope.clipPopupWindow.hide();

        $scope.enterChatText.blur();
    });

    $scope.$on(_msg.showVideoFrame, function(e, args){
        showVideoFrame.apply(null, args);
    });

    $scope.$on(_msg.hideVideoFrame, function (e, args) {
        hideVideoFrame.apply(null, args);
    });

    $scope.$on(_msg.clearChatFrame, function(e, args){

    });

    $scope.$on(_msg.fillChatFrame, function(e, args){
        noScrollDownOnSync = false;
        
        fillFrame.apply(null, args);
        
        $scope.hideFindChatText();
    });

    $scope.$on(_msg.addChatMessage, function(e, args){
        chatMessage.apply(null, args);
    });

    $scope.$on(_msg.addCustomMSG, function(e, args){
        customMessage.apply(null, args);
    });

    $scope.$on(_msg.clearConfMessages, function(e, args){
        var uid = args[0];

        framesList.clear('UID-' + uid);
    });

    $scope.$on(_msg.clearPrivateMessages, function(e, args){
        var uin = args[0];

        framesList.clear('UIN-' + uin);
    });

    $scope.$on(_msg.removeFrameChat, function (e, args) {
        var type = args[0];
        var idx  = args[1];
        
        framesList.remove(type + "-" + idx);
    });

    $scope.$on('hide' + $scope.Name, function(){
        $scope.removeHotKeys();
        $scope.hideFindChatText();

        view.hide();
    });

    $scope.$on('show' + $scope.Name, function(e, args){
        $scope.container = args[0];

        $scope.show();

        $scope.loadTextInputSize();
    });

    $rootScope.$broadcast('windowResize', [function(){
        if (view && view.isVisible()){
            var inFocus = webix.UIManager.getFocus();

            if (inFocus && inFocus.config.id === $scope.enterChatText.config.id){
                $scope.enterChatText.focus();
            }
        }
    }]);
}
"use strict";

function initBbsFrame($scope){
    var view = $$($scope.Name);

    function numberList(length) {
        return (new Array(length || 1)).join('.').split('.').map(function (itm, idx) { return idx.toString() })
    }

    if (!view){
        $$($scope.container).addView({
            id   : $scope.Name,
            rows : [
                { view: "button", type: "icon", icon: "chevron-down", id: "displayName" + $scope.Name, label: mcLang(556), // "556":"Доска объявлений",
                    click: $scope.titleMenu, css: "whiteBG imgBtn button_info frameTopBtnCenter",
                    on: { onItemClick: function () {
                        var btn = this.getNode();

                        setTimeout(function () {
                            $scope.clipPopupWindow.show(btn, {pos: 'bottom', x: 5, y: 10});
                        }, 100);
                    }}
                },

                { id: "bbsContent" + $scope.Name, view: "template", borderless: true, css: "myScroll selectable " + (!isMobile ? "scrollMenu" : ""),
                    scroll: false, template: '&nbsp;', gravity: 3},

                { id: "bbsResizer" + $scope.Name, view: "resizer", hidden: true},

                { id: "inputWrapper" + $scope.Name, gravity: 2, hidden: true, css: "whiteBG", rows: [

                    { view: "toolbar", height: 32, css: "borderTop", padding: 0, cols: [
                        { view:"datepicker",
                            id           : "bbsLifeTime" + $scope.Name,
                            value        : new Date(),
                            labelPosition: 'left',
                            labelAlign   : 'right',
                            label        : mcLang(559) + ":", // "559":"Актуально до",
                            labelWidth   : 110,
                            width        : 240,
                            suggest      : {
                                type : "calendar",
                                body : { minDate: new Date((new Date()).getTime() - mcConst.oneDay), maxDate: new Date("3000.01.01") }
                            }
                        },

                        { id: "bbsHours" + $scope.Name, view: "richselect", width: 55, value: 23, borderless: true,
                            suggest: { fitMaster: false, width: 65,
                                data: numberList(24)
                            }
                        },

                        { view: "label", label: ":", align: "center", width: 1, padding: 0},

                        { id: "bbsMinutes" + $scope.Name, view: "richselect", width: 55, value: 59, borderless: true,
                            suggest: { fitMaster: false, width: 65,
                                data: numberList(60)
                            }
                        },

                        { id: "bbsToTop" + $scope.Name, view: "checkbox", value: false, labelWidth: 0, labelRight: mcLang(560),  width: 20, css: "finger"}, // "560":"Поднять вверх",

                        {},

                        { view: "button", type: "icon", icon: "close", css: "noBG noBorderAll byCenter button_danger iconNoPadding", tooltip: mcLang(12), // "12" :"Закрыть",
                            click: $scope.closeBBS, width: 35
                        },

                        { width: 5},

                        { id: "btnSendText" + $scope.Name, view: "button", type: "icon", icon: "send", css: "noBG noBorderAll iconNoPadding byCenter", tooltip: mcLang(558), // "558":"Опубликовать",
                            click: $scope.sendBBS, width: 35
                        },

                        { width: 5}
                    ]},

                    { id: "enterBBSText" + $scope.Name, view: "textarea", css: "noBGColorAll borderTop", borderless: true, placeholder: mcLang(27)}, // "27" : "Введите ваше сообщение здесь",

                ]}
            ]
        });

        $scope.clipPopupWindow = webix.ui({
            view : "popup",
            id   : "topMenu" + $scope.Name,
            head : false,
            css  : "noUpperCase",
            width: 200,
            padding: 0,
            body : {  rows: [{
                view : "button",
                type : "icon",
                icon : "plus",
                css  : "icoButton",
                label: mcLang(557), // "557":"Новое объявление",
                click: function(){
                    this.getTopParentView().hide();

                    $scope.addNewBBS();
                }
            }]}
        });

        view = $$($scope.Name);

        $scope.bbsContent   = $$("bbsContent" + $scope.Name);
        $scope.enterBBSText = $$("enterBBSText" + $scope.Name);

        $scope.bbsResizer   = $$("bbsResizer" + $scope.Name);
        $scope.inputWrapper = $$("inputWrapper" + $scope.Name);
        $scope.btnSendText  = $$("btnSendText" + $scope.Name);

        $scope.bbsToTop     = $$("bbsToTop" + $scope.Name);
        $scope.bbsLifeTime  = $$("bbsLifeTime" + $scope.Name);
        $scope.bbsHours     = $$("bbsHours" + $scope.Name);
        $scope.bbsMinutes   = $$("bbsMinutes" + $scope.Name);
    } else {
        view.show();
    }

    return view;
}"use strict";

function bbsController($scope, $rootScope, mcPlaySound){
    $scope.Name = mcConst.dataModels.BBS;

    var view  = null;
    var deferredLoadImages = new McDeferredLoadImages();

    // =====================================

    function addMSG (bbs){
        // [{
        //     DisplayName: "Andrey Rakov",
        //     ID: 47,
        //     Msg: "sdfsdfsdfsdf",
        //     Top: false,
        //     UIN: 3,
        //     dtActualTo: "30.06.2017.23.59.00",
        //     dtCreated: "22.06.2017.17.11.16"
        // }]

        var div    = document.createElement('div');
        var text   = bbs.Msg.replace(/\u041e\u00ac/g, "");
        var uin    = bbs.UIN;
        var nick   = bbs.DisplayName;
        var time   = (bbs.dtCreated) ? bbs.dtCreated.split('.') : "";
        var date   = '';
        var target = $scope.bbsContent.getNode().firstChild;

        date = (time.length === 6) ? time[0] + "." + time[1] + "." + time[2] + "&nbsp;" : time; // dt[0] + "." + dt[1] + "." + dt[2] + "&nbsp;" +
        time = (time.length === 6) ? time[3] + ":" + time[4] + ":" + time[5] + "&nbsp;" : time; // dt[0] + "." + dt[1] + "." + dt[2] + "&nbsp;" +

        text = mcService.ReplaceURLs(text, { callback: function(text, link){
            var res = "";

            if (/png|jpg|jpeg$/.test(link)){
                res = '<br/><img class="thumbImage" src="' + link + '">';
            }

            return link ? '<a href="' + link + '" title="' + link + '" target="_blank">' + (res || text) + '</a>' : text;
        }}).replace(/\r\n/g, "<br>");

        div.className = bbs.Top ? "messageUser" : "messageMy";

        div.innerHTML = mcService.myReplaceFormated(
            "<div id='#{id}' class='bbsMessage'>" +
                "<div><span class='bbsTime brown'>#{time}</span> <span class='bbsDate gray'>#{date}</span> <span class='bbsName linkColor finger' uin='#{uin}' onclick='_userActions.openUserPrivate.apply(this)'>#{name}</span></div><br>" +
                "<div class='bbsText'>#{text}</div>" +
            "</div>",
            {
                id  : bbs.ID,
                time: time,
                date: date,
                name: nick,
                text: text,
                uin : uin
            }
        );
        
        div.setAttribute('uin', uin);
        div.setAttribute('Idx', bbs.ID);
        div.style.wordBreak = "break-word";

        target.insertBefore(document.createElement('br'), target.firstChild);
        target.insertBefore(div, target.firstChild);
    }

    function showFileLoadingImg(){
        $scope.clipPopupButton.hide();
        $scope.clipPopupLoaderImg.show();

        $scope.enterBBSText.disable();
    }

    function hideFileLoadingImg(){
        if (!$scope.clipPopupButton.isVisible()){
            $scope.clipPopupLoaderImg.hide();
            $scope.clipPopupButton.show();

            $scope.enterBBSText.enable();
        }
    }

    // =====================================
    // =====================================

    $scope.registerHotKeys = function () {
        $rootScope.hotKeyDispatcher.addPreset(mcConst.dataModels.BBS, [{
            key   : mcConst.keyCodes.enter,
            func  : $scope.sendText
        }, {
            key   : mcConst.keyCodes.esc,
            func  : $scope.closeBBS
        }], $scope.enterBBSText.getNode());

        $rootScope.hotKeyDispatcher.addPreset(mcConst.dataModels.BBS + "global", [{
            key   : mcConst.keyCodes.n,
            altKey: true,
            func  : $scope.addNewBBS
        }], document);
    };

    $scope.removeHotKeys = function () {
        $rootScope.hotKeyDispatcher.removePreset(mcConst.dataModels.BBS);
        $rootScope.hotKeyDispatcher.removePreset(mcConst.dataModels.BBS + "global");
    };

    $scope.addNewBBS = function () {
        $scope.inputWrapper.show();
        $scope.bbsResizer.show();

        $scope.enterBBSText.focus();
    };

    $scope.closeBBS = function () {
        $scope.inputWrapper.hide();
        $scope.bbsResizer.hide();

        setTimeout(function(){
            $scope.enterBBSText.setValue('');
            $scope.enterBBSText.$setValue('');
            $scope.enterBBSText.focus();
        }, 10);
    };

    $scope.sendBBS = function () {
        var msg    = mcService.trim($scope.enterBBSText.getValue());
        var expire = mcService.formatDate($scope.bbsLifeTime.getValue(), "dd.mm.yyyy.") +
                     $scope.bbsHours.getValue() + "." + $scope.bbsMinutes.getValue() + ".00";
        var sticky = mcService.convertIntToBool($scope.bbsToTop.getValue());

        if ($rootScope.isWebClient || mcConst.ClientSettings.SoundsSndChatRet) {
            mcPlaySound.PlaySound(mcPlaySound.Sounds.EnterBtn);
        }

        if (msg !== ''){
            msg = msg.replace(/\n/g, '\r\n');

            $rootScope.SendCMDToServer([
                mcConst._CMD_.cs_add_new_bbs,
                mcConst.SessionID,
                JSON.stringify({
                    Expired: expire, // 12.01.2013.14.15.00 до какого времени объявление будет актуально
                    Sticky : sticky, // Sticky "прилепленное" объявление (в самом верху) или обычное
                    Msg    : msg     // содержимое объявления
                })
            ]);

            setTimeout($scope.closeBBS, 50);
        }

        return false;
    };

    $scope.show = function(){
        view = initBbsFrame($scope);
    };
    
    $scope.getData = function (showNotify) {
        $rootScope.SendCMDToServer([
            mcConst._CMD_.cs_get_bbs,
            mcConst.SessionID,
            function (listBBS) {
                $scope.bbsContent.getNode().firstChild.innerHTML = "&nbsp;";
                
                if (listBBS && listBBS.length > 0){
                    var sticked = [];
                    var ordinary = [];
                    var first = listBBS[0];

                    if (showNotify && first){
                        var text = first.Msg.replace(/\u041e\u00ac/g, "");
                        var textForNotify = text.slice(0, 100) + ((text.length > 100) ? '...' : "" );

                        $rootScope.$broadcast('sendCMDToElectron', [
                            mcConst._CMD_.ce_show_notify,

                            first.DisplayName.slice(0, 30) + ((first.DisplayName.length > 30) ? '..' : "" ) + ":",
                            textForNotify,
                            first.ID
                        ]);
                    }

                    listBBS.forEach(function (bbs) {
                        if (bbs.Top) {
                            sticked.push(bbs);
                        } else {
                            ordinary.push(bbs);
                        }
                    });

                    sticked.sort(function (a, b) {
                        return mcService.sortAB(a.dtCreated, b.dtCreated);
                    });

                    ordinary.sort(function (a, b) {
                        return mcService.sortAB(a.dtCreated, b.dtCreated);
                    });

                    ordinary.forEach(function (bbs) {
                        addMSG(bbs);
                    });
                    
                    sticked.forEach(function (bbs) {
                        addMSG(bbs);
                    });
                }
            }
        ]);
    };

    //========================================

    var _msg = _messages_.BBS = {
        refreshBBS  : 'refreshBBS'
    };

    $scope.$on(_msg.refreshBBS, function (e, args) {
        var showNotify = args[0];

        if (view){
            $scope.getData(showNotify);
        }
    });

    $scope.$on('hide' + $scope.Name, function(){
        if (view && view.isVisible()) {
            $scope.removeHotKeys();

            view.hide();
        }
    });

    $scope.$on('show' + $scope.Name, function(e, args){
        $scope.container = args[0];

        $scope.show();

        $scope.getData();

        $scope.registerHotKeys();
    });
}"use strict";

function initKanbanFrame($scope){
    var view = $$($scope.Name);

    if (!view){
        $$($scope.container).addView({
            id   : $scope.Name,
            view : "iframe",
            css  : "iFrameFit",
            src  : $scope.kanbanURL + $scope.getToken($scope.kanbanURL),
            on   : {
                // onAfterLoad: $scope.onLoadKanban
            }
        });

        view = $$($scope.Name);
        
        view.showFrame = function () {
            view.define('width', undefined);
            view.resize();

            mcService.showFrame($scope.Name);
        };

        view.hideFrame = function () {
            view.define('width', '0');
            view.resize();

            mcService.hideFrame($scope.Name);
        };
    } else {
        view.showFrame();
    }

    return view;
}"use strict";

function kanbanController($scope, $rootScope, mcPlaySound){
    $scope.Name = mcConst.dataModels.Kanban;

    var iFrame = null;
    var goUrl  = null;

    $scope.token     = null;
    $scope.kanbanURL = "";

    function setKanbanUrl(url) {
        if (!$scope.token){
            $rootScope.SendCMDToServer([
                mcConst._CMD_.cs_create_token,
                mcConst.SessionID,

                $rootScope.chatAliases.Kanban.toLowerCase(),
                $scope.kanbanURL,

                function (data) {
                    $scope.token     = data.Token;

                    if (url){

                    }
                    $scope.kanbanURL = url || $scope.kanbanURL; //(mcService.getLocalHostPath($rootScope.isWebClient) + "/" + mcConst.pathAliases.AliasKanban + "/");

                    if (!iFrame.config.src) {
                        iFrame.define("src", $scope.kanbanURL + $scope.getToken($scope.kanbanURL));
                    }
                }
            ]);
        } else {
            goUrl = url.indexOf($scope.token) > 0 ? url : (url + $scope.getToken(url));

            if (iFrame && url.indexOf(mcService.getLocalHostPath($rootScope.isWebClient) === 0)){
                iFrame.define("src", goUrl);

                goUrl = null;
            } else {
                console.warn("Wrong URL for iFrame:" + goUrl);
            }
        }
    }

    // =====================================
    // =====================================

    $scope.getToken = function (url) {
        return $scope.token ? (url.indexOf("?") === -1 && url.indexOf("#") === -1 ? "?" : "&") + "token=" + $scope.token : "";
    };

    $scope.registerHotKeys = function () {
        // $rootScope.hotKeyDispatcher.addPreset(mcConst.dataModels.Kanban, [{
        //     key   : mcConst.keyCodes.enter,
        //     func  : function () {
        //     }
        // }], document);
    };

    $scope.removeHotKeys = function () {
        // $rootScope.hotKeyDispatcher.removePreset(mcConst.dataModels.Kanban);
    };

    $scope.show = function(){
        iFrame = initKanbanFrame($scope);
    };

    // $scope.onLoadKanban = function () {
    //     if (goUrl){
    //         setTimeout(function () {
    //             setKanbanUrl(goUrl);
    //         }, 200);
    //     }
    // };

    //========================================

    var _msg = _messages_.kanban = {
        openKanbanUrl  : 'openKanbanUrl',
        closeKanban    : 'closeKanban'
    };

    $scope.$on(_msg.openKanbanUrl, function (e, args) {
        setKanbanUrl.apply(null, args);
    });

    $scope.$on(_msg.closeKanban, function () {
        if (iFrame){
            $scope.token = null;
            $scope.kanbanURL = null;

            iFrame.define('src', "");
        }
    });

    $scope.$on('hide' + $scope.Name, function(){
        $scope.removeHotKeys();

        if (iFrame && iFrame.isVisible()) {
            iFrame.hideFrame();
        }
    });

    $scope.$on('show' + $scope.Name, function(e, args){
        $scope.container = args[0];

        if (!$scope.kanbanURL) {
            $rootScope.SendCMDToServer([
                mcConst._CMD_.cs_create_token,
                mcConst.SessionID,

                $rootScope.chatAliases.Kanban.toLowerCase(),
                $scope.kanbanURL,

                function (data) {
                    $scope.token = data.Token;

                    $scope.show();

                    if (!iFrame.config.src) {
                        $scope.kanbanURL = mcService.getLocalHostPath($rootScope.isWebClient) + "/" + mcConst.pathAliases.AliasKanban + "/";

                        iFrame.define("src", $scope.kanbanURL + $scope.getToken($scope.kanbanURL));
                    }
                }
            ]);
        }

        // if ($scope.token){
        // } else {
            $scope.show();
        // }
    });
}"use strict";

function initUserProfile($scope){
    function __textInput(id, pl, lb, change, disabled, hidden){
        return {
            view         : "text",
            id           : 'up' + id,
            // value        : $scope.data[id],
            labelPosition: 'top',
            css          : "noBGAll",
            placeholder  : mcLang(pl) || pl,
            label        : mcLang(lb) || lb,
            on           : { onTimedKeyPress: change  || function(){}},
            disabled     : disabled,
            hidden       : (hidden != undefined)? hidden : false
        }
    }

    var _view = $$($scope.Name);

    if (!_view){
        var width  = $scope.wndSize.width  >= 800 ? 600 : $scope.wndSize.width;
        var height = $scope.wndSize.height >= 800 ? 800 : $scope.wndSize.height;
        var labelWidth = 100;

        var _sex = [
            {id: '0', value: mcService.Lang(74)}, // "74" : "не определен",
            {id: '1', value: mcService.Lang(75)}, // "75" : "мужской",
            {id: '2', value: mcService.Lang(76)}  // "76" : "женский",
        ];

        var infoMain = { id: "profileBody" + $scope.Name, /*height: height - 33 - 34, width: width, */ css: "myScroll scrollMenu", rows: [
            { height: 4}
        ]};

        var infoMainFoto = { width: 180, rows: [
            { height: 3},
            { id: 'upFoto', template: $scope.noImage, height: 170, borderless: true, css: "byCenter"}
        ]};

        var _fotoBtns = { id: "fotoEditBtns"};

        _fotoBtns[width < 600 ? "cols" : "rows"] = [
            { view:"uploader",label: mcService.Lang(78), css: '', id: 'upLoadFoto',  autosend: false, upload: "", multiple: false, // "78" : "Загрузить фото",
                accept: ".jpg,.png,.jpeg", on : { onBeforeFileAdd: $scope.uploadFoto} },
            { view:"button",  label: mcService.Lang(79), css: 'button_danger', id: 'upClearFoto', click: $scope.clearFoto}  // "79" : "Очистить фото",
        ];

        infoMainFoto.rows.push(_fotoBtns);

        var infoMainDesc = [
            { view:"text",  id: 'upUIN',       value:$scope.data.UIN,       labelWidth: labelWidth,label:"UIN:", disabled: true},
            { view:"text",  id: 'upFirstName', value:$scope.data.FirstName, labelWidth: labelWidth,label:mcService.Lang(68),on:{onTimedKeyPress: $scope.change }, disabled: $scope.notMyProfile}, // "68" : "Имя:",
            { view:"text",  id: 'upMiddleName',value:$scope.data.MiddleName,labelWidth: labelWidth,label:mcService.Lang(69),on:{onTimedKeyPress: $scope.change }, disabled: $scope.notMyProfile}, // "69" : "Отчество:",
            { view:"text",  id: 'upLastName',  value:$scope.data.LastName,  labelWidth: labelWidth,label:mcService.Lang(70),on:{onTimedKeyPress: $scope.change }, disabled: $scope.notMyProfile}, // "70" : "Фамилия:",
            { view:"text",  id: 'upNick',      value:$scope.data.Nick,      labelWidth: labelWidth,label:mcService.Lang(57),on:{onTimedKeyPress: $scope.change }, disabled: $scope.notMyProfile}, // "57" : "Ник:",
            { view:"select",id: 'upSex',       value:$scope.data.Sex,       labelWidth: labelWidth,label:mcService.Lang(71),on:{onChange: $scope.change }, disabled: $scope.notMyProfile, options:_sex}, // "71" : "Пол:",
            { view:"text",  id: 'upEmail',     value:$scope.data.Email,     labelWidth: labelWidth,label:mcService.Lang(72),on:{onTimedKeyPress: $scope.change }, disabled: $scope.notMyProfile}  // "72" : "Основной E-mail:",
            //{ view: "text",   id: 'upRole',      value:$scope.data.Role,      labelWidth: labelWidth, label: mcService.Lang(73), disabled: true, css: "color54"}
        ];

        infoMain.rows.push({ cols: [
                { width: 15},
                { rows: infoMainDesc},
                infoMainFoto,
                { width: 5}
            ]});

        var systemInfo = { padding:14, rows: [
            {view:"text", id: 'upCompNetName', value:$scope.data.CompNetName,disabled:true,hidden:!$scope.data.CompNetName,labelWidth:labelWidth,label: mcLang(116)}, // "116": "Компьютер",
            {view:"text", id: 'upIP',          value:$scope.data.IP,         disabled:true,hidden:!$scope.data.IP,         labelWidth:labelWidth,label: mcLang(115)},// "115": "IP адрес",
            {view:"text", id: 'upMAC',         value:$scope.data.MAC,        disabled:true,hidden:!$scope.data.MAC,        labelWidth:labelWidth,label: mcLang(114)},// "114": "MAC адрес",
            {view:"text", id: 'upLastAccess',  value:$scope.data.LastAccess, disabled:true,hidden:!$scope.data.LastAccess, labelWidth:labelWidth*2,label: mcLang(113)}  // "113": "Последнее подключение",
        ]};

        var workInfo = { header:mcService.Lang(127), collapsed: true, css: "prInp", body: { rows: [ // "127": "Информация о компании (организации)",
            { height: 7 },

            __textInput('WorkCompanyName',118, 126, $scope.change, $scope.notMyProfile),
            __textInput('WorkPosition',    '', 124, $scope.change, true, !$scope.data.WorkPosition),
            __textInput('WorkDept',        '', 123, $scope.change, true, !$scope.data.WorkDept),
            __textInput('WorkOffice',     118, 122, $scope.change, $scope.notMyProfile, $scope.notMyProfile && !$scope.data.WorkOffice),
            __textInput('WorkPhone',      118, 121, $scope.change, $scope.notMyProfile, $scope.notMyProfile && !$scope.data.WorkPhone),
            __textInput('WorkFax',        118, 120, $scope.change, $scope.notMyProfile, $scope.notMyProfile && !$scope.data.WorkFax),
            __textInput('WorkPager',      118, 119, $scope.change, $scope.notMyProfile, $scope.notMyProfile && !$scope.data.WorkPager),

            __textInput('WorkCity',         118, 164, $scope.change, $scope.notMyProfile, $scope.notMyProfile && !$scope.data.WorkCity),
            __textInput('WorkStreetAddress',118, 163, $scope.change, $scope.notMyProfile, $scope.notMyProfile && !$scope.data.WorkStreetAddress),
            __textInput('WorkState',        118, 165, $scope.change, $scope.notMyProfile, $scope.notMyProfile && !$scope.data.WorkState),
            __textInput('WorkZIP',          118, 166, $scope.change, $scope.notMyProfile, $scope.notMyProfile && !$scope.data.WorkZIP),

            { view:"select",
                id           : 'upWorkCountry',
                value        : $scope.data.WorkCountry,
                labelPosition: 'top',
                label        : mcLang(167), // "167":"Страна",
                on           : { onChange: $scope.change },
                options      : mcService.GetCountriesList(),
                css          : "noBGAll",
                disabled     : $scope.notMyProfile,
                hidden       : $scope.notMyProfile && !$scope.data.WorkZIP
            },

            __textInput('WorkWWW',     118, 178, $scope.change, $scope.notMyProfile, $scope.notMyProfile && !$scope.data.WorkWWW),

            {height: 10}
        ]}};

        var peronalInfo = {header:mcService.Lang(148), collapsed: true, css: "prInp", body: { rows: [ // "148":"Личная информация",
            {height: 7},
            {view:"datepicker",
                id           : 'upBirthday',
                value        : $scope.data.Birthday,
                labelPosition: 'top',
                placeholder  : mcLang(118),
                label        : mcLang(149) + ":", on:{ onChange: $scope.change }, // "149":"Дата рождения:",
                disabled     : $scope.notMyProfile,
                hidden       : $scope.notMyProfile && !$scope.data.Birthday,
                suggest: {
                    type:"calendar",
                    body: {
                        minDate: new Date("1900.01.01"),
                        maxDate: new Date("3000.01.01")
                    }
                }
            },

            {view:"select",
                id           : 'upMaritalStatus',
                value        : $scope.data.MaritalStatus,
                labelPosition: 'top',
                label        : mcLang(150) + ":",
                on           : { onChange: $scope.change },
                options      : mcService.GetMaritalStatusList(),
                css          : "noBGAll",
                disabled     : $scope.notMyProfile,
                hidden       : $scope.notMyProfile && !$scope.data.MaritalStatus
            },

            __textInput('HomePhone',        118, 159, $scope.change, $scope.notMyProfile, $scope.notMyProfile && !$scope.data.HomePhone),
            __textInput('HomeFax',          118, 160, $scope.change, $scope.notMyProfile, $scope.notMyProfile && !$scope.data.HomeFax),
            __textInput('HomeCellular',     118, 161, $scope.change, $scope.notMyProfile, $scope.notMyProfile && !$scope.data.HomeCellular),
            __textInput('HomeStreetAddress',118, 163, $scope.change, $scope.notMyProfile, $scope.notMyProfile && !$scope.data.HomeStreetAddress),
            __textInput('HomeCity',         118, 164, $scope.change, $scope.notMyProfile, $scope.notMyProfile && !$scope.data.HomeCity),
            __textInput('HomeState',        118, 165, $scope.change, $scope.notMyProfile, $scope.notMyProfile && !$scope.data.HomeState),
            __textInput('HomeZIP',          118, 166, $scope.change, $scope.notMyProfile, $scope.notMyProfile && !$scope.data.HomeZIP),

            {view:"select",
                id           : 'upHomeCountry',
                value        : $scope.data.HomeCountry,
                labelPosition: 'top',
                label        : mcLang(167), // "167":"Страна",
                on           : { onChange: $scope.change },
                options      : mcService.GetCountriesList(),
                css          : "noBGAll",
                disabled     : $scope.notMyProfile,
                hidden       : $scope.notMyProfile && !$scope.data.HomeCountry
            },

            __textInput('HomeWWW',          118, 168, $scope.change, $scope.notMyProfile, $scope.notMyProfile && !$scope.data.HomeWWW),

            {height: 10}
        ]}};

        //===============================================

        var otherInfoAccordion = { cols: [
            { width: 5},{
                view : "accordion",
                multi: true,
                borderless: true,
                css: "headerAccordion",
                rows : [workInfo, peronalInfo]
            }, { width: 11}
        ]};

        infoMain.rows.push({height: 7});
        infoMain.rows.push(systemInfo);
        infoMain.rows.push({height: 7});
        infoMain.rows.push(otherInfoAccordion);
        infoMain.rows.push({height: 7});

        // ==========================================

        $$($scope.container).addView({
            id   : $scope.Name,
            css  : "color54",
            rows : [
                { css: "header", cols: [
                    { view: "button", type: "icon", icon: "arrow-left", label: mcService.Lang(63), width: 140, css: "headerBtn whiteBG", // "63" :"Назад",
                        click: $scope.closeProfile
                    },

                    // { view: "template", template: mcLang(586), autoheight: true, borderless: true, height: 34, css: "byCenter"}, // "586":"Протоколы",

                    { id: "profileHeaderDisplayName", view: "template", template: $scope.displayName, autoheight: true, borderless: true, height: 34, css: "byCenter myScroll"},

                    { view: "button", id: "saveBtn" + $scope.Name, type: "icon", icon: "check", label: mcService.Lang(77), click: $scope.saveProfile, // "77" : "Сохранить",
                        css: "headerBtn", width: 140, hidden: true
                    }
                ]},

                { height: 3, css: "whiteBG"},

                { view: "scrollview", body: infoMain }
            ]
        });

        _view = $$($scope.Name);

        //=============================================

        $scope.uFoto   = $$("upFoto");
        $scope.saveBtn = $$("saveBtn" + $scope.Name);
        $scope.profileHeaderDisplayName = $$("profileHeaderDisplayName");
        $scope.fotoEditBtns = $$("fotoEditBtns");

        if (isMobile){
            $$("profileBody" + $scope.Name).$view.id = "_profileBody" + $scope.Name;

            var viewer = new TouchScroll();

            viewer.init({
                id: "_profileBody" + $scope.Name,
                draggable: true,
                wait: false
            });
        }
    } else {
        _view.show();
    }

    return _view;
}"use strict";

function userProfileController($scope, $rootScope){
    $scope.Name = mcConst.dataModels.UserProfile;
    $scope.userData = null;
    $scope.noImage  = '<img id="upFotoCanvas" src="' + mcConst.imagesPath.all + 'noimage.png" border="0">';
    $scope.displayName = "";

    var _view     = null;

    // ===================================================

    $scope.registerHotKeys = function () {
        $rootScope.hotKeyDispatcher.addPreset($scope.Name, [{
            key   : mcConst.keyCodes.esc,
            lockPrev: true,
            func  : $scope.closeProfile
        }], document);
    };

    $scope.removeHotKeys = function () {
        $rootScope.hotKeyDispatcher.removePreset($scope.Name);
    };

    $scope.drawFoto = function(fotoData){
        if (fotoData && fotoData.CRC32){
            $scope.uFoto.define('template', '<img id="uFotoCanvas" src="data:image/jpg;base64,' + fotoData.Foto +'">');
        } else {
            $scope.uFoto.define('template', $scope.noImage);
        }

        $scope.uFoto.refresh();
    };

    $scope.clearFoto = function(){
        webix.confirm({
            type  : "confirm-warning",
            text  : mcService.Lang(553), // "553":"Удалить фотографию?",
            ok    : mcService.Lang(519), // "519":"Удалить",
            cancel: mcService.Lang(33),  // "33" :"Отмена",
            callback:function(yes){
                if (yes){
                    $rootScope.$broadcast('SendCMDToServer', [
                        mcConst._CMD_.cs_set_uin_foto,
                        mcConst.SessionID,
                        ""
                    ]);

                    $$('upFoto').define('template', '<img id="upFotoCanvas" src="" border="0">');
                    $$('upFoto').refresh();

                    webix.message(mcService.Lang(554)); // "554":"Фото удалено",
                }
            }
        });
    };

    $scope.uploadFoto = function(item){
        var file = item.file;
        var type = item.type.toLowerCase();
        var res  = true;

        if(file && (type == "jpg" || type == "png")){
            $rootScope.$broadcast(mcConst.lockInterface, []);

            var reader = new FileReader(); // We need to use a FileReader to actually read the file.

            reader.onload = function(event){
                $$('upFoto').define('template', '<canvas id="upFotoCanvas" height="' + mcConst.userFoto.h + '" width="' + mcConst.userFoto.w + '"></canvas>');
                $$('upFoto').refresh();

                var img = new Image();

                img.src = event.target.result;

                img.onload = function(){
                    var _canvas = document.createElement('canvas');
                    var resized = document.getElementById('upFotoCanvas');

                    _canvas.width  = img.width;
                    _canvas.height = img.height;

                    if ((_canvas.height <= mcConst.userFoto.h) && (_canvas.width <= mcConst.userFoto.w)){
                        resized.width  = _canvas.width;
                        resized.height = _canvas.height;
                    } else
                    if (_canvas.width >= _canvas.height) {
                        resized.width  = mcConst.userFoto.w;
                        resized.height = _canvas.height / (_canvas.width / mcConst.userFoto.w);
                    } else {
                        resized.width  = _canvas.width / (_canvas.height / mcConst.userFoto.h);
                        resized.height = mcConst.userFoto.h;
                    }

                    var ctx = _canvas.getContext('2d');

                    ctx.fillStyle = '#fff';
                    ctx.fillRect(0, 0, _canvas.width, _canvas.height);
                    ctx.drawImage(img, 0, 0, img.width, img.height);

                    canvasResize(_canvas, resized, function(){
                        $rootScope.$broadcast('SendCMDToServer', [
                            mcConst._CMD_.cs_set_uin_foto,
                            mcConst.SessionID,
                            resized.toDataURL('image/jpeg').replace('data:image/jpeg;base64,', '')
                        ]);

                        $rootScope.$broadcast('hide' + mcConst.lockInterface, []);
                    });
                };
            };

            reader.onerror = function(){ // err
                $rootScope.$broadcast('ErrorMsg', ['client', mcService.Lang(555) + file.name]); // "555":"Ошибка чтения файла: ",

                $rootScope.$broadcast('hide' + mcConst.lockInterface, []); // unlock

                res = false;
            };

            reader.readAsDataURL(file);
        } else {
            $rootScope.$broadcast('ErrorMsg', ['client', mcService.Lang(555) + file.name]); // "555":"Ошибка чтения файла: ",

            $rootScope.$broadcast('hide' + mcConst.lockInterface, []); // unlock

            res = false;
        }

        if (!res) {
            return res;
        }
    };
    
    $scope.closeProfile = function () {
        $rootScope.$broadcast("changeCenterView");
    };

    $scope.saveProfile = function(){
        $scope.data.Birthday = mcService.formatDate($scope.data.Birthday, 'dd.mm.yyyy');

        $rootScope.$broadcast('SendCMDToServer' , [
            mcConst._CMD_.cs_set_uin_info,
            mcConst.SessionID,
            JSON.stringify($scope.data)
        ]);

        webix.alert(mcLang(117)); // "117": "Изменения сохранены",

        if (!$scope.notMyProfile){
            $scope.saveBtn.hide();
        }
    };

    $scope.change = function(){
        var id  = this.data.id.toString().replace(/^up/, '');
        var val = this.getValue();

        if (mcService.isString(val)){
            val = mcService.trim(val.replace(/\u2022|\u0002|\u0003|\u000b|\r|\n/g, ""));
            
            if (!val){
                $scope.data[id] = val;
            }
        } else {
            $scope.data[id] = val;
        }

        if (!$scope.notMyProfile) {
            $scope.saveBtn.show();
        }
    };

    $scope.getData = function(uin){
        var task = new mcService.TaskList();

        task.AddTask(function () {
            $rootScope.$broadcast('SendCMDToServer' , [
                mcConst.lockInterface,
                mcConst._CMD_.cs_get_uin_info,
                mcConst.SessionID,
                uin,

                function (data) {
                    $scope.data = data;

                    task.Next();
                }
            ]);
        });

        task.AddTask(function () {
            $rootScope.$broadcast('SendCMDToServer', [
                mcConst._CMD_.cs_get_uin_foto,
                mcConst.SessionID,
                $scope.data.UIN,

                function (foto) {
                    $scope.show();

                    $scope.drawFoto(foto);
                }
            ]);
        });

        task.Run();
    };

    $scope.show = function(){
        $scope.notMyProfile = $scope.data.UIN != mcConst.UserInfo.UIN;
        $scope.displayName  = $scope.data.DisplayNick || mcConst.UserInfo.Nick;

        _view = initUserProfile($scope);

        Object.keys($scope.data).forEach(function (item) {
            var elem = $$('up' + item);

            if (elem && elem.setValue){
                elem.setValue($scope.data[item]);

                if (["CompNetName", "IP", "MAC", "LastAccess", "UIN"].indexOf(item) === -1){
                    elem[$scope.notMyProfile ? "disable" : "enable"]();
                }
            }
        });

        $scope.saveBtn.hide();

        $scope.fotoEditBtns[$scope.notMyProfile ? "hide" : "show"]();

        $scope.profileHeaderDisplayName.define('template', $scope.displayName);
        $scope.profileHeaderDisplayName.refresh();
    };

    // ====================================================

    $scope.$on('onGetUserProfileInfo', function(e, args){
        $scope.data = args[0];

        $rootScope.$broadcast('SendCMDToServer', [
            mcConst._CMD_.cs_get_uin_foto,
            mcConst.SessionID,
            $scope.data.UIN,

            function (foto) {
                $scope.show();

                $scope.drawFoto(foto);
            }
        ]);
    });

    $scope.$on('hide' + $scope.Name, function(){
        _view.hide();
        
        $scope.removeHotKeys();
    });

    $scope.$on('show' + $scope.Name, function(e, args){
        $scope.container = args[0];

        $scope.wndSize = $rootScope.wndSize;

        $scope.getData(args[1] || mcConst.UserInfo.UIN);

        $scope.registerHotKeys();
    });

    $rootScope.$broadcast('windowResize', [function(w, h){
        if (isMobile && _view){
            _view.define('height', h);
            _view.resize();
            _view.resizeChildren();
        }
    }]);

}"use strict";

function initViewLogsFrame($scope){
    var view = $$($scope.Name);

    if (!view){
        $$($scope.container).addView({
            id   : $scope.Name,
            rows : [
                { css: "header", cols: [
                    { view: "template", template: mcLang(586), autoheight: true, borderless: true, height: 34, css: "byCenter myScroll"}, // "586":"Протоколы",
                    /*{ view: "button", id: "displayName" + $scope.Name, label: mcLang(586),
                        click: $scope.titleMenu, css: "whiteBG imgBtn button_info frameTopBtnCenter",
                        on: { onItemClick: function () {
                            var btn = this.getNode();

                            /!*setTimeout(function () {
                             $scope.clipPopupWindow.show(btn, {pos: 'bottom', x: 5, y: 10});
                             }, 100);*!/
                        }}
                    },*/

                    { id: "logsCalendar" + $scope.Name, view: "daterangepicker", css: "finger", value: {start: new Date(), end: new Date()},
                        on: { onChange: $scope.selectLogsRange },
                        suggest: {
                            view: "daterangesuggest",
                            body: { calendarCount: 1}
                        }
                    }
                ]},

                { id: "logsContent" + $scope.Name, view: "template", borderless: true, css: "selectable scrollMenu myScroll", scroll: false, template: '<div></div>', gravity: 3}
            ]
        });

        view = $$($scope.Name);

        // $scope.fileTree     = $$("fileTree" + $scope.Name);
        $scope.logsCalendar = $$("logsCalendar" + $scope.Name);
        $scope.logsContent  = $$("logsContent" + $scope.Name);
    } else {
        view.show();
    }

    return view;
}"use strict";

function viewLogsController($scope, $rootScope, mcPlaySound){
    $scope.Name = mcConst.dataModels.ViewLogs;

    var view   = null;
    var bakCss = "";

    // =====================================

    function addLogDay(text, dt) {
        var div = document.createElement('div');

        div.setAttribute('day', dt);

        text = text.replace(/\r\n/gi, '<br/>');
        
        div.className       = "monospaceAll font85 framePaddingР10";
        div.style.wordBreak = "break-word";
        div.innerHTML       = text;

        $scope.logsContent.$view.firstChild.appendChild(div);

        $scope.logsContent.$view.scrollTop = $scope.logsContent.$view.scrollHeight;
    }

    function clear() {
        $scope.logsContent.define('template', "<div></div>");
        $scope.logsContent.refresh();
    }

    function getLogs(from, to) {
        clear();

        $rootScope.$broadcast(window._messages_.clientData.sendCMDToElectron, [
            mcConst._CMD_.ce_get_logs_files,
            from,
            to,

            function (list) {
                Object.keys(list).forEach(function (day) {
                    addLogDay(list[day], day);
                });
            }
        ]);
    }

    // =====================================

    $scope.registerHotKeys = function () {
        // $rootScope.hotKeyDispatcher.addPreset(mcConst.dataModels.ViewLogs + "global", [{
        //     key   : mcConst.keyCodes.n,
        //     altKey: true,
        //     func  : $scope.addNewBBS
        // }], document);
    };

    $scope.selectLogsRange = function () {
        var dt   = $scope.logsCalendar.getValue();
        var from = dt.start;
        var to   = dt.end;

        getLogs(from, to);
    };

    $scope.removeHotKeys = function () {
        // $rootScope.hotKeyDispatcher.removePreset(mcConst.dataModels.ViewLogs + "global");
    };

    $scope.show = function(){
        view = initViewLogsFrame($scope);

        bakCss = $$($scope.container).getNode().className;
        
        $$($scope.container).getNode().className = "webix_view noMargin webix_layout_line";
    };

    $scope.getData = function () {
        $rootScope.$broadcast(window._messages_.clientData.sendCMDToElectron, [
            mcConst._CMD_.ce_get_logs_list,
            
            function (data) {
                var calendars = $scope.logsCalendar.getPopup().getBody().getChildViews()[0].getChildViews();
                var from      = new Date(data.minDate.split('.'));
                var to        = new Date(data.maxDate.split('.'));

                calendars[0].define("minDate", from);
                calendars[0].define("maxDate", to);

                getLogs(to, to);
            }
        ]);
    };

    //========================================

    var _msg = _messages_.VievLogs = {

    };

    $scope.$on('hide' + $scope.Name, function(){
        if (view && view.isVisible()) {
            $scope.removeHotKeys();

            view.hide();

            clear();

            $$($scope.container).getNode().className = bakCss;
        }
    });

    $scope.$on('show' + $scope.Name, function(e, args){
        $scope.container = args[0];

        $scope.show();

        $scope.getData();

        $scope.registerHotKeys();
    });
}"use strict";

function initSettingsView($scope){
    var view = $$($scope.Name);

    if (!view){
        var labelWidth     = 200;
        var blockWidth     = 600;
        var headerList     = {
            '1':  mcLang({id:591,  from: "admin"}), // "591":"Сетевые настройки",
            '2':  mcLang({id:1345, from: "admin"}), // "1345":"Настройки прокси",
            '3':  mcLang({id:1350, from: "admin"}), // "1350":"Общие",
            '4':  mcLang({id:1357, from: "admin"}), // "1357":"Окно чата",
            '5':  mcLang({id:1367, from: "admin"}), // "1367":"Показывать окно чата поверх всех окон",
            '6':  mcLang({id:1371, from: "admin"}), // "1371":"Формат даты/времени в протоколах сообщений",
            '7':  mcLang({id:1373, from: "admin"}), // "1373":"Информационные окошки в системном трее",
            '8':  mcLang({id:1336, from: "admin"}), // "1336":"Горчие клавиши",
            '9':  mcLang({id:1402, from: "admin"}), // "1402":"Звуки",
            '10': mcLang({id:29,   from: "admin"}), // "29" : "Сообщения",
            '11': mcLang({id:1430, from: "admin"}), // "1430":"Системные события",
            '12': mcLang({id:598,  from: "admin"}), // "598": "Протоколирование",
            '13': mcLang({id:1445, from: "admin"}), // "1445":"Загрузка истории сообщений в приват",
            '14': mcLang({id:1451, from: "admin"}), // "1451":"Максимальный размер истории сообщений в окне (штук)",
            '15': mcLang({id:838,  from: "admin"}), // "838":"Файлы",
            '16': mcLang({id:1461, from: "admin"}), // "1461":"Интерфейс клиаента чата",
            '17': mcLang({id:1464, from: "admin"}), // "1464":"Обновления",
            '18': mcLang({id:574,  from: "admin"}), // "574":"Дополнительно",
            '19': mcLang({id:1851, from: "admin"})  // "1851":"Звонки",
        };

        var __items = [
            // == "1350":"Общие" ==
            { rows: [
                { template: headerList['3'], head: 3, id: "rmctrlHeader3",  css: "dialogsHeader font115 byCenter white lHeight28", height: 28},

                { padding: 7, rows: [
                    // { id: "rcitm_GeneralWindowsStart", head: 3, view: "checkbox", labelRight: mcLang({id:1351, from: "admin"}), labelWidth: 0, value: "", css: "finger", on: { onChange: $scope.universalChanger}},
                    { id: "rcitm_GeneralConfirmExit",  head: 3, view: "checkbox", labelRight: mcLang({id:1352, from: "admin"}), labelWidth: 0, value: "", css: "finger", on: { onChange: $scope.universalChanger}},
                    { height: 10},
                    { id: "rcitm_GeneralMainWindow", head: 3, view: "radio", css: "finger paraPadding20", value: "0", vertical: true, label: mcLang({id:1353, from: "admin"}), labelPosition: "top", height: 100, options: [
                        { id: "0", value: mcLang({id:683, from: "admin"})},  // "683": "Ничего не делать",
                        { id: "1", value: mcLang({id:1355, from: "admin"})}, // "1355":"Прятать окно MyChat в трей после старта",
                        { id: "2", value: mcLang({id:1356, from: "admin"})}  // "1356":"Разворачивать главное окно на весь экран после старта",
                    ], on: { onChange: $scope.universalChanger}},
                    { height: 10},
                    { id: "rcitm_SpecialMessagesFontSize", head: 3, view: "radio", css: "finger paraPadding20", value: "0", vertical: true, label: mcLang({id:1664, from: "admin"}), labelPosition: "top", height: 120, options: [// "1664":"Размер шрифта для сообщений",
                        { id: "0", value: mcLang({id:1667, from: "admin"})}, // "1667":"маленький",
                        { id: "1", value: mcLang({id:1668, from: "admin"})}, // "1668":"обычный",
                        { id: "2", value: mcLang({id:1669, from: "admin"})}, // "1669":"большой",
                        { id: "3", value: mcLang({id:1670, from: "admin"})}  // "1670":"очень большой",
                    ], on: { onChange: $scope.universalChanger}},
                    { id: "rcitm_EventsTimeStamp", head: 4,  view: "checkbox", labelRight: mcLang({id:1372, from: "admin"}), labelWidth: 0, value: "", css: "finger", on: { onChange: $scope.universalChanger}},
                ]}
            ]},

            // == "1357":"Окно чата" ==
            { rows: [
                { template: headerList['4'], head: 4, id: "rmctrlHeader4",  css: "dialogsHeader font115 byCenter white lHeight28", height: 26},

                { padding: 7, rows: [
                    { id: "rcitm_GeneralShowSendButton", head: 4, view: "checkbox",  labelRight: mcLang({id:1358, from: "admin"}), labelWidth: 0, value: "", css: "finger", on: { onChange: $scope.universalChanger}},
                    { id: "rcitm_GeneralCtrlEnterSend", head: 4, view: "checkbox",  labelRight: mcLang({id:1359, from: "admin"}), labelWidth: 0, value: "", css: "finger", on: { onChange: $scope.universalChanger}},
                    { id: "rcitm_GeneralSpellCheck", head: 4, view: "checkbox",  labelRight: mcLang({id:1360, from: "admin"}), labelWidth: 0, value: "", css: "finger", on: { onChange: $scope.universalChanger}},
                    // { id: "rcitm_GeneralAutoHideMainWindow", head: 4, view: "checkbox",  labelRight: mcLang({id:1361, from: "admin"}), labelWidth: 0, value: "", css: "finger", on: { onChange: $scope.universalChanger}}, // "1361":"Автоматическое скрытие окна MyChat Client в трей при бездействии пользователя",
                    { id: "rcitm_GeneralDoubleClickPagesClose", head: 4, view: "checkbox",  labelRight: mcLang(614), labelWidth: 0, value: "", css: "finger", on: { onChange: $scope.universalChanger}} // "614":"Закрывать диалоги двойным щелчком мыши",
                ]}
            ]},

            // == "1367":"Показывать окно чата поверх всех окон", ==
            { rows: [
                { template: headerList['5'], head: 5, id: "rmctrlHeader5",  css: "dialogsHeader font115 byCenter white lHeight28", height: 26},

                { padding: 7, rows: [
                    { id: "rcitm_EventsPopupOnNewBBS", head: 5, view: "checkbox",  labelRight: mcLang({id:1368, from: "admin"}), labelWidth: 0, value: "", css: "finger", on: { onChange: $scope.universalChanger}},
                    { id: "rcitm_EventsPopupOnChannelMessage", head: 5, view: "checkbox",  labelRight: mcLang({id:1369, from: "admin"}), labelWidth: 0, value: "", css: "finger", on: { onChange: $scope.universalChanger}},
                    { id: "rcitm_EventsPopupOnPrivateMessage", head: 5, view: "checkbox",  labelRight: mcLang({id:1370, from: "admin"}), labelWidth: 0, value: "", css: "finger", on: { onChange: $scope.universalChanger}}
                ]}
            ]},

            // == "1373":"Информационные окошки в системном трее", ==
            { rows: [
                { template: headerList['7'], head: 7, id: "rmctrlHeader7",  css: "dialogsHeader font115 byCenter white lHeight28", height: 26},

                { padding: 7, rows: [
                    { id: "rcitm_EventsShowPopupTrayWindow", head: 7, view: "checkbox",  labelRight: mcLang({id:1374, from: "admin"}), labelWidth: 0, value: "", css: "finger", on: { onChange: $scope.universalChanger}},
                    { id: "rcitm_EventsTrayBBSMsg", head: 7, view: "checkbox",  labelRight: mcLang({id:1368, from: "admin"}), labelWidth: 0, value: "", css: "finger", on: { onChange: $scope.universalChanger}}, // "1368":"При новому повідомленні на дошці оголошень",
                    { id: "rcitm_EventsTrayChMsg", head: 7, view: "checkbox",  labelRight: mcLang({id:1369, from: "admin"}), labelWidth: 0, value: "", css: "finger", on: { onChange: $scope.universalChanger}}, // "1369":"При получении нового сообщения в конференциях",
                    { id: "rcitm_EventsTrayPvMsg", head: 7, view: "checkbox",  labelRight: mcLang({id:1370, from: "admin"}), labelWidth: 0, value: "", css: "finger", on: { onChange: $scope.universalChanger}}, // "1370":"При получении нового сообщения в привате",

                    { height: 10},

                    { head: 7,  cols: [
                        { id: "rcitm_EventsTrayDontHide", head: 7, view: "radio", value: "1", vertical: true, width: 300, label: mcLang({id:1334, from: "admin"}), labelPosition: "top", css: "finger paraPadding20", height: 70, options:[ // "1334":"Что делать со всплывающим окном?",
                            { id: "1", value: mcLang({id:1378, from: "admin"})}, // "1378":"Показывать и не прятать",
                            { id: "0", value: mcLang({id:1380, from: "admin"})} // "1380":"Скрывать после:",
                        ], on: { onChange: $scope.universalChanger}},

                        { rows: [
                            { height: 42},
                            
                            { cols: [
                                { id: "rcitm_EventsTrayWindowDuration", head: 7, view: "counter", value: 10, step: 1, min: 1, max: 999, width: 100, on: { onChange: $scope.universalChanger, onKeyPress: $scope.checkNumbers}},
                                { template: mcLang({id:1379, from: "admin"}), height: 38, autoheight: true, css: "lHeight38", borderless: true } // "1379":"секунд",
                            ]}
                        ]}
                    ]},
                    { id: "rcitm_EventsTrayBlinkOnTaskBar", head: 7, view: "checkbox",  labelRight: mcLang({id:1842, from: "admin"}), labelWidth: 0, value: "", css: "finger", on: { onChange: $scope.universalChanger}}, // "1370":"При получении нового сообщения в привате",
                ]}
            ]},

            // == "1402":"Звуки", ==
            { rows: [
                { template: headerList['9'], head: 9, id: "rmctrlHeader9",  css: "dialogsHeader font115 byCenter white lHeight28", height: 26},

                { padding: 7, rows: [

                    { id: "rcitm_SoundsAllSoundsOff", head: 9,  rows: [
                        { id: "sub_SoundsAllSoundsOff", head: 9, view: "checkbox", labelRight: mcLang({id:1403, from: "admin"}), labelWidth: 0, value: "", css: "finger", on: { onChange: $scope.universalChanger}} // "1403":"Включить все звуки",
                    ]},

                    { cols: [
                        { rows: [
                            { head: 9, view: "accordion", multi: true, rows: [
                                { id: "rcitm_SoundsAllSoundsOffCustom", view: "accordionitem", header: mcLang({id:1681, from: "admin"}), collapsed : true, body:{ padding: 7, rows: [
                                    { id: "rcitm_SoundsSndError", hidden: true, head: 9, view: "checkbox", labelRight: mcLang({id:1386, from: "admin"}), labelWidth: 0, value: "", css: "finger", on: { onChange: $scope.universalChanger}}, // "1386":"Ошибка",
                                    { id: "rcitm_SoundsSndJoin", head: 9, view: "checkbox", labelRight: mcLang({id:1404, from: "admin"}), labelWidth: 0, value: "", css: "finger", on: { onChange: $scope.universalChanger}}, // "1404":"Пользователь заходит в канал",
                                    { id: "rcitm_SoundsSndLeave", head: 9, view: "checkbox", labelRight: mcLang({id:1405, from: "admin"}), labelWidth: 0, value: "", css: "finger", on: { onChange: $scope.universalChanger}}, // "1405":"Пользователь покидает канал",
                                    { id: "rcitm_SoundsSndChat", head: 9, view: "checkbox", labelRight: mcLang({id:1406, from: "admin"}), labelWidth: 0, value: "", css: "finger", on: { onChange: $scope.universalChanger}}, // "1406":"Новое сообщение в канале",
                                    { id: "rcitm_SoundsSndStatus", hidden: true, head: 9, view: "checkbox", labelRight: mcLang({id:1407, from: "admin"}), labelWidth: 0, value: "", css: "finger", on: { onChange: $scope.universalChanger}}, // "1407":"Изменения в чате (смена ника, аватара, темы канала и т.д.)",
                                    { id: "rcitm_SoundsSndSignal", hidden: true, head: 9, view: "checkbox", labelRight: mcLang({id:1408, from: "admin"}), labelWidth: 0, value: "", css: "finger", on: { onChange: $scope.universalChanger}}, // "1408":"Сигнал",
                                    { id: "rcitm_SoundsSndChatType", head: 9, view: "checkbox", labelRight: mcLang({id:1409, from: "admin"}), labelWidth: 0, value: "", css: "finger", on: { onChange: $scope.universalChanger}}, // "1409":"Ввод текст",
                                    { id: "rcitm_SoundsSndChatBS", head: 9, view: "checkbox", labelRight: mcLang({id:1410, from: "admin"}), labelWidth: 0, value: "", css: "finger", on: { onChange: $scope.universalChanger}}, // "1410":"Правка текста (BS, Del)",
                                    { id: "rcitm_SoundsSndChatRet", head: 9, view: "checkbox", labelRight: mcLang({id:1411, from: "admin"}), labelWidth: 0, value: "", css: "finger", on: { onChange: $scope.universalChanger}}, // "1411":"Ввод текста (Enter)",
                                    { id: "rcitm_SoundsSndNewMsg", head: 9, view: "checkbox", labelRight: mcLang({id:1412, from: "admin"}), labelWidth: 0, value: "", css: "finger", on: { onChange: $scope.universalChanger}}, // "1412":"Новое сообщение на доске объявлений",
                                    { id: "rcitm_SoundsSndPrivate", head: 9, view: "checkbox", labelRight: mcLang({id:1413, from: "admin"}), labelWidth: 0, value: "", css: "finger", on: { onChange: $scope.universalChanger}}, // "1413":"Новое сообщение в привате",
                                    { id: "rcitm_SoundsSndBadWord", hidden: true, head: 9, view: "checkbox", labelRight: mcLang({id:1414, from: "admin"}), labelWidth: 0, value: "", css: "finger", on: { onChange: $scope.universalChanger}}, // "1414":"Плохие слова",
                                    { id: "rcitm_SoundsSndBroadcast", head: 9, view: "checkbox", labelRight: mcLang({id:1415, from: "admin"}), labelWidth: 0, value: "", css: "finger", on: { onChange: $scope.universalChanger}}, // "1415":"Новое оповещение",
                                    { id: "rcitm_SoundsSndScreenShot", head: 9, view: "checkbox", labelRight: mcLang({id:1416, from: "admin"}), labelWidth: 0, value: "", css: "finger", on: { onChange: $scope.universalChanger}}, // "1416":"Снимок экрана",
                                    { id: "rcitm_SoundsSndFilesExchangeRequest", head: 9, view: "checkbox", labelRight: mcLang({id:1417, from: "admin"}), labelWidth: 0, value: "", css: "finger", on: { onChange: $scope.universalChanger}}, // "1417":"Запрос на передачу файлов",
                                    { id: "rcitm_SoundsSndFilesExchangeDone", head: 9, view: "checkbox", labelRight: mcLang({id:1418, from: "admin"}), labelWidth: 0, value: "", css: "finger", on: { onChange: $scope.universalChanger}}, // "1418":"Передача файлов завершена",
                                    { id: "rcitm_SoundsSndMediaCall", head: 9, view: "checkbox", labelRight: mcLang({id:1419, from: "admin"}), labelWidth: 0, value: "", css: "finger", on: { onChange: $scope.universalChanger}}, // "1419":"Медиазвонок, сигнал вызова",
                                    { id: "rcitm_SoundsSndMediaBusy", head: 9, view: "checkbox", labelRight: mcLang({id:1420, from: "admin"}), labelWidth: 0, value: "", css: "finger", on: { onChange: $scope.universalChanger}}, // "1420":"Медиазвонок, сигнал \"занято\"",
                                    { id: "rcitm_SoundsSndMediaCallReject", head: 9, view: "checkbox", labelRight: mcLang({id:1421, from: "admin"}), labelWidth: 0, value: "", css: "finger", on: { onChange: $scope.universalChanger}}, // "1421":"Медиазвонок, обрыв связи",
                                    { id: "rcitm_SoundsSndMediaIncomingCall", head: 9, view: "checkbox", labelRight: mcLang({id:1422, from: "admin"}), labelWidth: 0, value: "", css: "finger", on: { onChange: $scope.universalChanger}}, // "1422":"Медиазвонок, входящий звонок",
                                    { id: "rcitm_SoundsSndMediaEndCall", head: 9, view: "checkbox", labelRight: mcLang({id:1423, from: "admin"}), labelWidth: 0, value: "", css: "finger", on: { onChange: $scope.universalChanger}}  // "1423":"Медиазвонок, конец связи",
                                ]}},
                                
                                { id: "rcitm_SoundsFilesCustom", hidden: true, view: "accordionitem", header: mcLang({id:1694, from: "admin"}), collapsed : true, body:{ padding: 7, rows: [
                                    { id: "rcitm_SoundsSndErrorFile", hidden: true, head: 9, view: "text", label: mcLang({id:1702, from: "admin"}), labelPosition: "top", value: "", css: "finger", on: { onChange: $scope.universalChanger}}, //"1702":"Файл звука сообщения об ошибке",
                                    { id: "rcitm_SoundsSndJoinFile", head: 9, view: "text", label: mcLang({id:1698, from: "admin"}), labelPosition: "top", value: "", css: "finger", on: { onChange: $scope.universalChanger}}, //"1698":"Файл звука пользователей, которые входят в конференцию",
                                    { id: "rcitm_SoundsSndLeaveFile", head: 9, view: "text", label: mcLang({id:1697, from: "admin"}), labelPosition: "top", value: "", css: "finger", on: { onChange: $scope.universalChanger}}, //"1697":"Файл звука пользователей, которые покидают конференцию",
                                    { id: "rcitm_SoundsSndChatFile", head: 9, view: "text", label: mcLang({id:1706, from: "admin"}), labelPosition: "top", value: "", css: "finger", on: { onChange: $scope.universalChanger}}, //"1706":"Файл звука сообщения в текстовой конференции",
                                    { id: "rcitm_SoundsSndStatusFile", hidden: true, head: 9, view: "text", label: mcLang({id:1701, from: "admin"}), labelPosition: "top", value: "", css: "finger", on: { onChange: $scope.universalChanger}}, //"1701":"Файл звука статусного сообщения",
                                    { id: "rcitm_SoundsSndSignalFile", hidden: true, head: 9, view: "text", label: mcLang({id:1705, from: "admin"}), labelPosition: "top", value: "", css: "finger", on: { onChange: $scope.universalChanger}}, //"1705":"Файл звука \"будильника\" в привате",
                                    { id: "rcitm_SoundsSndChatTypeFile", head: 9, view: "text", label: mcLang({id:1699, from: "admin"}), labelPosition: "top", value: "", css: "finger", on: { onChange: $scope.universalChanger}}, //"1699":"Файл звука набора сообщения",
                                    { id: "rcitm_SoundsSndChatBSFile", head: 9, view: "text", label: mcLang({id:1700, from: "admin"}), labelPosition: "top", value: "", css: "finger", on: { onChange: $scope.universalChanger}}, //"1700":"Файл звука нажатия BS либо Del при наборе сообщения",
                                    { id: "rcitm_SoundsSndChatRetFile", head: 9, view: "text", label: mcLang({id:1704, from: "admin"}), labelPosition: "top", value: "", css: "finger", on: { onChange: $scope.universalChanger}}, //"1704":"Файл звука нажатия \"Enter\" при отправке сообщеия в чат",
                                    { id: "rcitm_SoundsSndNewMsgFile", head: 9, view: "text", label: mcLang({id:1695, from: "admin"}), labelPosition: "top", value: "", css: "finger", on: { onChange: $scope.universalChanger}}, //"1695":"Файл звука нового сообщения на доске объявлений",
                                    { id: "rcitm_SoundsSndPrivateFile", head: 9, view: "text", label: mcLang({id:1703, from: "admin"}), labelPosition: "top", value: "", css: "finger", on: { onChange: $scope.universalChanger}}, //"1703":"Файл звука входящего приатного сообщения",
                                    { id: "rcitm_SoundsSndBadWordFile", hidden: true, head: 9, view: "text", label: mcLang({id:1696, from: "admin"}), labelPosition: "top", value: "", css: "finger", on: { onChange: $scope.universalChanger}}, //"1696":"Файл звука \"плохих слов\" фильтра нецензурных выражений",
                                    { id: "rcitm_SoundsSndBroadcastFile", head: 9, view: "text", label: mcLang({id:1707, from: "admin"}), labelPosition: "top", value: "", css: "finger", on: { onChange: $scope.universalChanger}}, //"1707":"Файл звука входящего оповещения",
                                    { id: "rcitm_SoundsSndScreenShotFile", head: 9, view: "text", label: mcLang({id:1708, from: "admin"}), labelPosition: "top", value: "", css: "finger", on: { onChange: $scope.universalChanger}}, //"1708":"Файл звука снятия скриншота",
                                    { id: "rcitm_SoundsSndFilesExchangeRequestFile", head: 9, view: "text", label: mcLang({id:1709, from: "admin"}), labelPosition: "top", value: "", css: "finger", on: { onChange: $scope.universalChanger}}, //"1709":"Файл звука запроса на передачу файлов",
                                    { id: "rcitm_SoundsSndFilesExchangeDoneFile", head: 9, view: "text", label: mcLang({id:1710, from: "admin"}), labelPosition: "top", value: "", css: "finger", on: { onChange: $scope.universalChanger}}, //"1710":"Файл звука окончания передачи файлов",
                                    { id: "rcitm_SoundsSndMediaBusyFile", head: 9, view: "text", label: mcLang({id:1711, from: "admin"}), labelPosition: "top", value: "", css: "finger", on: { onChange: $scope.universalChanger}}, //"1711":"Файл звука \"занято\" для медиа звонка",
                                    { id: "rcitm_SoundsSndMediaCallFile", head: 9, view: "text", label: mcLang({id:1712, from: "admin"}), labelPosition: "top", value: "", css: "finger", on: { onChange: $scope.universalChanger}}, //"1712":"Файл звука исходящего медиа звонка",
                                    { id: "rcitm_SoundsSndMediaCallRejectFile", head: 9, view: "text", label: mcLang({id:1713, from: "admin"}), labelPosition: "top", value: "", css: "finger", on: { onChange: $scope.universalChanger}}, //"1713":"Файл звука отмены входящего медиа звонка",
                                    { id: "rcitm_SoundsSndMediaEndCallFile", head: 9, view: "text", label: mcLang({id:1714, from: "admin"}), labelPosition: "top", value: "", css: "finger", on: { onChange: $scope.universalChanger}}, //"1714":"Файл звука окончания медиа звонка",
                                    { id: "rcitm_SoundsSndMediaIncomingCallFile", head: 9, view: "text", label: mcLang({id:1715, from: "admin"}), labelPosition: "top", value: "", css: "finger", on: { onChange: $scope.universalChanger}}  //"1715":"Файл звука входящего медиа звонка",
                                ]}}
                            ]}
                        ]},
                        { gravity: 0}
                    ]}
                ]}
            ]},

            // == "29" : "Сообщения", ==
            { rows: [
                { template: headerList['10'], head: 10, id: "rmctrlHeader10",  css: "dialogsHeader font115 byCenter white lHeight28", height: 26},

                { padding: 7, rows: [
                    { id: "rcitm_SysEventsShowImagesInChat", head: 10, view: "checkbox",  labelRight: mcLang({id:1425, from: "admin"}), labelWidth: 0, value: "", css: "finger", on: { onChange: $scope.universalChanger}}, // "1425":"Показывать изображения в тексте чата",

                    { id: "rcitm_SysEventsImagesThumbsSize", head: 10, view: "select",  label: mcLang({id:1822, from: "admin"}), labelWidth: 300, width: 500, value: "0", options: [ // "1822":"Размер миниатюр изображений в чате",
                        { id: "0", value: mcLang({id:1823, from: "admin"})}, // "1823":"маленькое (120х120)",
                        { id: "1", value: mcLang({id:1824, from: "admin"})}, // "1824":"обычное (150х150)",
                        { id: "2", value: mcLang({id:1825, from: "admin"})}  // "1825":"большое (200х200)",
                    ], on: { onChange: $scope.universalChanger}},

                    { id: "rcitm_SysEventsDisableEmotions", head: 10, view: "checkbox",  labelRight: mcLang({id:1427, from: "admin"}), labelWidth: 0, value: "", css: "finger", on: { onChange: $scope.universalChanger}} // "1427":"Использовать графические смайлики",
                ]}
            ]},

            // == "1445":"Автоматическая загрузка истории сообщений в окно", ==
            { rows: [
                { template: headerList['13'], head: 13, id: "rmctrlHeader13",  css: "dialogsHeader font115 byCenter white lHeight28", height: 26},

                { padding: 7, rows: [

                    { id: "rcitm_57", head: 13,  rows: [
                    { cols: [
                        { id: "rcitm_SysEventsLoadHistoryType", head: 13, view: "radio", value: "0", vertical: true, width: 300, label: mcLang({id:1449, from: "admin"}), labelPosition: "top", css: "finger paraPadding20", height: 70, options:[ // "1449":"Варианты загрузки истории сообщений",
                            { id: "0", value: mcLang({id:1446, from: "admin"})}, // "1446":"Не загружать историю сообщений",
                            { id: "1", value: mcLang({id:1447, from: "admin"})} // "1447":"Загружать последние N сообщений",

                        ], on: { onChange: $scope.universalChanger}},
                        { rows: [
                            { height: 42 },
                            { cols: [
                                { id: "rcitm_SysEventsHistory_1_Num", head: 13, view: "counter", value: 10, step: 1, min: 1, max: 999, width: 100, on: { onChange: $scope.universalChanger, onKeyPress: $scope.checkNumbers}},
                                { template: mcLang({ id: 1450, from: "admin" }), borderless: true, css: "lHeight38"} // "1450":"сообщений",
                            ]}
                        ]}
                    ]},
                    { cols: [
                        { width: 30},
                        { id: "rcitm_LoadHistoryToConf", head: 12, view: "checkbox", labelRight: mcLang({id:1880, from: "admin"}), labelWidth: 0, value: "", css: "finger", on: { onChange: $scope.universalChanger}} // "1880":"Загружать историю в конференции",
                    ]},
                    { cols: [
                        { width: 30},
                        { id: "rcitm_LoadHistoryToPrivate", head: 12, view: "checkbox", labelRight: mcLang({id:1881, from: "admin"}), labelWidth: 0, value: "", css: "finger", on: { onChange: $scope.universalChanger}} // "1881":"Загружать историю в приваты",
                    ]}
                ]}
                ]}
            ]},

            // == "838":"Файлы", ==
            { rows: [
                { template: headerList['15'], head: 15, id: "rmctrlHeader15",  css: "dialogsHeader font115 byCenter white lHeight28", height: 26},

                { padding: 7, rows: [
                    { id: "rcitm_63", head: 15,  cols: [
                        { id: "rcitm_SendFilesRandomPorts", head: 15, view: "radio", value: "1", vertical: true, width: 225, label: mcLang({id:1454, from: "admin"}), labelPosition: "top", css: "finger paraPadding20", height: 70, options:[ // "1454":"Порты для передачи файлов",
                            { id: "0", value: mcLang({id:1455, from: "admin"})}, // "1455":"Фиксированные",
                            { id: "1", value: mcLang({id:1456, from: "admin"})}  // "1456":"Случайные, из диапазона",
                        ], on: { onChange: $scope.universalChanger}},

                        { rows: [
                            { height: 7},
                            { cols: [
                                { id: "rcitm_SendFilesBasePort", head: 15, view: "counter", value: 10, step: 1, min: 1, max: 65000, width: 130, labelWidth: 30, label: "&nbsp;", on: { onChange: $scope.universalChanger, onKeyPress: $scope.checkNumbers}},
                                { id: "rcitm_SendFilesDataPort", head: 15, view: "counter", value: 10, step: 1, min: 1, max: 65000, width: 130, labelWidth: 30, label: "&nbsp;", on: { onChange: $scope.universalChanger, onKeyPress: $scope.checkNumbers}}
                            ]},
                            { cols: [
                                { id: "rcitm_SendFilesRandomPortStart", head: 15, view: "counter", value: 10, label: mcLang({id:1339, from: "admin"}), labelWidth: 30, step: 1, min: 1, max: 65000, width: 130, on: { onChange: $scope.universalChanger, onKeyPress: $scope.checkNumbers}}, // "1339":"от",
                                { id: "rcitm_SendFilesRandomPortEnd", head: 15, view: "counter", value: 10, label: mcLang({id:634, from: "admin"}),  labelWidth: 30, step: 1, min: 1, max: 65000, width: 130, on: { onChange: $scope.universalChanger, onKeyPress: $scope.checkNumbers} } // "634": "до",
                            ]}
                        ]}
                    ]},

                    { maxWidth: blockWidth, rows: [
                        { id: "rcitm_SendFilesInputFilesDir", head: 15,  view: "text", value: "", keyPressTimeout: 500, label: mcLang({id:1457, from: "admin"}), labelPosition: "top",
                            on: { onTimedKeyPress: $scope.universalChanger }} // "1457":"Сохранять файлы, которые присылают пользователи, в:",
                    ]}
                ]}
            ]},

            // == "1464":"Обновления", ==
            { hidden: true, rows: [
                { template: headerList['17'], head: 17, id: "rmctrlHeader17",  css: "dialogsHeader font115 byCenter white lHeight28", height: 26},

                { padding: 7, rows: [
                    { id: "rcitm_GeneralDailyUpdatesCheck", head: 17, view: "checkbox",  labelRight: mcLang({id:1465, from: "admin"}), labelWidth: 0, value: "", css: "finger", on: { onChange: $scope.universalChanger}}, // "1465":"Еженедельно проверять наличие новой верии MyChat",
                ]}
            ]},

            // == "1851":"Звонки", ==
            { rows: [
                { template: headerList['19'], head: 19, id: "rmctrlHeader19",  css: "dialogsHeader font115 byCenter white lHeight28", height: 26},

                { padding: 7, rows: [
                    { id: "rcitm_Transport", head: 19,   cols: [
                        { template: mcLang({id:1852, from: "admin"}), borderless: true, autoheight: true, width: 200}, // "1852":"Сетевой транспорт",
                        { id: "rcitm_MediaNetworkTransportTCP", head: 19, view: "checkbox", width: 60, labelRight: "TCP", labelWidth: 0, value: "", css: "finger", on: { onChange: $scope.universalChanger}},
                        { id: "rcitm_MediaNetworkTransportUDP", head: 19, view: "checkbox", width: 60, labelRight: "UDP", labelWidth: 0, value: "", css: "finger", on: { onChange: $scope.universalChanger}},
                        {}
                    ]},

                    { id: "rcitm_IceTransportPolicy", head: 19, view: "select",  label: mcLang({id:1856, from: "admin"}), labelWidth: 200, width: 500, value: "classic", options: [ //  "1856":"Метод связи",
                        { id: "relay", value: mcLang({id:1854, from: "admin"})}, // "1854":"Через сервер",
                        { id: "all",   value: mcLang({id:1855, from: "admin"})}  // "1855":"Напрямую и через сервер",
                    ], on: { onChange: $scope.universalChanger}}
                ]}
            ]},

            // == "574":"Дополнительно", ==
            { rows: [
                { template: headerList['18'], head: 18, id: "rmctrlHeader18",  css: "dialogsHeader font115 byCenter white lHeight28", height: 26},

                { padding: 7, rows: [
                    { id: "rcitm_AdditionalPrivateInfoFields", head: 18, view: "text",  label: mcLang({id:1470, from: "admin"}), labelPosition: "top", value: "", on: { onTimedKeyPress: $scope.universalChanger}}, // "1470":"Список информационных полей, которые показываются в приватном чате",
                    { id: "rcitm_AdditionalProgramCaption", head: 18, view: "text",  label: mcLang({id:1471, from: "admin"}), labelPosition: "top", value: "", on: { onTimedKeyPress: $scope.universalChanger}}, // "1471":"Заголовок программы",
                    { id: "rcitm_AdditionalSystemTrayText", head: 18, view: "text",  label: mcLang({id:1472, from: "admin"}), labelPosition: "top", value: "", on: { onTimedKeyPress: $scope.universalChanger}}  // "1472":"Хинт в системном лотке (трее)",
                ]}
            ]}
        ];

        $$($scope.container).addView({
            id   : $scope.Name,
            rows : [
                { view: "template", template: mcLang(15), autoheight: true, borderless: true, height: 34, css: "byCenter header"},

                { view: "scrollview", borderless: true, scroll: false, css: "scrollMenu myScroll", body: { padding: 0, css: "font14l", rows: [].concat(__items)}}
            ]
        });

        view = $$($scope.Name);

    } else {
        view.show();
    }

    return view;
}
"use strict";

function settingsController($scope, $rootScope){
    $scope.Name = mcConst.dataModels.Settings;

    var view   = null;
    var bakCss = "";
    var canChange = true;

    // ===================================== AutoLoadBroadcastFiles

    var conformity = {
        "EventsTrayDontHide" : {
            set : function(val){
                $$("rcitm_EventsTrayDontHide").setValue(mcService.convertBool(val));
            },
            get : function(){
                return mcService.convertIntToBool($$("rcitm_EventsTrayDontHide").getValue());
            }
        },
        "SendFilesRandomPorts" : {
            set : function(val){
                $$("rcitm_SendFilesRandomPorts").setValue(mcService.convertBool(val));
            },
            get : function(){
                return mcService.convertIntToBool($$("rcitm_SendFilesRandomPorts").getValue());
            }
        },
        "SoundsAllSoundsOff" : {
            set : function(val){
                $$("sub_SoundsAllSoundsOff").setValue(mcService.convertBool(val));
            },
            get : function(){
                return $$("rcitm_SoundsAllSoundsOff").config.hidden ? null : mcService.convertIntToBool($$("sub_SoundsAllSoundsOff").getValue());
            }
        },
        "SysEventsHistory_1_Num": {
            set : function(val){
                $$("rcitm_SysEventsHistory_1_Num").setValue(val);
            },
            get : function(){
                return $$("rcitm_SysEventsHistory_1_Num").getValue();
            }
        },
        "SysEventsLoadHistoryType": {
            set : function(val){
                $$("rcitm_SysEventsLoadHistoryType").setValue(mcService.convertBool(val));
            },
            get : function(){
                return $$("rcitm_SysEventsLoadHistoryType").getValue();
            }
        },
        "SendFilesInputFilesDir": {
            set : function(val){
                $$("rcitm_SendFilesInputFilesDir").setValue(val);
            },
            get : function(){
                return $$("rcitm_SendFilesInputFilesDir").getValue();
            }
        }
    };

    ["SendFilesBasePort","SendFilesDataPort","SendFilesRandomPortStart","SendFilesRandomPortEnd"].forEach(function(elem){
        conformity[elem] = {
            set : function(val){
                $$("rcitm_" + elem).setValue(val);
            },
            get : function(){
                return $$("rcitm_" + elem).getValue();
            }
        }
    });

    ["LoadHistoryToConf", "LoadHistoryToPrivate"].forEach(function(elem){
        conformity[elem] = {
            set : function(val){
                $$("rcitm_" + elem).setValue(mcService.convertBool(val));
            },
            get : function(){
                return $$("rcitm_57").config.hidden ? null : mcService.convertIntToBool($$("rcitm_" + elem).getValue());
            }
        };
    });

    ["MediaNetworkTransportTCP", "MediaNetworkTransportUDP"].forEach(function(elem){
        conformity[elem] = {
            set : function(val){
                $$("rcitm_" + elem).setValue(mcService.convertBool(val));
            },
            get : function(){
                return $$("rcitm_Transport").config.hidden ? null :  mcService.convertIntToBool($$("rcitm_" + elem).getValue());
            }
        };
    });

    ["SoundsSndError","SoundsSndJoin","SoundsSndLeave","SoundsSndChat","SoundsSndStatus","SoundsSndSignal",
        "SoundsSndChatType","SoundsSndChatBS","SoundsSndChatRet","SoundsSndNewMsg","SoundsSndPrivate",
        "SoundsSndBadWord","SoundsSndBroadcast","SoundsSndScreenShot","SoundsSndFilesExchangeRequest",
        "SoundsSndFilesExchangeDone","SoundsSndMediaCall","SoundsSndMediaBusy","SoundsSndMediaCallReject",
        "SoundsSndMediaIncomingCall","SoundsSndMediaEndCall"].forEach(function(elem){
        conformity[elem] = {
            set : function(val){
                $$("rcitm_" + elem).setValue(mcService.convertBool(val));
            },
            get : function(){
                return $$("rcitm_SoundsAllSoundsOffCustom").config.hidden ? null : mcService.convertIntToBool($$("rcitm_" + elem).getValue());
            }
        };
    });

    ["SoundsSndNewMsgFile","SoundsSndBadWordFile","SoundsSndLeaveFile","SoundsSndJoinFile","SoundsSndChatTypeFile",
        "SoundsSndChatBSFile","SoundsSndStatusFile","SoundsSndErrorFile","SoundsSndPrivateFile","SoundsSndChatRetFile",
        "SoundsSndSignalFile","SoundsSndChatFile","SoundsSndBroadcastFile","SoundsSndScreenShotFile",
        "SoundsSndFilesExchangeRequestFile","SoundsSndFilesExchangeDoneFile","SoundsSndMediaBusyFile","SoundsSndMediaCallFile",
        "SoundsSndMediaCallRejectFile","SoundsSndMediaEndCallFile","SoundsSndMediaIncomingCallFile"].forEach(function(elem){
        conformity[elem] = {
            set : function(val){
                $$("rcitm_" + elem).setValue(val);
            },
            get : function(){
                return $$("rcitm_SoundsFilesCustom").config.hidden ? null : $$("rcitm_" + elem).getValue();
            }
        };
    });

    // =====================================

    $scope.registerHotKeys = function () {
        // $rootScope.hotKeyDispatcher.addPreset(mcConst.dataModels.ViewLogs + "global", [{
        //     key   : mcConst.keyCodes.n,                                   
        //     altKey: true,
        //     func  : $scope.addNewBBS
        // }], document);
    };

    $scope.checkNumbers = function(code){
        if (this.config.view === "counter" && mcService.inArray(code, mcConst.keyCodes.Digits.concat(mcConst.keyCodes.EditSymbols)) === -1){
            return false;
        }
    };

    $scope.universalChanger = function () {
        var val     = null;
        var element = null;
        var changed = false;

        if (canChange){
            for (var item in mcConst.ClientSettings){
                val = null;

                if (conformity.hasOwnProperty(item)){
                    val = conformity[item].get();

                    if (val !== null && val != mcConst.ClientSettings[item]) {
                        mcConst.ClientSettings[item] = val;

                        changed = true;
                    }
                } else {
                    element = $$("rcitm_" + item);

                    if (element && !element.config.hidden){
                        if (element.config.view === "checkbox") {
                            val = mcService.convertIntToBool(element.getValue());
                        } else {
                            val = element.getValue();
                        }

                        if (val !== null && val != mcConst.ClientSettings[item]) {
                            mcConst.ClientSettings[item] = val;

                            changed = true;
                        }
                    }
                }
            }

            if (changed) {
                $rootScope.$broadcast(window._messages_.clientData.saveClientSettings);
            }
        }
    };

    $scope.removeHotKeys = function () {
        // $rootScope.hotKeyDispatcher.removePreset(mcConst.dataModels.ViewLogs + "global");
    };

    $scope.show = function(){
        view = initSettingsView($scope);

        bakCss = $$($scope.container).getNode().className;
        
        $$($scope.container).getNode().className = "webix_view noMargin webix_layout_line";
    };

    $scope.getData = function () {
        var element = null;

        canChange = false;

        Object.keys(mcConst.ClientSettings).forEach(function (stng) {
            if (conformity.hasOwnProperty(stng)) {
                conformity[stng].set(mcConst.ClientSettings[stng]);
            } else {
                element = $$("rcitm_" + stng);

                if (element && !element.config.hidden){
                    if (element.config.view === "checkbox") {
                        element.setValue(mcService.convertIntToBool(mcConst.ClientSettings[stng]));
                    } else {
                        element.setValue(mcConst.ClientSettings[stng]);
                    }
                }
            }
        });

        canChange = true;
    };

    //========================================

    var _msg = _messages_.Settings = {
        changeUserProfile   : 'changeUserProfile'
    };

    $scope.$on(_msg.changeUserProfile, function (e, args) {
        mcConst.ClientSettings = mcService.Marge(mcConst.ClientSettings, args[0]);

        $rootScope.$broadcast(window._messages_.clientData.saveClientSettings);

        $scope.getData();
    });

    $scope.$on('hide' + $scope.Name, function(){
        if (view && view.isVisible()) {
            $scope.removeHotKeys();

            view.hide();

            $$($scope.container).getNode().className = bakCss;
        }
    });

    $scope.$on('show' + $scope.Name, function(e, args){
        $scope.container = args[0];

        $scope.show();

        $scope.getData();

        $scope.registerHotKeys();
    });
}
"use strict";

function initUpdateWrapper($scope){
    var view = $$($scope.Name);

    if (view){
        view.destructor();
    }

    view = webix.ui({
        id       : $scope.Name,
        view     : "window",
        width    : 350,
        position : "center",
        head     : false,
        body     : { padding: 5, rows: [
            { template: "<div class='byCenter font115 lHeight36'>" + mcLang(613) + "</div>", borderless: true, autoheight: true, // "613":"Загрузка обновления...",
                on: {
                    onAfterRender: $scope.download
                }
            },
            
            $scope.duViews.progressWrapper
        ]}
    });

    view.show();

    return view;
}"use strict";

function updateController($scope, $rootScope){
    $scope.Name       = mcConst.dataModels.Update;
    $scope.containers = mcConst.containers;

    var view       = null;
    var serverInfo = {};
    var startDownloadUpdate   = false;
    var downloadUploadManager = new DownloadUploadManager($rootScope, function () {    });

    function hide() {
        startDownloadUpdate = false;

        if (view && view.isVisible()) {
            view.close();
        }
    }
    
    //================================================

    $scope.download = function(){
        startDownloadUpdate = true;

        downloadUploadManager.initViews();

        downloadUploadManager.downloadUrl(mcService.getLocalHostPath(false), {
            downloadUpdate: true
        }, true);
    };

    //================================================

    var _msg = window._messages_.clientUpdate = {
        DownloadClientUpdate        : "DownloadClientUpdate",
        on_file_download_aborted    : "on_file_download_aborted",
        on_file_download_complete   : "on_file_download_complete",
        on_file_download_file_no_found: "on_file_download_file_no_found"
    };

    $scope.$on(_msg.on_file_download_aborted, function(){
        if (startDownloadUpdate){
            $rootScope.$broadcast('show' + mcConst.dataModels.Login, []);
        }
    });
    $scope.$on(_msg.on_file_download_file_no_found, function(){
        if (startDownloadUpdate){
            $rootScope.$broadcast('ErrorMsg', [mcConst._CMD_.Errors.WrongServerVersion, mcConst.ErrorText[mcConst._CMD_.Errors.WrongServerVersion], '', function(){
                $rootScope.$broadcast('show' + mcConst.dataModels.Login, []);
            }]);
        }
    });
    
    $scope.$on(_msg.on_file_download_complete, function(){
        if (startDownloadUpdate){
            hide();

            $scope.$broadcast(window._messages_.clientData.sendCMDToElectron, [
                mcConst._CMD_.ce_restart_client
            ]);
        }
    });

    $scope.$on(_msg.DownloadClientUpdate, function(e, args){
        serverInfo = args[0];

        mcConst.UserInfo.PortNode = serverInfo.NodePort;
        mcConst.UserInfo.HTTPS    = serverInfo.HTTPS;

        $scope.duViews = downloadUploadManager.getViews();

        view = initUpdateWrapper($scope);
    });

    $scope.$on('hide' + $scope.Name, hide);
}
"use strict";

function initBroadcastView($scope, broadcasts){
    var view = $$($scope.Name);

    function numberList(length) {
        return (new Array(length || 1)).join('.').split('.').map(function (itm, idx) { return idx.toString() })
    }

    // Avatar      : 0,
    // DisplayName : "Andrey Rakov",
    // ID          : 428,
    // Sex         : 1,
    // State       : 0,
    // dtCreatedUTC: "22.06.2018.11.06.53",
    // files_list  : [],
    // msg         : "sdfsdf",
    // msg_type    : 0,
    // read_notify : true,
    // uinOwner    : 3

    if (!view){
        view = webix.ui({
            id      : $scope.Name,
            view    : "window",
            position: "center",
            modal   : true,
            width   : document.body.offsetWidth  - 40,
            height  : document.body.offsetHeight - 40,
            head    : false,
            body    : { padding: 5, rows: [
                { id: "brTitle", template: "&nbsp;", height: 38, css: "byCenter lHeight36"},

                { id: "brCntWrapper", cols: [
                    { id: "brUserList", view: "list", width: 200, select: true, minWidth: 200, maxWidth: 500,
                        type:{
                            height: 50
                        },
                        template: function (obj) {
                            return  mcService.myReplaceFormated(
                                "<div class='lHeight26'>" +
                                    "<div class='firstLineList'>#{name}</div>" +
                                    "<div>#{date}#{onlySee}#{confirm}#{reply}</div>" +
                                "</div>",
                                {
                                    name   : obj.DisplayName,
                                    date   : mcService.formatDate(mcService.utcTime(obj.dtCreatedUTC), "hh:nn dd.mm.yyyy"),
                                    onlySee: obj.msg_type === $scope.msgType.regular    ? " " + mcService.insertIco("fa-eye", " ") : "",
                                    confirm: obj.msg_type === $scope.msgType.needRead   ? " " + mcService.insertIco("fa-check-square-o", " ") : "",
                                    reply  : obj.msg_type === $scope.msgType.needAnswer ? " " + mcService.insertIco("fa-comments-o", " ") : ""
                                });
                        },
                        on: {
                            onAfterSelect : $scope.selectBroadcast,
                            onBeforeSelect: $scope.backupAnswer
                        }
                    },

                    { view: "resizer"},

                    { rows: [
                        { cols: [
                            { rows: [
                                $scope.dwlMngr.progressWrapper,

                                { id: "brMsgContent", template: "&nbsp;", css: "framePaddingAll10"},

                                { id: "brAnswerResizer", view: "resizer", hidden: true},
                                { id: "brAnswer", view: "textarea", css: "noBGColorAll", hidden: true, height: 60, placeholder: mcLang(621)}, // "621":"Введите здесь ответ на оповещение",

                                { rows: [
                                    { id: "brImReadMsgWrap", cols: [
                                        { id: "brImReadMsg", view: "checkbox", value: false, labelWidth: 0, labelRight: mcLang(607),  css: "finger", // "607":"Я прочитал сообщение",
                                            on: {onChange: $scope.readMsg}
                                        },
                                        {},
                                        { id: "brCloseWnd", view: "button", width: 150, value: mcLang(12), click: $scope.closeBroadcast} // "12" :"Закрыть",
                                    ]},

                                    { height: 20 }
                                ]}
                            ]},

                            { id: "brFilesResizer", view: "resizer"},

                            { id: "brFileListWrap", hidden: true, rows: [
                                { height: 3},
                                    
                                { id: "brFilesCount", template: mcLang(622), css: "byCenter", autoheight: true, borderless: true}, // "622":"Файлы",

                                { height: 3},

                                { id: "brFileList", view: "list", width: 200, select: false, minWidth: 200, maxWidth: 500, css: "lHeight17All font80 filesList",
                                    type:{
                                        height: "auto"
                                    },
                                    template: function (obj) {
                                        return mcService.myReplaceFormated(
                                            "<span class='bolder'>#{fName}</span><br><span class='gray'>#{sizeTitle}: #{size}</span>",
                                            {
                                                fName    : obj.OriginalFileName,
                                                size     : mcService.formatFileSize(obj.Size),
                                                sizeTitle: mcLang(590) // "590":"размер",
                                            }
                                        );
                                    },
                                    on: {
                                        onItemClick: $scope.downloadFile
                                    }
                                }
                            ]}
                        ]}
                    ]}
                ]}
            ]}
        });

        $scope.initDU();
    }

    broadcasts.forEach(function (itm) {
        itm.id = itm.ID;
    });

    $scope.brUserList      = $$("brUserList");
    $scope.brTitle         = $$("brTitle");
    $scope.brMsgContent    = $$("brMsgContent");
    $scope.brImReadMsgWrap = $$("brImReadMsgWrap");
    $scope.brImReadMsg     = $$("brImReadMsg");
    $scope.brCntWrapper    = $$("brCntWrapper");
    $scope.answerResizer   = $$("brAnswerResizer");
    $scope.answer          = $$("brAnswer");
    $scope.brFileListWrap  = $$("brFileListWrap");
    $scope.brFilesResizer  = $$("brFilesResizer");
    $scope.brFileList      = $$("brFileList");
    $scope.brFilesCount    = $$("brFilesCount");

    $scope.brUserList.parse(broadcasts);
    $scope.brUserList.select($scope.brUserList.getFirstId());

    view.show();

    return view;
}"use strict";

function broadcastController($scope, $rootScope, mcPlaySound){
    $scope.Name = mcConst.dataModels.Broadcast;

    var view               = null;
    var deferredLoadImages = new McDeferredLoadImages();
    var currentBrID        = null;
    var readBroadcasts     = {};
    var broadcasts         = [];
    var canChangeCkb       = true;
    var downloadUploadManager = null;

    $scope.msgType = {
        regular   : 0, // 0 - обычное оповещение,
        needRead  : 1, // 1 - оповещение обязательно к прочтению. Окошко у получателя не закроется, пока тот не подтвердит, что он действительно прочитал сообщение
        needAnswer: 2  // 2 - оповещение требует специального ответа от получателя, и не закроется, пока тот не даст ответ
    };

    function close() {
        var list     = mcService.ObjToString(readBroadcasts);
        var canClose = true;
        var notifyList = {};

        broadcasts.forEach(function (item) {
            if (!((item.msg_type === $scope.msgType.needRead   && readBroadcasts[item.ID] && readBroadcasts[item.ID].read) ||
                  (item.msg_type === $scope.msgType.needAnswer && readBroadcasts[item.ID] && readBroadcasts[item.ID].ReplyText) ||
                  (item.msg_type === $scope.msgType.regular    && readBroadcasts[item.ID])
                )) {
                
                $rootScope.$broadcast('ErrorMsg', [-1, mcLang(612), "", function(){ // "612":"Вы не прочитала все оповещения или не ответили",
                    
                }]);

                canClose = false;
            }

            if (item.read_notify){
                notifyList[item.ID] = {
                    UIN: item.uinOwner
                };
            }
        });

        if (canClose && $scope.brUserList){
            $rootScope.SendCMDToServer([
                mcConst._CMD_.cs_broadcast_just_readed,
                mcConst.SessionID,

                list
            ]);

            $rootScope.SendCMDToServer([
                mcConst._CMD_.cs_broadcast_readed_notify,
                mcConst.SessionID,

                mcService.ObjToString(notifyList)
            ]);

            if (view && view.isVisible()) {
                $scope.removeHotKeys();

                view.hide();
            }

            broadcasts     = [];
            readBroadcasts = {};
            currentBrID    = null;
            
            $scope.brUserList.clearAll();

            if (!$rootScope.isWebClient){
                $rootScope.$broadcast(window._messages_.clientData.sendCMDToElectron, [
                    mcConst._CMD_.ce_disable_always_on_top
                ]);
            }
        } else {

        }
    }

    // =====================================

    $scope.readMsg = function(val){
        if (currentBrID && canChangeCkb){
            readBroadcasts[currentBrID].read = mcService.convertIntToBool(val);
        }
    };

    $scope.registerHotKeys = function () {
        // $rootScope.hotKeyDispatcher.addPreset(mcConst.dataModels.Broadcast + "global", [{
        //     key   : mcConst.keyCodes.n,
        //     func  : function () {
        //
        //     }
        // }], document, true);
    };

    $scope.removeHotKeys = function () {
        // $rootScope.hotKeyDispatcher.removePreset(mcConst.dataModels.Broadcast + "global");
    };

    $scope.closeBroadcast = function () {
        var item = $scope.brUserList.getItem(currentBrID);

        if (readBroadcasts[currentBrID] && item && item.msg_type === $scope.msgType.needAnswer){
            readBroadcasts[currentBrID].ReplyText = $scope.answer.getValue();
        }

        close();
    };

    $scope.downloadFile = function(id){
        var item = $scope.brFileList.getItem(id);

        if (item && item.Hash){
            var broadcastItem = broadcasts[mcService.findItemInArrayOfObj(broadcasts, currentBrID, "ID")];
            var url           = mcService.getLocalHostPath($rootScope.isWebClient) + "/" + mcConst.pathAliases.AliasFiles + "/" + item.Hash + "/" + encodeURI(item.OriginalFileName);
            var fileInfo      = {
                uin        : broadcastItem.uinOwner,
                displayName: broadcastItem.DisplayName,
                filePath   : "",
                fileDT     : item.UTCWriteTime,
                hash       : item.Hash
            };

            if ($rootScope.isWebClient){
                // window.open(url);
            } else {
                downloadUploadManager.openDownloadUrl(url, fileInfo);
            }
        }
    };

    $scope.selectBroadcast = function (id) {
        var item = $scope.brUserList.getItem(id);

        canChangeCkb = false;
        currentBrID  = id;

        $scope.brTitle     .define("template", mcLang(611) + item.DisplayName + " <span class='Gray monospaceAll'>" + mcService.formatDate(mcService.utcTime(item.dtCreatedUTC), "[hh:nn dd.mm.yyyy]") + "</span>"); // "611":"Оповещение от: ",
        $scope.brMsgContent.define("template", item.msg.split('L$').join("<br>"));

        $scope.brTitle     .refresh();
        $scope.brMsgContent.refresh();

        $scope.brImReadMsg   [item.msg_type === $scope.msgType.needRead   ? "show" : "hide"]();
        $scope.answerResizer [item.msg_type === $scope.msgType.needAnswer ? "show" : "hide"]();
        $scope.answer        [item.msg_type === $scope.msgType.needAnswer ? "show" : "hide"]();
        $scope.brFileListWrap[item.files_list && item.files_list.length ? "show" : "hide"]();
        $scope.brFilesResizer[item.files_list && item.files_list.length ? "show" : "hide"]();

        $scope.brFileList.clearAll();
        $scope.currentFilesCount = 0;

        if (item.files_list){
            $scope.brFileList.parse(item.files_list);
            $scope.currentFilesCount = item.files_list.length;

            $scope.brFilesCount.define("template", mcLang(622) + " [" + $scope.currentFilesCount + "]");
            $scope.brFilesCount.refresh();
        }

        if (!readBroadcasts.hasOwnProperty(currentBrID)){
            readBroadcasts[currentBrID] = {
                ReplyText: "",
            };
        }

        if (item.msg_type === $scope.msgType.needRead) {
            $scope.brImReadMsg.setValue(readBroadcasts[currentBrID].read);
        } else
        if (item.msg_type === $scope.msgType.needAnswer){
            $scope.answer.setValue(readBroadcasts[currentBrID].ReplyText);
        }

        canChangeCkb = true;
    };

    $scope.backupAnswer = function () {
        var item = $scope.brUserList.getItem(currentBrID);

        if (readBroadcasts[currentBrID] && item && item.msg_type === $scope.msgType.needAnswer){
            readBroadcasts[currentBrID].ReplyText = $scope.answer.getValue();

            $scope.answer.setValue("");
        }
    };

    $scope.show = function(_broadcasts){
        broadcasts = _broadcasts;

        if (!downloadUploadManager){
            downloadUploadManager = new DownloadUploadManager($rootScope, function (chatType, ID, info, Type, fType) {
                    
            });

            $scope.initDU     = downloadUploadManager.initViews;
            $scope.dwlMngr    = downloadUploadManager.getViews(mcLang(33)); // "33" :"Отмена",
        }

        view = initBroadcastView($scope, broadcasts);
    };

    //========================================

    var _msg = _messages_.Broadcast = {
        onReceiveBroadcast  : 'onReceiveBroadcast'
    };

    $scope.$on(_msg.onReceiveBroadcast, function (e, args) {
        $scope.show.apply(null, args);

        $scope.registerHotKeys();
    });

    $scope.$on('hide' + $scope.Name, function(){
        close();
    });
}

"use strict";

function initSendBroadcastView($scope, broadcasts){
    var view = $$($scope.Name);

    function numberList(length) {
        return (new Array(length || 1)).join('.').split('.').map(function (itm, idx) { return idx.toString() })
    }

    if (!view){
        view = webix.ui({
            id      : $scope.Name,
            view    : "window",
            position: "center",
            modal   : true,
            width   : document.body.offsetWidth  - 60,
            height  : document.body.offsetHeight - 60,
            head    : false,
            body    : { rows: [
                { template: res, borderless: true, scroll: "y" },
                { view: "button", value: mcLang(12), click: function(){
                    this.getTopParentView().hide();
                    this.getTopParentView().destructor();
                }} //"12" : "Закрыть",
            ]}
        });
    }

    view.show();

    return view;
}"use strict";

function sendBroadcastController($scope, $rootScope, mcPlaySound){
    $scope.Name = mcConst.dataModels.Broadcast;

    var view  = null;
    var deferredLoadImages = new McDeferredLoadImages();

    // =====================================

    $scope.registerHotKeys = function () {
        $rootScope.hotKeyDispatcher.addPreset(mcConst.dataModels.BBS, [{
            key   : mcConst.keyCodes.enter,
            func  : $scope.sendText
        }, {
            key   : mcConst.keyCodes.esc,
            func  : $scope.closeBBS
        }], $scope.enterBBSText.getNode());

        $rootScope.hotKeyDispatcher.addPreset(mcConst.dataModels.BBS + "global", [{
            key   : mcConst.keyCodes.n,
            altKey: true,
            func  : $scope.addNewBBS
        }], document);
    };

    $scope.removeHotKeys = function () {
        $rootScope.hotKeyDispatcher.removePreset(mcConst.dataModels.BBS);
        $rootScope.hotKeyDispatcher.removePreset(mcConst.dataModels.BBS + "global");
    };

    $scope.addNewBroadcast = function () {
        $scope.inputWrapper.show();
        $scope.bbsResizer.show();

        $scope.enterBBSText.focus();
    };

    $scope.closeBroadcast = function () {
        $scope.inputWrapper.hide();
        $scope.bbsResizer.hide();

        setTimeout(function(){
            $scope.enterBBSText.setValue('');
            $scope.enterBBSText.$setValue('');
            $scope.enterBBSText.focus();
        }, 10);
    };

    $scope.sendBroadcast = function () {
        var msg    = mcService.trim($scope.enterBBSText.getValue());
        var expire = mcService.formatDate($scope.bbsLifeTime.getValue(), "dd.mm.yyyy.") +
                     $scope.bbsHours.getValue() + "." + $scope.bbsMinutes.getValue() + ".00";
        var sticky = mcService.convertIntToBool($scope.bbsToTop.getValue());

        if ($rootScope.isWebClient || mcConst.ClientSettings.SoundsSndChatRet) {
            mcPlaySound.PlaySound(mcPlaySound.Sounds.EnterBtn);
        }

        if (msg !== ''){
            msg = msg.replace(/\n/g, '\r\n');

            $rootScope.SendCMDToServer([
                mcConst._CMD_.cs_add_new_bbs,
                mcConst.SessionID,
                JSON.stringify({
                    Expired: expire, // 12.01.2013.14.15.00 до какого времени объявление будет актуально
                    Sticky : sticky, // Sticky "прилепленное" объявление (в самом верху) или обычное
                    Msg    : msg     // содержимое объявления
                })
            ]);

            setTimeout($scope.closeBBS, 50);
        }

        return false;
    };

    $scope.show = function(broadcasts){
        view = initBroadcastView($scope, broadcasts);
    };

    $scope.getData = function (showNotify) {
        $rootScope.SendCMDToServer([
            mcConst._CMD_.cs_get_bbs,
            mcConst.SessionID,
            function (listBBS) {
                $scope.bbsContent.getNode().firstChild.innerHTML = "&nbsp;";
                
                if (listBBS && listBBS.length > 0){
                    var sticked = [];
                    var ordinary = [];
                    var first = listBBS[0];

                    if (showNotify && first){
                        var text = first.Msg.replace(/\u041e\u00ac/g, "");
                        var textForNotify = text.slice(0, 100) + ((text.length > 100) ? '...' : "" );

                        $rootScope.$broadcast('sendCMDToElectron', [
                            mcConst._CMD_.ce_show_notify,

                            first.DisplayName.slice(0, 30) + ((first.DisplayName.length > 30) ? '..' : "" ) + ":",
                            textForNotify,
                            first.ID
                        ]);
                    }

                    listBBS.forEach(function (bbs) {
                        if (bbs.Top) {
                            sticked.push(bbs);
                        } else {
                            ordinary.push(bbs);
                        }
                    });

                    sticked.sort(function (a, b) {
                        return mcService.sortAB(a.dtCreated, b.dtCreated);
                    });

                    ordinary.sort(function (a, b) {
                        return mcService.sortAB(a.dtCreated, b.dtCreated);
                    });

                    ordinary.forEach(function (bbs) {
                        addMSG(bbs);
                    });
                    
                    sticked.forEach(function (bbs) {
                        addMSG(bbs);
                    });
                }
            }
        ]);
    };

    //========================================

    var _msg = _messages_.Broadcast = {
        onReceiveBroadcast  : 'onReceiveBroadcast'
    };

    $scope.$on(_msg.onReceiveBroadcast, function (e, args) {
        $scope.show.apply(null, args);

        $scope.registerHotKeys();
    });

    $scope.$on('hide' + $scope.Name, function(){
        if (view && view.isVisible()) {
            $scope.removeHotKeys();

            view.hide();
        }
    });

    // $scope.$on('show' + $scope.Name, function(e, args){
    //
    //     $scope.getData();
    //
    // });
}"use strict";

function initChatWrapper($scope){
    var view = null;

    // === LEFT VIEW =====================================

    var leftView = [
        { id: "mainMenu" + $scope.Name,  view: "toggle", type: "icon", css: "ico20 button_warning button_transparent noUpperCase", //popup: "mainMenuPopup", //
            offIcon: "bars",  onIcon:"close", offLabel: $scope.myName, onLabel: $scope.myName,
            on: { onChange: $scope.showMainMenu }
        },

        { id: $scope.containers.left, css: "noBGColorAll", rows: [ { gravity: 0} ]}
    ];

    // === RIGHT VIEW ====================================

    var rightView = [
        { id: $scope.containers.right, rows: [
            { gravity: 0}
        ]}
    ];

    // === TOOLS VIEW ====================================

    var toolBarView = { view: "toolbar", padding: 0};

    var btnList     = [
        {  id: "btn_" + mcConst.dataModels.CommonContacts,   view: "toggle", type: "icon", icon: "sitemap", width: 34, css: "iconNoPadding",
            tooltip: mcLang(10), on: {onItemClick: $scope.clickToolBtn} //  "10" :"Общие контакты",
        },
        {  id: "btn_" + mcConst.dataModels.PersonalContacts, view: "toggle", type: "icon", icon: "users",   width: 34, css: "iconNoPadding",
            tooltip: mcLang(17), on: {onItemClick: $scope.clickToolBtn} // "17" :"Личные контакты",
        },
        {  id: "btn_" + mcConst.dataModels.HistoryDialogs,   view: "toggle", type: "icon", icon: "history",width: 34, css: "iconNoPadding",
            tooltip: mcLang(578), on: {onItemClick: $scope.clickToolBtn} // "578":"История диалогов",
        },

        {  id: "btn_" + mcConst.dataModels.PrivateInfo,      view: "toggle", type: "icon", icon: "comment", width: 34, css: "iconNoPadding",
            tooltip: mcLang(46), hidden: true, on: {onItemClick: $scope.clickToolBtn} // "46" :"Приватный разговор",
        },
        {  id: "btn_" + mcConst.dataModels.ConfUserList,     view: "toggle", type: "icon", icon: "comments",width: 34, css: "iconNoPadding",
            tooltip: mcLang(26), hidden: true, on: {onItemClick: $scope.clickToolBtn} // "26" :"Люди в конференции",
        },
        {  id: "btn_" + mcConst.dataModels.CommonFiles,      view: "toggle", type: "icon", icon: "files-o",width: 34, css: "iconNoPadding",
            tooltip: mcLang(567), hidden: true, on: {onItemClick: $scope.clickToolBtn} // "567":"Общие файлы на сервере",
        },
        {  id: "btn_" + mcConst.dataModels.ReceiveFiles,     view: "toggle", type: "icon", icon: "exchange",width: 34, css: "iconNoPadding",
            tooltip: mcLang(588), hidden: true, on: {onItemClick: $scope.clickToolBtn} // "588":"Прием файлов",
        }
    ];

    // ====================================================

    if (isMobile){
        toolBarView.height = 37;
        toolBarView.css = "bgDarkness WhiteMenu";

        toolBarView.cols = [{}].concat(btnList);

        view = webix.ui({ view: "carousel", scrollSpeed:"600ms", navigation:{
            type   : "flip",
            items  : false,
            buttons: false
        }, cols:[
            { id: "leftSide", width: $scope.wndSize.width, css: "bgDarkness", rows: leftView},

            { id: $scope.containers.center, width: $scope.wndSize.width, css: "noMargin gradient", rows: [ { gravity: 0} ]},

            { id: "rightSideResizer", width: 0, hidden: true}, // bgMC

            { rows: [
                toolBarView,
                { id: "rightSide", width: $scope.wndSize.width, css: "bgMC noMargin", rows: rightView}
            ]}
        ]});

        view.getChildViews()[0].attachEvent("onAfterScroll", $scope.scrollView);
        view.setActive($scope.containers.center);

        webix.attachEvent("onTouchEnd", $scope.correctSwipe);
    } else {
        toolBarView.width = 34;

        toolBarView.rows = btnList.concat({});

        view = webix.ui({ type: "layout", rows:[
            { cols:[
                { id: "leftSide", width: 210, css: "bgDarkness", rows: leftView, minWidth: 210, maxWidth: 250},

                { id: "leftSideResizer", view: "resizer", css: "noBorder bgDarkness"},

                { id: $scope.containers.center, css: "noMargin gradient", cols: [ { gravity: 0} ]},

                { id: "rightSideResizer", view: "resizer", css: "noBorder bgMC noMargin", hidden: true}, // bgMC

                { id: "rightSide", width: 250, css: "bgMC noMargin", minWidth: 210, maxWidth: 350, hidden: true, rows: rightView}
            ].concat(toolBarView)}
        ]});
    }

    $scope.toolBtn.CommonContacts   = $$("btn_" + mcConst.dataModels.CommonContacts);
    $scope.toolBtn.PersonalContacts = $$("btn_" + mcConst.dataModels.PersonalContacts);
    $scope.toolBtn.PrivateInfo      = $$("btn_" + mcConst.dataModels.PrivateInfo);
    $scope.toolBtn.ConfUserList     = $$("btn_" + mcConst.dataModels.ConfUserList);
    $scope.toolBtn.CommonFiles      = $$("btn_" + mcConst.dataModels.CommonFiles);
    $scope.toolBtn.HistoryDialogs   = $$("btn_" + mcConst.dataModels.HistoryDialogs);
    $scope.toolBtn.ReceiveFiles     = $$("btn_" + mcConst.dataModels.ReceiveFiles);

    $scope.mainMenu         = $$("mainMenu" + $scope.Name);

    $scope.leftSide         = $$("leftSide");
    $scope.leftSideResizer  = $$("leftSideResizer");

    $scope.rightSide        = $$("rightSide");
    $scope.rightSideResizer = $$("rightSideResizer");
    //$scope.selectToolList   = $$("selectToolList");

    $scope.centerBlock = $$($scope.containers.center).getNode();
    $scope.rightSideBlock = $scope.rightSide.getNode();

    return view;
}"use strict";

function chatWrapperController($scope, $rootScope){
    $scope.Name       = mcConst.dataModels.ChatWrapper;
    $scope.toolBtn    = {};
    $scope.containers = mcConst.containers;

    var view                     = null;
    var oldFrame                 = mcConst.dataModels.ChatFrame;
    var currentFrame             = mcConst.dataModels.ChatFrame;
    var pinTool                  = '';
    var activeView               = 1;
    var notShowRightSide         = false;
    var currentTool              = null;
    var automaticClosedRightTool = false;
    var addingWidth              = 0;
    var selectToolList           = {
        data: {},

        currentTool: null,

        setValue: function (val, skipOnChange) {
            var prev = this.currentTool;

            this.currentTool = this.data.hasOwnProperty(val) ? val : null;

            if (this.currentTool && this.onChange && this.currentTool !== prev && !skipOnChange){
                this.onChange(this.currentTool, prev);
            }
        },

        getValue: function () {
            return this.currentTool;
        },

        onChange: null
    };
    var restoreTool              = null;
    var restoreValue             = null;
    var toolList                 = [
        mcConst.dataModels.CommonContacts,
        mcConst.dataModels.HistoryDialogs,
        mcConst.dataModels.PersonalContacts,
        mcConst.dataModels.PrivateInfo,
        mcConst.dataModels.ConfUserList,
        mcConst.dataModels.CommonFiles,
        mcConst.dataModels.ReceiveFiles
    ];

    function unPinTool(){
        pinTool = '';
    }

    function PinTool(tool) {
        pinTool = tool;
    }

    function switchToolBtnVisible(tool) {
        switch (tool){
            case mcConst.dataModels.PrivateInfo:
                if ($rootScope.GetChatTypeID() === "UIN-0"){
                    $scope.toolBtn.PrivateInfo.hide();
                } else {
                    $scope.toolBtn.PrivateInfo.show();
                }
                
                $scope.toolBtn.ConfUserList.hide();

                paintBG('privateBg');
            break;

            case mcConst.dataModels.ConfUserList:
                $scope.toolBtn.PrivateInfo.hide();
                $scope.toolBtn.ConfUserList.show();

                paintBG('bgMC');
            break;

            case mcConst.dataModels.CommonContacts:
            case mcConst.dataModels.HistoryDialogs:
            case mcConst.dataModels.PersonalContacts:
            case mcConst.dataModels.CommonFiles:

            break;

            case mcConst.dataModels.ReceiveFiles:
                $scope.toolBtn[mcConst.dataModels.ReceiveFiles].show();
            break;

            default:
                $scope.toolBtn.PrivateInfo.hide();
                $scope.toolBtn.ConfUserList.hide();

                if (!pinTool) {
                    $scope.rightSide.hide();
                    $scope.rightSideResizer.hide();
                }
        }
    }

    function selectToolView(tool, needClick) {
        if (pinTool === '') {
            $scope.changeTool(tool);

            if (needClick && tool){
                $scope.toolBtn[tool].callEvent("onItemClick");
            }
        } else {
            switchToolBtnVisible(tool, pinTool);
        }

        $rootScope.$broadcast(window._messages_.chatFrame.focusToEnterChat);
    }

    function toggleRightToolBarByWndSize() {
        var chkWidth = (!automaticClosedRightTool ? mcConst.minChatFrameWidth : mcConst.minChatFrameWidth + addingWidth + 40);

        if (!automaticClosedRightTool && $scope.centerBlock.offsetWidth <= chkWidth && $scope.rightSide.isVisible()) {
            addingWidth = $scope.rightSideBlock.offsetWidth;

            selectToolView(currentTool, true);

            automaticClosedRightTool = true;
        } else
        if (automaticClosedRightTool && $scope.centerBlock.offsetWidth > chkWidth) {
            selectToolView(currentTool, true);

            addingWidth = 0;

            automaticClosedRightTool = false;
        }
    }

    function __config() {
        $scope.containers[mcConst.dataModels.CommonContacts]   = mcConst.containers.right;
        $scope.containers[mcConst.dataModels.PersonalContacts] = mcConst.containers.right;
        $scope.containers[mcConst.dataModels.PrivateInfo]      = mcConst.containers.right;
        $scope.containers[mcConst.dataModels.ConfUserList]     = mcConst.containers.right;
        $scope.containers[mcConst.dataModels.CommonFiles]      = mcConst.containers.right;
        $scope.containers[mcConst.dataModels.HistoryDialogs]   = mcConst.containers.right;
        $scope.containers[mcConst.dataModels.ReceiveFiles]     = mcConst.containers.right;

        $scope.containers[mcConst.dataModels.Dialogs]          = mcConst.containers.left;
        $scope.containers[mcConst.dataModels.MainMenu]         = mcConst.containers.left;

        $scope.containers[mcConst.dataModels.ChatFrame]        = mcConst.containers.center;
        $scope.containers[mcConst.dataModels.UserProfile]      = mcConst.containers.center;
        $scope.containers[mcConst.dataModels.BBS]              = mcConst.containers.center;
        $scope.containers[mcConst.dataModels.Kanban]           = mcConst.containers.center;
        $scope.containers[mcConst.dataModels.ViewLogs]         = mcConst.containers.center;
        $scope.containers[mcConst.dataModels.Settings]         = mcConst.containers.center;

        selectToolList.data[mcConst.dataModels.CommonContacts  ] = mcService.Lang(10);  //"10" : "Контакты",
        selectToolList.data[mcConst.dataModels.PersonalContacts] = mcService.Lang(17);  //"17" : "Личные контакты",
        selectToolList.data[mcConst.dataModels.PrivateInfo     ] = mcService.Lang(46);  //"46" : "Приватный разговор",
        selectToolList.data[mcConst.dataModels.ConfUserList    ] = mcService.Lang(26);  //"26" : "Люди в конференции",
        selectToolList.data[mcConst.dataModels.CommonFiles     ] = mcService.Lang(567); //"567":"Общие файлы на сервере",
        selectToolList.data[mcConst.dataModels.HistoryDialogs  ] = mcService.Lang(578); //"578":"История диалогов",
        selectToolList.data[mcConst.dataModels.ReceiveFiles    ] = mcService.Lang(588); //"588":"Прием файлов",

        selectToolList.onChange = $scope.changeTool;
    }

    function restoringTool(newFrame) {
        if (newFrame &&
            [
                mcConst.dataModels.Settings,
                mcConst.dataModels.ViewLogs,
                mcConst.dataModels.BBS,
                mcConst.dataModels.UserProfile,
                mcConst.dataModels.Kanban
            ].indexOf(newFrame) === -1){
            
            switch (restoreTool){
                case mcConst.dataModels.CommonContacts:
                case mcConst.dataModels.PersonalContacts:
                case mcConst.dataModels.HistoryDialogs:
                    switch ($rootScope.GetChatAlias()){
                        case $rootScope.chatAliases.Conf:
                            $scope.toolBtn[mcConst.dataModels.ConfUserList].show();
                        break;

                        case $rootScope.chatAliases.Privat:
                            $scope.toolBtn[mcConst.dataModels.PrivateInfo].show();
                        break;
                    }
                break;

                default:
                    var __rTool = $scope.toolBtn[restoreTool];

                    if (restoreTool) {
                        __rTool.show();
                    }

                    if (restoreTool && __rTool.getValue() !== restoreValue) {
                        __rTool.callEvent("onItemClick");
                    } else {
                        selectToolView(restoreTool);
                    }
            }
        } else {
            selectToolView();
        }
    }

    function changeCenterView(newFrame, params){
        if (newFrame && newFrame !== currentFrame){
            $rootScope.$broadcast('hide' + currentFrame);

            oldFrame = currentFrame;

            currentFrame = newFrame;

            $rootScope.$broadcast('show' + newFrame, [$scope.containers[newFrame], params]);

            if (!params || params !== "dUIN-0") {
                restoringTool(newFrame);
            }
        } else

        if (!newFrame && oldFrame){
            $rootScope.$broadcast('hide' + currentFrame);

            currentFrame = oldFrame;

            $rootScope.$broadcast('show' + oldFrame, [$scope.containers[oldFrame], params]);

            if (!params || params !== "dUIN-0") {
                restoringTool(oldFrame);
            }
        } else

        if (newFrame === mcConst.dataModels.UserProfile){
            currentFrame = newFrame;

            $rootScope.$broadcast('show' + newFrame, [$scope.containers[newFrame], params]);
        }
    }

    function paintBG(color) {
        $scope.rightSideResizer.getNode().className = "webix_view webix_resizer_x noBorder noMargin " + color;
        $scope.rightSide.getNode().className = "webix_view noMargin webix_layout_line " + color;
    }

    function hideTool(tool) {
        switch (tool){
            case mcConst.dataModels.ReceiveFiles:
                if ($scope.toolBtn[tool].isVisible()){
                    $scope.toolBtn[tool].setValue(false);
                    $scope.toolBtn[tool].hide();

                    if (currentTool === tool){
                        if ($rootScope.GetChatType() === $rootScope.chatAliases.UIN){
                            $scope.changeTool(mcConst.dataModels.PrivateInfo);
                        } else
                        if ($rootScope.GetChatType() === $rootScope.chatAliases.UID){
                            $scope.changeTool(mcConst.dataModels.ConfUserList);
                        } else {
                            $scope.rightSide.hide();
                            $scope.rightSideResizer.hide();
                        }
                    }
                }
            break;
        }
    }

    // ===============================================

    $scope.registerHotKeys = function () {
        $rootScope.hotKeyDispatcher.addPreset($scope.Name, [{
            key   : mcConst.keyCodes.esc,
            shiftKey: true,
            func  : function () {
                selectToolView(currentTool, true);
            }
        }], document);
    };

    $scope.removeHotKeys = function () {
        $rootScope.hotKeyDispatcher.removePreset($scope.Name);
    };

    $scope.showMainMenu = function () {
        var val = $scope.mainMenu.getValue();

        if (val){
            webix.html.addCss( $scope.mainMenu.getNode(), "darkenNavBG");

            webix.html.removeCss( $scope.leftSideResizer.getNode(), "bgDarkness");
            webix.html.addCss( $scope.leftSideResizer.getNode(), "darkenNavBG");

            $rootScope.$broadcast('hide' + mcConst.dataModels.Dialogs);
            $rootScope.$broadcast('show' + mcConst.dataModels.MainMenu, [$scope.containers[mcConst.dataModels.MainMenu]]);

            if (!pinTool && [$rootScope.chatAliases.Conf, $rootScope.chatAliases.Privat].indexOf($rootScope.GetChatAlias()) === -1){
                restoreTool = null;
            }
        } else {
            webix.html.removeCss( $scope.mainMenu.getNode(), "darkenNavBG");

            webix.html.addCss( $scope.leftSideResizer.getNode(), "bgDarkness");
            webix.html.removeCss( $scope.leftSideResizer.getNode(), "darkenNavBG");

            $rootScope.$broadcast('hide' + mcConst.dataModels.MainMenu);
            $rootScope.$broadcast('show' + mcConst.dataModels.Dialogs, [$scope.containers[mcConst.dataModels.Dialogs]]);
        }

        //$scope.mainMenu.refresh();
    };

    $scope.changeTool = function(tool, oldTool){
        var currentType = $rootScope.GetChatType();

        oldTool = oldTool || selectToolList.getValue();

        currentTool = tool;

        if ($rootScope.GetChatTypeID() === 'UIN-0' && tool === mcConst.dataModels.PrivateInfo){
            switchToolBtnVisible();
        }

        if (($rootScope.GetChatTypeID() === 'UIN-0' && tool === mcConst.dataModels.PrivateInfo) ||
            (tool === mcConst.dataModels.ConfUserList && currentType === $rootScope.chatAliases.UIN) ||
            (tool === mcConst.dataModels.PrivateInfo  && currentType === $rootScope.chatAliases.Conf)){

            selectToolList.setValue(oldTool);

            $scope.changeToolBtn.apply($scope.toolBtn[oldTool]);
        } else {
            unPinTool();

            selectToolList.setValue(tool, true);

            if (!notShowRightSide && tool){
                $scope.changeToolBtn.apply($scope.toolBtn[tool]);
                $scope.rightSide.show();
                $scope.rightSideResizer.show();
            }

            switchToolBtnVisible(tool);

            if (tool){
                $rootScope.$broadcast('show' + tool, [$scope.containers[tool]]);
            }
        }

        if ($scope.rightSide.isVisible()){
            automaticClosedRightTool = false;
        }

    };

    $scope.changeToolBtn = function(){
        toolList.forEach(function (itm) {
            $scope.toolBtn[itm].setValue(false);
        });
        
        if (this && this.setValue){
            this.setValue(true);

            restoreTool  = this.config.id.split('_')[1];
            restoreValue = this.getValue();
        }
    };

    $scope.clickToolBtn = function(){
        var oldTool = selectToolList.getValue();

        restoreTool  = this.config.id.split('_')[1];
        restoreValue = this.getValue();

        if (oldTool === restoreTool && !restoreValue){ // !this.getValue() - unpressed
            if (!isMobile){
                $scope.rightSide.hide();
                $scope.rightSideResizer.hide();

                $rootScope.$broadcast('hide' + oldTool);

                notShowRightSide = true;
            } else {
                return false;
            }
        } else {
            notShowRightSide = false;

            $scope.changeTool(restoreTool);
        }
    };

    $scope.scrollView = function(){
        $rootScope.$broadcast('blurChatTextOutput', []);
    };

    $scope.correctSwipe = function (c1, c2){
        if (c1 && c2){
            var directionX = c2.x - c1.x;

            if (directionX > 100){ // left
                activeView = (activeView === 0) ? 0 : activeView - 1;
            } else
            if (directionX < -100){ // right
                activeView = (activeView === 2) ? 2 : activeView + 1;
            }

            if (view.getActiveIndex() !== activeView) {
                view.setActiveIndex(activeView);
            }
        }
    };

    //================================================

    var _msg = _messages_.chatWrapper = {
        carouselChange  : "carouselChange",
        showHideMenu    : "showHideMenu",
        selectTool      : "selectTool",
        changeCenterView: "changeCenterView",
        pinTool         : "pinTool",
        unPinTool       : "unPinTool",
        hideTool        : "hideTool",
        hideAllTools    : "hideAllTools",
        isVisibleRightSide: "isVisibleRightSide"
    };

    $scope.$on(_msg.hideAllTools, function () {
        toolList.forEach(function (tool) {
            if ($scope.toolBtn[tool].getValue()){
                $scope.toolBtn[tool].callEvent("onItemClick");
            }
        });
    });

    $scope.$on(_msg.isVisibleRightSide, function () {
        return $scope.rightSide.isVisible();
    });

    $scope.$on(_msg.hideTool, function (e, args) {
        hideTool.apply(null, args);
    });

    $scope.$on(_msg.carouselChange, function(e, args){
        var id = args[0];

        view.setActive(id);
    });

    $scope.$on(_msg.showHideMenu, function () {
        $scope.mainMenu.toggle();
    });

    $scope.$on(_msg.selectTool, function(e, args){
        selectToolView.apply(null, args);
    });

    $scope.$on(_msg.changeCenterView, function(e, args){
        changeCenterView.apply(null, args);
    });

    $scope.$on(_msg.pinTool, function(e, args){
        PinTool.apply(null, args);
    });

    $scope.$on(_msg.unPinTool, function(){
        unPinTool();
    });

    $scope.$on('hide' + $scope.Name, function(){
        view.hide();
    });

    $scope.$on('show' + $scope.Name, function(){
        $scope.wndSize = mcService.getWindowSize();
        $scope.myName  = mcConst.UserInfo.Nick;

        __config();

        view = initChatWrapper($scope);

        $rootScope.$broadcast('show' + mcConst.dataModels.Dialogs, [$scope.containers[mcConst.dataModels.Dialogs]]);

        setTimeout(toggleRightToolBarByWndSize, 200);

        $rootScope.registerRightsCheck('_warpper', function () {
            $scope.toolBtn.CommonContacts  [mcService.checkRights(mcConst._CMD_.RS.QShowCommonContactsList)  ? 'show' : 'hide']();
            $scope.toolBtn.PersonalContacts[mcService.checkRights(mcConst._CMD_.RS.QAllowContactsListsTotal) ? 'show' : 'hide']();

            $scope.leftSide       [mcService.checkRights(mcConst._CMD_.RS.QCommonAllowDialogs) ? 'show' : 'hide']();
            $scope.leftSideResizer[mcService.checkRights(mcConst._CMD_.RS.QCommonAllowDialogs) ? 'show' : 'hide']();
        });

        $scope.registerHotKeys();

        var left  = $scope.leftSide.getNode();
        var right = $scope.rightSide.getNode();

        left.ondragover = right.ondragover = left.ondrop = right.ondrop = $scope.centerBlock.ondragover = function(e) {
            /** @namespace e.dataTransfer */
            if (e.dataTransfer.files.length){
                e.preventDefault();
            }
        };

        $scope.centerBlock.ondrop = function(e) {
            var dataTransfer = e.dataTransfer;

            if (dataTransfer.files.length) {
                $rootScope.$broadcast(window._messages_.downloadUpload.on_file_drop, [dataTransfer]);

                e.preventDefault();
            }
        };
    });

    $rootScope.$broadcast('windowResize', [function(w, h){
        if (view){
            if (isMobile){
                $scope.wndSize.width = w;
                $scope.wndSize.height = h;

                view.define('height', h);
                view.define('width', w);

                $scope.leftSide.define('width', w);
                $$($scope.containers.center).define('width', w);
                $scope.rightSide.define('width', w);

                $scope.leftSide.resize();
                $$($scope.containers.center).resize();
                $scope.rightSide.resize();

                view.resize();
            } else {
                toggleRightToolBarByWndSize();
            }
        }
    }]);
}

// var tt = [
//     {
//         "_id": "5c361f26a72decf7729f67b7",
//         "name": "sampleRoom",
//         "notifying": {
//             "streamChange": true,
//             "participantActivities": true
//         },
//         "transcoding": {
//             "video": {
//                 "parameters": {
//                     "keyFrameInterval": true,
//                     "bitrate": true,
//                     "framerate": true,
//                     "resolution": true
//                 },
//                 "format": true
//             },
//             "audio": true
//         },
//         "mediaOut": {
//             "video": {
//                 "parameters": {
//                     "keyFrameInterval": [100, 30, 5, 2, 1],
//                     "bitrate": ["x0.8", "x0.6", "x0.4", "x0.2"],
//                     "framerate": [6, 12, 15, 24, 30, 48, 60],
//                     "resolution": ["x3/4", "x2/3", "x1/2", "x1/3", "x1/4", "hd1080p", "hd720p", "svga", "vga", "cif"]
//                 },
//                 "format": [
//                     { "codec": "h264", "profile": "CB" },
//                     { "codec": "vp9" }
//                 ]},
//             "audio": [
//                 { "codec": "opus", "sampleRate": 48000, "channelNum": 2 },
//                 { "codec": "isac", "sampleRate": 16000 },
//                 { "codec": "isac", "sampleRate": 32000 },
//                 { "codec": "g722", "sampleRate": 16000, "channelNum": 1 },
//                 { "codec": "pcma" },
//                 { "codec": "pcmu" },
//                 { "codec": "aac",  "sampleRate": 48000, "channelNum": 2 },
//                 { "codec": "ac3"  },
//                 { "codec": "nellymoser" },
//                 { "codec": "ilbc" }
//             ]},
//         "mediaIn": {
//             "video": [
//                 { "codec": "h264" },
//                 { "codec": "vp9"  }
//             ],
//             "audio": [
//                 { "codec": "opus", "sampleRate": 48000, "channelNum": 2 },
//                 { "codec": "isac", "sampleRate": 16000 },
//                 { "codec": "isac", "sampleRate": 32000 },
//                 { "codec": "g722", "sampleRate": 16000, "channelNum": 1 },
//                 { "codec": "pcma" },
//                 { "codec": "pcmu" },
//                 { "codec": "aac" },
//                 { "codec": "ac3" },
//                 { "codec": "nellymoser" },
//                 { "codec": "ilbc" }
//             ]},
//         "views": [
//             { "video": {
//                 "layout": {
//                     "templates": {
//                         "custom": [
//                             { "region": [
//                                 {
//                                     "id": "1",
//                                     "area": {
//                                         "left": "0", "top": "0", "width": "1", "height": "1"
//                                     },
//                                     "shape": "rectangle" }]
//                             },
//                             { "region": [
//                                 {
//                                     "id": "1",
//                                     "area": {
//                                         "left": "0", "top": "0", "width": "1/3", "height": "1/3"
//                                     },
//                                     "shape": "rectangle"
//                                 },
//                                 {
//                                     "id": "2",
//                                     "area": {
//                                         "left": "1/3", "top": "0", "width": "1/5", "height": "1/5"
//                                     }, "shape": "rectangle"
//                                 }
//                             ]}
//                         ],
//                         "base": "fluid"
//                     },
//                     "fitPolicy": "crop"
//                 },
//                 "keepActiveInputPrimary": false,
//                 "bgColor": {
//                     "b": 0, "g": 0, "r": 0
//                 },
//                 "motionFactor": 0.8,
//                 "maxInput": 16,
//                 "parameters": {
//                     "keyFrameInterval": 100,
//                     "framerate": 30,
//                     "resolution": {
//                         "height": 600, "width": 800
//                     }
//                 },
//                 "format": { "codec": "vp9" }
//             },
//             "audio": {
//                 "vad": true,
//                 "format": { "channelNum": 2, "sampleRate": 48000, "codec": "opus" }
//             },
//             "label": "common"
//         }],
//
//         "roles": [
//             {
//                 "subscribe": { "video": true, "audio": true },
//                 "publish": { "video": true, "audio": true },
//                 "role": "presenter"
//             },
//             {
//                 "subscribe": { "video": true, "audio": true },
//                 "publish": { "video": false, "audio": false },
//                 "role": "viewer"
//             },
//             {
//                 "subscribe": { "video": false, "audio": true },
//                 "publish": { "video": false, "audio": true },
//                 "role": "audio_only_presenter"
//             },
//             {
//                 "subscribe": { "video": true, "audio": false },
//                 "publish": { "video": false, "audio": false },
//                 "role": "video_only_viewer"
//             },
//             {
//                 "subscribe": { "video": true, "audio": true },
//                 "publish": { "video": true, "audio": true },
//                 "role": "sip"
//             }
//         ],
//         "participantLimit": -1,
//         "inputLimit": -1,
//         "__v": 5
//     }
// ];





















function mainController($scope, $rootScope, mcCmdParser, mcCmdLoop, $http, $location, mcStatistics){
    var resizeWndCb = [];

    // ============================================================

    function initLockWindow(){
        if (lockWindow){
            lockWindow.destructor();
        }

        lockWindow = webix.ui({
            view     : "window",
            modal    : true,
            head     : mcService.Lang(18), // "18" : "Обработка запроса",
            position : "center",
            width    : 220,
            height   : mcConst.lockWindowHeight, // 65
            body     : {
                template : "<div align='center'><img src='" + mcConst.imagesPath.loading + "'></div>"
            }
        });
    }

    function displayError(txtCode, txt, txtParam, callback, okText){
        $scope.errorMessagesIsShowed = true;

        $rootScope.errorDialog = webix.alert({
            title: txtCode === -1 ? "" : mcService.Lang(11, txtCode), // mcService.Lang(11, err.ErrNum), // "11" : "Ошибка #"
            ok   : okText || mcService.Lang(12),          // "12" : "Закрыть",
            type : "alert-error",
            width: 400,
            text : mcService.myReplace(txt, txtParam),
            callback: function(){
                if (callback){
                    callback();
                }

                $rootScope.lastError = txtCode;

                var args = $scope.errorMessages.shift();

                if (args !== undefined){
                    setTimeout(function(){
                        displayError.apply(null, args);
                    }, 20);
                }

                $scope.errorMessagesIsShowed = false;

                $rootScope.errorDialog = null;
            }
        });
    }

    function runCmd(cmd, args){
        if (mcService.isArray(args)){
            var cmdNumb = args.shift();

            if (mcCmdParser[cmd][cmdNumb]){
                mcCmdParser[cmd][cmdNumb].apply(null, args);
            } else {
                console.warn(mcService.myReplace(mcService.Lang(9), [cmd.toString(), cmdNumb.toString()])); // "10" : "%s: %s not found!"
            }
        } else {
            throw new Error(mcService.myReplace(mcService.Lang(8), [cmd])); // "8" : "%s: нет входящих аргументов"
        }
    }

    function sendCMD(args, toElectron){
        if (args[0] === mcConst.lockInterface){
            args.shift();

            $scope.$emit(mcConst.lockInterface, []);
        }

        if (mcService.isFunction(args[args.length - 1])){
            if (!$rootScope.customCallBack[args[0]]){
                $rootScope.customCallBack[args[0]] = [];
            }

            $rootScope.customCallBack[args[0]].push(args.pop());
        }

        if (toElectron){
            mcCmdParser.internalSender(args);
        } else {
            if (mcStatistics){
                mcStatistics.setValueByCMD.apply(null, args);
            }

            if (mcCmdParser.MultiSender.apply(null , args)){
                runCmd('SendCMDToServer', args);
            }
        }
    }

    function setWindowSize() {
        $rootScope.wndSize = mcService.getWindowSize();

        for (var i = 0; i < resizeWndCb.length; i++){
            resizeWndCb[i]($rootScope.wndSize.width, $rootScope.wndSize.height);
        }
    }

    function receiveCMD(args) {
        if (mcStatistics){
            mcStatistics.setValueByCMD.apply(null, args);
        }

        if (mcCmdParser.MultiParser.apply(null, args)){
            runCmd('ProcessCMD', args);
        }
    }

    function startPingTimer (){
        mcConst.PingTimer = new mcCmdLoop(mcConst.PingInterval, mcConst.SessionID, {
            onError : function(){
                if ($rootScope.isWebClient){
                    mcConst.LoggedIn = false;

                    $scope.$emit('ErrorMsg', ['223', mcConst.ErrorText['223'], '', function(){
                        location.search = "";
                        location.reload();
                    }]);
                } else {
                    $rootScope.restoreConnection = false;

                    $rootScope.$broadcast('ReconnectLoop');

                    $rootScope.$broadcast('ErrorMsg', ['223', mcConst.ErrorText['223'] + "<br>" + mcLang(539) + "<br><br>" + mcConst.loadGif, '', function(){ // "539":"Восстанавливаем связь!",
                        mcService.ClearSessionSettings(true, true);

                        location.search = "";
                        location.reload();
                    }, mcLang(540)]); // "540":"Прервать",
                }
            },
            onStop: function () {
                mcConst.LoggedIn  = false;
                mcConst.PingTimer = null;
                mcConst.SessionID = '';

                $rootScope.destroySocketIo();

                if (!$rootScope.isWebClient){
                    $rootScope.$broadcast("disableGlobalHotKeys");
                }
            }
        });
    }

    // ========= Отправка клиентских логов (browser) на сервер ===========
    if (window.cLog){
        cLog(mcConst._CMD_.ce_console_log, sendCMD);
    }
    // ===================================================================

    var lockWindow = null;
    var reconnectTimer = null;

    $scope.lockCount = 0;
    $scope.lockTimer = null;
    $scope.errorMessages = [];
    $scope.errorMessagesIsShowed = false;

    // ====================================================

    if (window.McTextFinder) {
        McTextFinder($rootScope);
    }

    $rootScope.hotKeyDispatcher = new mcService.HotkeyManager();

    mcService._hotkeys = $rootScope.hotKeyDispatcher;

    $rootScope.acConfig = {
        serversInfo: {}
    };
    $rootScope.restrictedSymbols = '"\/\\[]:;|=,+*?<>';

    $rootScope.thumbsSize     = mcConst.imageSize.big;

    $rootScope.mcStorage      = mcService.Marge({}, mcConst.dataModels);
    $rootScope.customCallBack = {};
    $rootScope.needFoto       = false;
    $rootScope.errorDialog    = null;
    $rootScope.Purl           = purl();                        
    $rootScope.customUserOptions = null;

    $rootScope.chatAliases = {
        Conf  : mcConst.dataModels.ConfUserList,
        UIN   : "UIN",
        UID   : "UID",
        Forum : mcConst.dataModels.Forum,
        Privat: mcConst.dataModels.PrivateInfo,
        Kanban: mcConst.dataModels.Kanban,
        BBS   : mcConst.dataModels.BBS
    };

    $rootScope.wndSize = mcService.getWindowSize();

    $rootScope.isWebClient = location.protocol !== 'file:';

    $rootScope.SendCMDToServer = sendCMD;
    $rootScope.ProcessCMD      = receiveCMD;

    if (!$rootScope.isWebClient){
        try {
            initClientData.apply(null, [$scope, $rootScope, sendCMD, mcStatistics]);
        } catch (e){}
    }

    // ====================================================

    var toolShowed     = null;

    $rootScope.setTool = function(name){
        if (toolShowed !== name) {
            $rootScope.hidePrevTool(toolShowed);

            toolShowed = name;
        }
    };

    $rootScope.getTool = function(){
        return toolShowed;
    };

    $rootScope.hidePrevTool = function(){
        if (toolShowed)
            $rootScope.$broadcast('hide' + toolShowed, []);
    };

    // ====================================================

    var rightCheck  = {
        // where: function()
    };

    var CurrentDialog = {
        id   : '-1',
        type : $rootScope.chatAliases.UIN,
        alias: mcConst.dataModels.PrivateInfo
    };

    /**
     * @return {string}
     */
    $rootScope.GetChatID = function(){
        return CurrentDialog.id;
    };

    /**
     * @return {string}
     */
    $rootScope.GetChatType = function(){
        return CurrentDialog.type;
    };

    $rootScope.GetChatAlias = function(){
        return CurrentDialog.alias;
    };

    /**
     * @return {string}
     */
    $rootScope.GetChatTypeID = function(){
        return CurrentDialog.type + "-" + CurrentDialog.id;
    };

    $rootScope.createUIN = function(uin){
        return $rootScope.chatAliases.UIN + "-" + uin;
    };

    $rootScope.createUID = function(uid){
        return $rootScope.chatAliases.UID + "-" + uid;
    };

    $rootScope.SetPrivate = function(UIN){ // PRIVATE
        CurrentDialog = {
            id: UIN, type: $rootScope.chatAliases.UIN, alias: mcConst.dataModels.PrivateInfo
        };
    };

    $rootScope.SetKanban = function(){ // KANBAN
        CurrentDialog = {
            id: '0', type: $rootScope.chatAliases.Kanban, alias: mcConst.dataModels.Kanban
        };
    };

    $rootScope.SetBBS = function(){ // BBS
        CurrentDialog = {
            id: '0', type: $rootScope.chatAliases.BBS, alias: mcConst.dataModels.BBS
        };
    };

    $rootScope.SetConf = function(UID){ // CHANNEL
        CurrentDialog = {
            id: UID, type: $rootScope.chatAliases.UID, alias: mcConst.dataModels.ConfUserList
        };
    };

    $rootScope.checkAbilityByRights = function (where) {
        if (where){
            if (rightCheck[where]) {
                rightCheck[where]()
            } else {
                console.error("Was't set rights check for the \"" + where + "\"");
            }
        } else {
            for (var item in rightCheck){
                rightCheck[item]();
            }
        }
    };

    $rootScope.registerRightsCheck = function (where, cb) {
        rightCheck[where] = cb;
    };

    $rootScope.startUrlOptions = function () {
        var uin = $rootScope.Purl.param('uin');

        if (uin){
            $rootScope.$broadcast('OpenPrivate', [uin]);
        }
    };

    $rootScope.spellCheckManager = null;

    $rootScope.initSocketIo = function () {
        if (window.hasOwnProperty("io") && mcService.isFunction(window.io) && !mcConst.socketIO){
            mcConst.socketIO = io({
                'reconnection': true,
                'reconnectionAttempts': 5,
                'timeout' : 10000
            });

            mcConst.initWS(mcConst.socketIO);
        }
    };

    $rootScope.destroySocketIo = function () {
        if (mcConst.socketIO){
            mcConst.socketIO.disconnect();
            mcConst.socketIO = null;
        }
    };

    // ====================================================

    window._userActions = {};
    window.moment       = moment || {};
    window.isMobile     = browserDetect.mobile;
    
    webix.Date.startOnMonday = true;

    mcService.clearPlaneObj($rootScope.mcStorage);
    mcConst.LoginInfo = mcService.LoadSessionSettings();

    // ====================================================

    var _msg = _messages_.main = {
        SendCMDToServer : 'SendCMDToServer',
        ProcessCMD      : 'ProcessCMD',
        StartPingTimer  : 'StartPingTimer',
        StopPingTimer   : 'StopPingTimer',
        ReconnectLoop   : 'ReconnectLoop',
        ChangLanguage   : 'ChangLanguage',
        ErrorMsg        : 'ErrorMsg',
        hideAllErrors   : 'hideAllErrors',
        windowResize    : 'windowResize',
        confirmExit     : 'confirmExit'
    };

    $scope.$on(_msg.confirmExit, function (e, args) {
        var cb = args[0];

        if (cb){
            webix.confirm({
                type  : "confirm-error",
                text  : mcLang(603), // "603":"Выйти из чата?",
                ok    : mcLang(43),  // "43" :"Да",
                cancel: mcLang(44),  // "44" :"Нет",
                callback:function(yes){
                    if (yes){
                        cb();
                    }
                }
            });
        }
    });

    $scope.$on(_msg.SendCMDToServer, function(e, args){
        sendCMD(args);
    });

    $scope.$on(_msg.ProcessCMD, function(e, args){
        receiveCMD(args);
    });

    $scope.$on(_msg.StartPingTimer, startPingTimer);

    $scope.$on(_msg.StopPingTimer, function(){
        if (mcConst.PingTimer) {
            if (mcConst.LoggedIn && mcStatistics && mcStatistics.saveStat){
                mcStatistics.saveStat(mcConst.ServerInfo.ID, mcConst.UserInfo.UIN);
            }

            mcConst.PingTimer.StopPingTimer();

            mcConst.PingTimer = null;
        }
    });

    $scope.$on(_msg.ReconnectLoop, function () {
        if (!mcConst.PingTimer && !$rootScope.restoreConnection && $rootScope.loginFormNotShowed && !$rootScope.systemSuspened) {
            $rootScope.restoreConnection = true;

            if (!reconnectTimer){
                reconnectTimer = setTimeout(function () {
                    reconnectTimer = null;

                    $rootScope.SetPrivate(-1);

                    $rootScope.$broadcast(window._messages_.confUsers.clearUserForUID);
                    $rootScope.$broadcast(window._messages_.dialogsList.clearConfOnReconnect);
                    // $rootScope.$broadcast(window._messages_.dialogsCtrl.clearDialogsList);

                    $rootScope.$broadcast('SendCMDToServer' , [
                        mcConst.lockInterface,
                        mcConst._CMD_.Login,

                        mcConst.LoginInfo.login,
                        mcConst.LoginInfo.pwd,
                        mcConst.LoginInfo.servPwd,
                        mcConst.LoginInfo.rm
                    ]);
                }, !$rootScope.isWebClient && mcConst.ClientSettings.NetworkReconnectTime ? mcConst.ClientSettings.NetworkReconnectTime * 1000 : mcConst.reconnectTime);
            }
        }
    });

    $scope.$on(_msg.ChangLanguage, function(e, args){
        (function(locale, lang){
            setLocalizations();

            lang = $location.param('lang') || lang;

            if (lang.toLowerCase() === 'ua') {
                lang = 'uk';
            }

            moment.locale(lang);

            mcConst.Lang = lang;

            webix.Date.startOnMonday = mcConst.Lang !== 'en';

            webix.skin.set('material');
            webix.skin.material.optionHeight = 30;

            $http(MC_RESOURCE.TextSource.smileys + 'smileys.json').success(function(txt){
                mcConst.SmileysSet = mcService.isObject(txt) ? txt : JSON.parse(txt);
            });

            $http(MC_RESOURCE.TextSource.languages + lang + '.languages.json').success(function(txt){
                mcConst.LanguagesList = mcService.isObject(txt) ? txt : JSON.parse(txt);
            });

            $http(MC_RESOURCE.TextSource.errors.client + lang + '.errors.json').success(function(txt){
                mcConst.ErrorText = mcService.isObject(txt) ? txt : JSON.parse(txt);
            });

            $http(MC_RESOURCE.TextSource.www.admin + lang + '.json').success(function(txt){
                mcConst.LMSG_admin = mcService.isObject(txt) ? txt : JSON.parse(txt);
            });

            $http(MC_RESOURCE.TextSource.www.chat + lang + '.json').success(function(txt){
                mcConst.LMSG = mcService.isObject(txt) ? txt : JSON.parse(txt);

                if ($rootScope.isWebClient){
                    $scope.$broadcast('show' + mcConst.dataModels.Login, [lang]);
                } else {
                    $scope.prepareActions(lang);
                }

                initLockWindow();

                mcService.CheckNotification();

                webix.i18n.setLocale(lang);
            });

            if (window.McSpellChecker){
                $rootScope.spellCheckManager = new McSpellChecker();
            }
        }).apply(null, args)
    });

    $scope.$on(mcConst.lockInterface, function(){
        if ($scope.lockCount === 0){
            $scope.lockTimer = setTimeout(function(){
                lockWindow.show();

                mcService.getElementByClass('webix_modal')[0].className += ' noLockScreen';
            }, 100);
        }

        $scope.lockCount ++;
    });

    $scope.$on('hide' + mcConst.lockInterface, function(e, args){
        if (args[0] == 'all'){
            $scope.lockCount = 0;
        }

        if ($scope.lockCount > 0) {
            $scope.lockCount --;
        }

        if ($scope.lockCount === 0 || !mcConst.PingTimer) {
            clearTimeout($scope.lockTimer);

            lockWindow.hide();
        }
    });

    $scope.$on(_msg.ErrorMsg, function(e, args){
        if ($scope.errorMessagesIsShowed){
            if ($scope.errorMessages.length && $scope.errorMessages[$scope.errorMessages.length - 1][0] !== args[0]){
                $scope.errorMessages.push(args);
            }
        } else {
            displayError.apply(null, args);
        }
    });

    $scope.$on(_msg.hideAllErrors, function(){
        $scope.errorMessagesIsShowed = [];

        if ($rootScope.errorDialog) {
            webix.modalbox.hide($rootScope.errorDialog);
        }

        $rootScope.errorDialog = null;

        $scope.errorMessagesIsShowed = false;
    });

    $scope.$on(_msg.windowResize, function(e, args){
        if (mcService.isFunction(args[0])){
            resizeWndCb.push(args[0]);
        }
    });

    // =============================================================
         
    $scope.$emit(_msg.ChangLanguage, mcService.detectLang(webix.storage.local.get(mcConst.storageFields.lang)));

    webix.rules.isNotEmpty = function(val){
        return mcService.trim(val) != '';
    };

    webix.rules.registerLogin = function(val){
        var res = false;
        var str = mcService.trim(val);

        if (str !== ""){
            for (var i = 0; i < str.length; i++){
                if ($rootScope.restrictedSymbols.indexOf(str[i]) !== -1){
                    res = false;
                    
                    break;
                } else {
                    res = true;
                }
            }
        }

        return res;
    };

    webix.rules.isNumber = function(val){
        return /^\d+$/ig.test(val);// && !isNaN(parseInt(mcService.trim(val)));
    };

    webix.protoUI({
        name:"activeList"
    }, webix.ui.unitlist, webix.ActiveContent);

    webix.protoUI({
        name:"moveTemplate"
    }, webix.ui.view, webix.Movable, webix.EventSystem);

    webix.protoUI({
        name:"suggest",
        defaults:{
            filter:function(item,value){
                return item.value.toString().toLowerCase().indexOf(value.toLowerCase()) !== -1;
            }
        }
    }, webix.ui.suggest);

    webix.ready(function(){
        if (!webix.env.touch && webix.ui.scrollSize) {
            webix.CustomScroll.init();
        }
    });

    // ========================================================

    window.onbeforeunload = function() {
        if (!$rootScope.isWebClient){
            sendCMD([
                mcConst._CMD_.cs_quit,
                mcConst.SessionID
            ]);
        } else
        if (mcConst.LoggedIn){
            return mcService.Lang(40); // "40" : "Вы хотите завершить сеанс?",
        }
    };

    window.onunload = function(){
        if (mcConst.LoggedIn) {
            sendCMD([
                mcConst._CMD_.cs_quit,
                mcConst.SessionID
            ]);
        }
    };

    mcService.addEvent(window, "resize", setWindowSize);

}
"use strict";

if (!window.old_IE) {
    var units   = []
            // .concat(location.protocol === 'file:' ? { module: 'cLog', args: []} : [])
            .concat({ module: 'mcPlaySound',     args: ['$rootScope']})
            .concat({ module: 'mcConnect',       args: []})
            .concat({ module: 'mcCmdLoop',       args: ['mcConnect',  '$rootScope']})
            .concat({ module: 'CallStates',      args: []})
            .concat({ module: 'MediaCall',       args: []})
            .concat({ module: 'mcMedia',         args: ['mcPlaySound','$rootScope', 'MediaCall', 'CallStates']})
            .concat({ module: 'mcDialogsList',   args: ['$rootScope', 'mcPlaySound']})
            .concat({ module: 'mcFileUploading', args: ['$rootScope']})
            .concat({ module: 'mcStorage',       args: ['$rootScope']})
            .concat({ module: 'mcUploadProgress',args: ['$rootScope']})
            .concat(location.protocol === 'file:' ? { module: 'mcStatistics', args: ['$rootScope']} : [])
            .concat({ module: 'mcCmdParser',     args: ['mcConnect',  '$rootScope', 'mcPlaySound', 'mcStatistics']})

            .concat({ module: "mainController",  args: ['$scope', '$rootScope', 'mcCmdParser', 'mcCmdLoop', '$http',
                                                        '$location', 'mcStatistics']})

            .concat({ module: 'loginController',            args: ['$scope', '$rootScope', '$location']})
            .concat({ module: 'commonContactsController',   args: ['$scope', '$rootScope']})
            .concat({ module: 'personalContactsController', args: ['$scope', '$rootScope']})
            .concat({ module: 'chatFrameController',        args: ['$scope', '$rootScope', 'mcPlaySound']})
            .concat({ module: 'confUserListController',     args: ['$scope', '$rootScope']})
            .concat({ module: 'confManagerController',      args: ['$scope', '$rootScope']})
            .concat({ module: 'dialogsController',          args: ['$scope', '$rootScope', 'mcPlaySound']})
            .concat({ module: 'mainMenuController',         args: ['$scope', '$rootScope']})
            .concat({ module: 'privateInfoController',      args: ['$scope', '$rootScope', 'mcMedia', 'mcPlaySound']})
            .concat({ module: 'userProfileController',      args: ['$scope', '$rootScope']})
            .concat({ module: 'chatWrapperController',      args: ['$scope', '$rootScope']})
            .concat({ module: 'bbsController',              args: ['$scope', '$rootScope', 'mcPlaySound']})
            .concat({ module: 'kanbanController',           args: ['$scope', '$rootScope']})
            .concat({ module: 'commonFilesController',      args: ['$scope', '$rootScope']})
            .concat({ module: 'historyDialogsController',   args: ['$scope', '$rootScope']})
            .concat({ module: 'broadcastController',        args: ['$scope', '$rootScope']})

            .concat(location.protocol === 'file:' ? { module: 'updateController',        args: ['$scope', '$rootScope']} : [])
            .concat(location.protocol === 'file:' ? { module: 'viewLogsController',      args: ['$scope', '$rootScope']} : [])
            .concat(location.protocol === 'file:' ? { module: 'serverManagerController', args: ['$scope', '$rootScope']} : [])
            .concat(location.protocol === 'file:' ? { module: 'receiveFilesController',  args: ['$scope', '$rootScope']} : [])
            .concat(location.protocol === 'file:' ? { module: 'settingsController',      args: ['$scope', '$rootScope']} : [])
        ;

    window.mcService = servicesController('chat');
    window.mcLang    = mcService.Lang;

    mcComponents.units(units).start();
}
