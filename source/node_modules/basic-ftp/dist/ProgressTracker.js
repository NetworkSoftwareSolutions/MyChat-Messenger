"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Tracks progress of one socket data transfer at a time.
 */
var ProgressTracker = /** @class */ (function () {
    function ProgressTracker() {
        this.bytesOverall = 0;
        this.intervalMs = 500;
        this.onStop = noop;
        this.onHandle = noop;
    }
    /**
     * Register a new handler for progress info. Use `undefined` to disable reporting.
     */
    ProgressTracker.prototype.reportTo = function (onHandle) {
        if (onHandle === void 0) { onHandle = noop; }
        this.onHandle = onHandle;
    };
    /**
     * Start tracking transfer progress of a socket.
     *
     * @param socket  The socket to observe.
     * @param name  A name associated with this progress tracking, e.g. a filename.
     * @param type  The type of the transfer, typically "upload" or "download".
     */
    ProgressTracker.prototype.start = function (socket, name, type) {
        var _this = this;
        var lastBytes = 0;
        this.onStop = poll(this.intervalMs, function () {
            var bytes = socket.bytesRead + socket.bytesWritten;
            _this.bytesOverall += bytes - lastBytes;
            lastBytes = bytes;
            _this.onHandle({
                name: name,
                type: type,
                bytes: bytes,
                bytesOverall: _this.bytesOverall
            });
        });
    };
    /**
     * Stop tracking transfer progress.
     */
    ProgressTracker.prototype.stop = function () {
        this.onStop(false);
    };
    /**
     * Call the progress handler one more time, then stop tracking.
     */
    ProgressTracker.prototype.updateAndStop = function () {
        this.onStop(true);
    };
    return ProgressTracker;
}());
exports.ProgressTracker = ProgressTracker;
/**
 * Starts calling a callback function at a regular interval. The first call will go out
 * immediately. The function returns a function to stop the polling.
 */
function poll(intervalMs, updateFunc) {
    var id = setInterval(updateFunc, intervalMs);
    var stopFunc = function (stopWithUpdate) {
        clearInterval(id);
        if (stopWithUpdate) {
            updateFunc();
        }
        // Prevent repeated calls to stop calling handler.
        updateFunc = noop;
    };
    updateFunc();
    return stopFunc;
}
function noop() { }
