"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var fs_1 = require("fs");
var path_1 = require("path");
var tls_1 = require("tls");
var util_1 = require("util");
var FtpContext_1 = require("./FtpContext");
var nullObject_1 = require("./nullObject");
var parseList_1 = require("./parseList");
var ProgressTracker_1 = require("./ProgressTracker");
var StringWriter_1 = require("./StringWriter");
var fsReadDir = util_1.promisify(fs_1.readdir);
var fsMkDir = util_1.promisify(fs_1.mkdir);
var fsStat = util_1.promisify(fs_1.stat);
/**
 * Client offers an API to interact with an FTP server.
 */
var Client = /** @class */ (function () {
    /**
     * Instantiate an FTP client.
     *
     * @param timeout  Timeout in milliseconds, use 0 for no timeout. Optional, default is 30 seconds.
     */
    function Client(timeout) {
        if (timeout === void 0) { timeout = 30000; }
        this.ftp = new FtpContext_1.FTPContext(timeout);
        this.prepareTransfer = enterFirstCompatibleMode(enterPassiveModeIPv6, enterPassiveModeIPv4);
        this.parseList = parseList_1.parseList;
        this.progressTracker = new ProgressTracker_1.ProgressTracker();
    }
    /**
     * Close the client and all open socket connections.
     *
     * Close the client and all open socket connections. The client canâ€™t be used anymore after calling this method,
     * you have to either reconnect with `access` or `connect` or instantiate a new instance to continue any work.
     * A client is also closed automatically if any timeout or connection error occurs.
     */
    Client.prototype.close = function () {
        this.ftp.close();
        this.progressTracker.stop();
    };
    Object.defineProperty(Client.prototype, "closed", {
        /**
         * Returns true if the client is closed and can't be used anymore.
         */
        get: function () {
            return this.ftp.closed;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Connect (or reconnect) to an FTP server.
     *
     * This is an instance method and thus can be called multiple times during the lifecycle of a `Client`
     * instance. Whenever you do, the client is reset with a new control connection. This also implies that
     * you can reopen a `Client` instance that has been closed due to an error when reconnecting with this
     * method. In fact, reconnecting is the only way to continue using a closed `Client`.
     *
     * @param host  Host the client should connect to. Optional, default is "localhost".
     * @param port  Port the client should connect to. Optional, default is 21.
     */
    Client.prototype.connect = function (host, port) {
        var _this = this;
        if (host === void 0) { host = "localhost"; }
        if (port === void 0) { port = 21; }
        // The FTPContext is reset by assigning a new socket for the control connection.
        this.ftp.socket = this.ftp._newSocket();
        this.ftp.socket.connect({
            host: host,
            port: port,
            family: this.ftp.ipFamily
        }, function () { return _this.ftp.log("Connected to " + describeAddress(_this.ftp.socket)); });
        return this.ftp.handle(undefined, function (res, task) {
            if (res instanceof Error) {
                // The connection has been destroyed by the FTPContext at this point.
                task.reject(res);
            }
            else if (positiveCompletion(res.code)) {
                task.resolve(res);
            }
            // Reject all other codes, including 120 "Service ready in nnn minutes".
            else {
                _this.ftp.socket.destroy(); // Don't stay connected
                task.reject(new FtpContext_1.FTPError(res));
            }
        });
    };
    /**
     * Send an FTP command.
     *
     * If successful it will return a response object that contains the return code as well
     * as the whole message. Ignore FTP error codes if you don't want an exception to be thrown
     * if an FTP command didn't succeed.
     *
     * @param command  FTP command to send.
     * @param ignoreErrorCodes  Whether to ignore FTP error codes in result. Optional, default is false.
     */
    Client.prototype.send = function (command, ignoreErrorCodes) {
        if (ignoreErrorCodes === void 0) { ignoreErrorCodes = false; }
        return this.ftp.handle(command, function (res, task) {
            if (res instanceof FtpContext_1.FTPError) {
                if (ignoreErrorCodes) {
                    task.resolve({ code: res.code, message: res.message });
                }
                else {
                    task.reject(res);
                }
            }
            else if (res instanceof Error) {
                task.reject(res);
            }
            else {
                task.resolve(res);
            }
        });
    };
    /**
     * Upgrade the current socket connection to TLS.
     *
     * @param options  TLS options as in `tls.connect(options)`, optional.
     * @param command  Set the authentication command. Optional, default is "AUTH TLS".
     */
    Client.prototype.useTLS = function (options, command) {
        if (options === void 0) { options = {}; }
        if (command === void 0) { command = "AUTH TLS"; }
        return __awaiter(this, void 0, void 0, function () {
            var ret, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this.send(command)];
                    case 1:
                        ret = _b.sent();
                        _a = this.ftp;
                        return [4 /*yield*/, upgradeSocket(this.ftp.socket, options)];
                    case 2:
                        _a.socket = _b.sent();
                        this.ftp.tlsOptions = options; // Keep the TLS options for later data connections that should use the same options.
                        this.ftp.log("Control socket is using: " + describeTLS(this.ftp.socket));
                        return [2 /*return*/, ret];
                }
            });
        });
    };
    /**
     * Login a user with a password.
     *
     * @param user  Username to use for login. Optional, default is "anonymous".
     * @param password  Password to use for login. Optional, default is "guest".
     */
    Client.prototype.login = function (user, password) {
        var _this = this;
        if (user === void 0) { user = "anonymous"; }
        if (password === void 0) { password = "guest"; }
        this.ftp.log("Login security: " + describeTLS(this.ftp.socket));
        return this.ftp.handle("USER " + user, function (res, task) {
            if (res instanceof Error) {
                task.reject(res);
            }
            else if (positiveCompletion(res.code)) { // User logged in proceed OR Command superfluous
                task.resolve(res);
            }
            else if (res.code === 331) { // User name okay, need password
                _this.ftp.send("PASS " + password);
            }
            else { // Also report error on 332 (Need account)
                task.reject(new FtpContext_1.FTPError(res));
            }
        });
    };
    /**
     * Set the usual default settings.
     *
     * Settings used:
     * * Binary mode (TYPE I)
     * * File structure (STRU F)
     * * Additional settings for FTPS (PBSZ 0, PROT P)
     */
    Client.prototype.useDefaultSettings = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.send("TYPE I")]; // Binary mode
                    case 1:
                        _a.sent(); // Binary mode
                        return [4 /*yield*/, this.send("STRU F")]; // Use file structure
                    case 2:
                        _a.sent(); // Use file structure
                        if (!this.ftp.hasTLS) return [3 /*break*/, 5];
                        return [4 /*yield*/, this.send("PBSZ 0")]; // Set to 0 for TLS
                    case 3:
                        _a.sent(); // Set to 0 for TLS
                        return [4 /*yield*/, this.send("PROT P")]; // Protect channel (also for data connections)
                    case 4:
                        _a.sent(); // Protect channel (also for data connections)
                        _a.label = 5;
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Convenience method that calls `connect`, `useTLS`, `login` and `useDefaultSettings`.
     *
     * This is an instance method and thus can be called multiple times during the lifecycle of a `Client`
     * instance. Whenever you do, the client is reset with a new control connection. This also implies that
     * you can reopen a `Client` instance that has been closed due to an error when reconnecting with this
     * method. In fact, reconnecting is the only way to continue using a closed `Client`.
     */
    Client.prototype.access = function (options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var welcome;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.connect(options.host, options.port)];
                    case 1:
                        welcome = _a.sent();
                        if (!(options.secure === true)) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.useTLS(options.secureOptions)];
                    case 2:
                        _a.sent();
                        _a.label = 3;
                    case 3: return [4 /*yield*/, this.login(options.user, options.password)];
                    case 4:
                        _a.sent();
                        return [4 /*yield*/, this.useDefaultSettings()];
                    case 5:
                        _a.sent();
                        return [2 /*return*/, welcome];
                }
            });
        });
    };
    /**
     * Get the current working directory.
     */
    Client.prototype.pwd = function () {
        return __awaiter(this, void 0, void 0, function () {
            var res, parsed;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.send("PWD")
                        // The directory is part of the return message, for example:
                        // 257 "/this/that" is current directory.
                    ];
                    case 1:
                        res = _a.sent();
                        parsed = res.message.match(/"(.+)"/);
                        if (parsed === null || parsed[1] === undefined) {
                            throw new Error("Can't parse response to command 'PWD': " + res.message);
                        }
                        return [2 /*return*/, parsed[1]];
                }
            });
        });
    };
    /**
     * Get a description of supported features.
     *
     * This sends the FEAT command and parses the result into a Map where keys correspond to available commands
     * and values hold further information. Be aware that your FTP servers might not support this
     * command in which case this method will not throw an exception but just return an empty Map.
     */
    Client.prototype.features = function () {
        return __awaiter(this, void 0, void 0, function () {
            var res, features;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.send("FEAT", true)];
                    case 1:
                        res = _a.sent();
                        features = new Map();
                        // Not supporting any special features will be reported with a single line.
                        if (res.code < 400 && isMultiline(res.message)) {
                            // The first and last line wrap the multiline response, ignore them.
                            res.message.split("\n").slice(1, -1).forEach(function (line) {
                                // A typical lines looks like: " REST STREAM" or " MDTM".
                                // Servers might not use an indentation though.
                                var entry = line.trim().split(" ");
                                features.set(entry[0], entry[1] || "");
                            });
                        }
                        return [2 /*return*/, features];
                }
            });
        });
    };
    /**
     * Set the working directory.
     */
    Client.prototype.cd = function (path) {
        return __awaiter(this, void 0, void 0, function () {
            var validPath;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.protectWhitespace(path)];
                    case 1:
                        validPath = _a.sent();
                        return [2 /*return*/, this.send("CWD " + validPath)];
                }
            });
        });
    };
    /**
     * Switch to the parent directory of the working directory.
     */
    Client.prototype.cdup = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.send("CDUP")];
            });
        });
    };
    /**
     * Get the last modified time of a file. This is not supported by every FTP server, in which case
     * calling this method will throw an exception.
     */
    Client.prototype.lastMod = function (path) {
        return __awaiter(this, void 0, void 0, function () {
            var validPath, res, msg, date;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.protectWhitespace(path)];
                    case 1:
                        validPath = _a.sent();
                        return [4 /*yield*/, this.send("MDTM " + validPath)
                            // Message contains response code and modified time in the format: YYYYMMDDHHMMSS[.sss]
                            // For example `213 19991005213102` or `213 19980615100045.014`.
                        ];
                    case 2:
                        res = _a.sent();
                        msg = res.message;
                        date = new Date();
                        date.setUTCFullYear(+msg.slice(4, 8), +msg.slice(8, 10) - 1, +msg.slice(10, 12));
                        date.setUTCHours(+msg.slice(12, 14), +msg.slice(14, 16), +msg.slice(16, 18), +msg.slice(19, 22));
                        return [2 /*return*/, date];
                }
            });
        });
    };
    /**
     * Get the size of a file.
     */
    Client.prototype.size = function (path) {
        return __awaiter(this, void 0, void 0, function () {
            var validPath, command, res, size;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.protectWhitespace(path)];
                    case 1:
                        validPath = _a.sent();
                        command = "SIZE " + validPath;
                        return [4 /*yield*/, this.send(command)
                            // The size is part of the response message, for example: "213 555555". It's
                            // possible that there is a commmentary appended like "213 5555, some commentary".
                        ];
                    case 2:
                        res = _a.sent();
                        size = parseInt(res.message.slice(4), 10);
                        if (Number.isNaN(size)) {
                            throw new Error("Can't parse response to command '" + command + "' as a numerical value: " + res.message);
                        }
                        return [2 /*return*/, size];
                }
            });
        });
    };
    /**
     * Rename a file.
     *
     * Depending on the FTP server this might also be used to move a file from one
     * directory to another by providing full paths.
     */
    Client.prototype.rename = function (srcPath, destPath) {
        return __awaiter(this, void 0, void 0, function () {
            var validSrc, validDest;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.protectWhitespace(srcPath)];
                    case 1:
                        validSrc = _a.sent();
                        return [4 /*yield*/, this.protectWhitespace(destPath)];
                    case 2:
                        validDest = _a.sent();
                        return [4 /*yield*/, this.send("RNFR " + validSrc)];
                    case 3:
                        _a.sent();
                        return [2 /*return*/, this.send("RNTO " + validDest)];
                }
            });
        });
    };
    /**
     * Remove a file from the current working directory.
     *
     * You can ignore FTP error return codes which won't throw an exception if e.g.
     * the file doesn't exist.
     */
    Client.prototype.remove = function (path, ignoreErrorCodes) {
        if (ignoreErrorCodes === void 0) { ignoreErrorCodes = false; }
        return __awaiter(this, void 0, void 0, function () {
            var validPath;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.protectWhitespace(path)];
                    case 1:
                        validPath = _a.sent();
                        return [2 /*return*/, this.send("DELE " + validPath, ignoreErrorCodes)];
                }
            });
        });
    };
    /**
     * Report transfer progress for any upload or download to a given handler.
     *
     * This will also reset the overall transfer counter that can be used for multiple transfers. You can
     * also pass `undefined` as a handler to stop reporting to an earlier one.
     *
     * @param handler  Handler function to call on transfer progress.
     */
    Client.prototype.trackProgress = function (handler) {
        this.progressTracker.bytesOverall = 0;
        this.progressTracker.reportTo(handler);
    };
    /**
     * Upload data from a readable stream and store it as a file with a given filename in the current working directory.
     *
     * @param source  The stream to read from.
     * @param remotePath  The path of the remote file to write to.
     */
    Client.prototype.upload = function (source, remotePath) {
        return __awaiter(this, void 0, void 0, function () {
            var validPath;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.protectWhitespace(remotePath)];
                    case 1:
                        validPath = _a.sent();
                        return [4 /*yield*/, this.prepareTransfer(this)];
                    case 2:
                        _a.sent();
                        return [2 /*return*/, upload(this.ftp, this.progressTracker, source, validPath)];
                }
            });
        });
    };
    /**
     * Download a file with a given filename from the current working directory
     * and pipe its data to a writable stream. You may optionally start at a specific
     * offset, for example to resume a cancelled transfer.
     *
     * @param destination  The stream to write to.
     * @param remotePath  The name of the remote file to read from.
     * @param startAt  The offset to start at.
     */
    Client.prototype.download = function (destination, remotePath, startAt) {
        if (startAt === void 0) { startAt = 0; }
        return __awaiter(this, void 0, void 0, function () {
            var validPath, command;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.protectWhitespace(remotePath)];
                    case 1:
                        validPath = _a.sent();
                        return [4 /*yield*/, this.prepareTransfer(this)];
                    case 2:
                        _a.sent();
                        command = startAt > 0 ? "REST " + startAt : "RETR " + validPath;
                        return [2 /*return*/, download(this.ftp, this.progressTracker, destination, command, validPath)];
                }
            });
        });
    };
    /**
     * List files and directories in the current working directory.
     */
    Client.prototype.list = function () {
        return __awaiter(this, void 0, void 0, function () {
            var writable, progressTracker, text;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.prepareTransfer(this)];
                    case 1:
                        _a.sent();
                        writable = new StringWriter_1.StringWriter();
                        progressTracker = nullObject_1.createNullObject() // Don't track progress of list transfers.
                        ;
                        return [4 /*yield*/, download(this.ftp, progressTracker, writable, "LIST -a")];
                    case 2:
                        _a.sent();
                        text = writable.getText(this.ftp.encoding);
                        this.ftp.log(text);
                        return [2 /*return*/, this.parseList(text)];
                }
            });
        });
    };
    /**
     * Remove a directory and all of its content.
     *
     * After successfull completion the current working directory will be the parent
     * of the removed directory if possible.
     *
     * @param remoteDirPath  The path of the remote directory to delete.
     * @example client.removeDir("foo") // Remove directory 'foo' using a relative path.
     * @example client.removeDir("foo/bar") // Remove directory 'bar' using a relative path.
     * @example client.removeDir("/foo/bar") // Remove directory 'bar' using an absolute path.
     * @example client.removeDir("/") // Remove everything.
     */
    Client.prototype.removeDir = function (remoteDirPath) {
        return __awaiter(this, void 0, void 0, function () {
            var workingDir;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.cd(remoteDirPath)];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, this.clearWorkingDir()
                            // Remove the directory itself if we're not already on root.
                        ];
                    case 2:
                        _a.sent();
                        return [4 /*yield*/, this.pwd()];
                    case 3:
                        workingDir = _a.sent();
                        if (!(workingDir !== "/")) return [3 /*break*/, 6];
                        return [4 /*yield*/, this.cdup()];
                    case 4:
                        _a.sent();
                        return [4 /*yield*/, this.removeEmptyDir(remoteDirPath)];
                    case 5:
                        _a.sent();
                        _a.label = 6;
                    case 6: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Remove all files and directories in the working directory without removing
     * the working directory itself.
     */
    Client.prototype.clearWorkingDir = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _i, _a, file;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _i = 0;
                        return [4 /*yield*/, this.list()];
                    case 1:
                        _a = _b.sent();
                        _b.label = 2;
                    case 2:
                        if (!(_i < _a.length)) return [3 /*break*/, 10];
                        file = _a[_i];
                        if (!file.isDirectory) return [3 /*break*/, 7];
                        return [4 /*yield*/, this.cd(file.name)];
                    case 3:
                        _b.sent();
                        return [4 /*yield*/, this.clearWorkingDir()];
                    case 4:
                        _b.sent();
                        return [4 /*yield*/, this.cdup()];
                    case 5:
                        _b.sent();
                        return [4 /*yield*/, this.removeEmptyDir(file.name)];
                    case 6:
                        _b.sent();
                        return [3 /*break*/, 9];
                    case 7: return [4 /*yield*/, this.remove(file.name)];
                    case 8:
                        _b.sent();
                        _b.label = 9;
                    case 9:
                        _i++;
                        return [3 /*break*/, 2];
                    case 10: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Upload the contents of a local directory to the working directory.
     *
     * You can optionally provide a `remoteDirName` to put the contents inside a directory which
     * will be created if necessary. This will overwrite existing files with the same names and
     * reuse existing directories. Unrelated files and directories will remain untouched.
     *
     * @param localDirPath  A local path, e.g. "foo/bar" or "../test"
     * @param remoteDirName  The name of the remote directory. If undefined, directory contents will be uploaded to the working directory.
     */
    Client.prototype.uploadDir = function (localDirPath, remoteDirName) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(remoteDirName !== undefined)) return [3 /*break*/, 2];
                        if (remoteDirName.indexOf("/") !== -1) {
                            throw new Error("Path provided '" + remoteDirName + "' instead of single directory name.");
                        }
                        return [4 /*yield*/, openDir(this, remoteDirName)];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2: return [4 /*yield*/, uploadDirContents(this, localDirPath)
                        // The working directory should stay the same after this operation.
                    ];
                    case 3:
                        _a.sent();
                        if (!(remoteDirName !== undefined)) return [3 /*break*/, 5];
                        return [4 /*yield*/, this.cdup()];
                    case 4:
                        _a.sent();
                        _a.label = 5;
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Download all files and directories of the working directory to a local directory.
     *
     * @param localDirPath  The local directory to download to.
     */
    Client.prototype.downloadDir = function (localDirPath) {
        return __awaiter(this, void 0, void 0, function () {
            var _i, _a, file, localPath, writable;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, ensureLocalDirectory(localDirPath)];
                    case 1:
                        _b.sent();
                        _i = 0;
                        return [4 /*yield*/, this.list()];
                    case 2:
                        _a = _b.sent();
                        _b.label = 3;
                    case 3:
                        if (!(_i < _a.length)) return [3 /*break*/, 10];
                        file = _a[_i];
                        localPath = path_1.join(localDirPath, file.name);
                        if (!file.isDirectory) return [3 /*break*/, 7];
                        return [4 /*yield*/, this.cd(file.name)];
                    case 4:
                        _b.sent();
                        return [4 /*yield*/, this.downloadDir(localPath)];
                    case 5:
                        _b.sent();
                        return [4 /*yield*/, this.cdup()];
                    case 6:
                        _b.sent();
                        return [3 /*break*/, 9];
                    case 7:
                        writable = fs_1.createWriteStream(localPath);
                        return [4 /*yield*/, this.download(writable, file.name)];
                    case 8:
                        _b.sent();
                        _b.label = 9;
                    case 9:
                        _i++;
                        return [3 /*break*/, 3];
                    case 10: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Make sure a given remote path exists, creating all directories as necessary.
     * This function also changes the current working directory to the given path.
     */
    Client.prototype.ensureDir = function (remoteDirPath) {
        return __awaiter(this, void 0, void 0, function () {
            var names, _i, names_1, name_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!remoteDirPath.startsWith("/")) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.cd("/")];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2:
                        names = remoteDirPath.split("/").filter(function (name) { return name !== ""; });
                        _i = 0, names_1 = names;
                        _a.label = 3;
                    case 3:
                        if (!(_i < names_1.length)) return [3 /*break*/, 6];
                        name_1 = names_1[_i];
                        return [4 /*yield*/, openDir(this, name_1)];
                    case 4:
                        _a.sent();
                        _a.label = 5;
                    case 5:
                        _i++;
                        return [3 /*break*/, 3];
                    case 6: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Remove an empty directory, will fail if not empty.
     */
    Client.prototype.removeEmptyDir = function (path) {
        return __awaiter(this, void 0, void 0, function () {
            var validPath;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.protectWhitespace(path)];
                    case 1:
                        validPath = _a.sent();
                        return [2 /*return*/, this.send("RMD " + validPath)];
                }
            });
        });
    };
    /**
     * FTP servers can't handle filenames that have leading whitespace. This method transforms
     * a given path to fix that issue for most cases.
     */
    Client.prototype.protectWhitespace = function (path) {
        return __awaiter(this, void 0, void 0, function () {
            var pwd, absolutePathPrefix;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!path.startsWith(" ")) {
                            return [2 /*return*/, path];
                        }
                        return [4 /*yield*/, this.pwd()];
                    case 1:
                        pwd = _a.sent();
                        absolutePathPrefix = pwd.endsWith("/") ? pwd : pwd + "/";
                        return [2 /*return*/, absolutePathPrefix + path];
                }
            });
        });
    };
    return Client;
}());
exports.Client = Client;
/**
 * Return true if an FTP return code describes a positive completion.
 */
function positiveCompletion(code) {
    return code >= 200 && code < 300;
}
/**
 * Return true if an FTP return code describes a positive intermediate response.
 */
function positiveIntermediate(code) {
    return code >= 300 && code < 400;
}
/**
 * Returns true if an FTP response line is the beginning of a multiline response.
 */
function isMultiline(line) {
    return /^\d\d\d-/.test(line);
}
/**
 * Returns a string describing the encryption on a given socket instance.
 */
function describeTLS(socket) {
    if (socket instanceof tls_1.TLSSocket) {
        var protocol = socket.getProtocol();
        return protocol ? protocol : "Server socket or disconnected client socket";
    }
    return "No encryption";
}
/**
 * Returns a string describing the remote address of a socket.
 */
function describeAddress(socket) {
    if (socket.remoteFamily === "IPv6") {
        return "[" + socket.remoteAddress + "]:" + socket.remotePort;
    }
    return socket.remoteAddress + ":" + socket.remotePort;
}
/**
 * Upgrade a socket connection with TLS.
 */
function upgradeSocket(socket, options) {
    return new Promise(function (resolve, reject) {
        var tlsOptions = Object.assign({}, options, {
            socket: socket // Establish the secure connection using an existing socket connection.
        });
        var tlsSocket = tls_1.connect(tlsOptions, function () {
            // Make sure the certificate is valid if an unauthorized one should be rejected.
            var expectCertificate = tlsOptions.rejectUnauthorized !== false;
            if (expectCertificate && !tlsSocket.authorized) {
                reject(tlsSocket.authorizationError);
            }
            else {
                // Remove error listener below.
                tlsSocket.removeAllListeners("error");
                resolve(tlsSocket);
            }
        }).once("error", function (error) {
            reject(error);
        });
    });
}
/**
 * Try all available transfer strategies and pick the first one that works. Update `client` to
 * use the working strategy for all successive transfer requests.
 *
 * @param strategies
 * @returns a function that will try the provided strategies.
 */
function enterFirstCompatibleMode() {
    var strategies = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        strategies[_i] = arguments[_i];
    }
    return function autoDetect(client) {
        return __awaiter(this, void 0, void 0, function () {
            var _i, strategies_1, strategy, res, err_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        client.ftp.log("Trying to find optimal transfer strategy...");
                        _i = 0, strategies_1 = strategies;
                        _a.label = 1;
                    case 1:
                        if (!(_i < strategies_1.length)) return [3 /*break*/, 6];
                        strategy = strategies_1[_i];
                        _a.label = 2;
                    case 2:
                        _a.trys.push([2, 4, , 5]);
                        return [4 /*yield*/, strategy(client)];
                    case 3:
                        res = _a.sent();
                        client.ftp.log("Optimal transfer strategy found.");
                        client.prepareTransfer = strategy; // First strategy that works will be used from now on.
                        return [2 /*return*/, res];
                    case 4:
                        err_1 = _a.sent();
                        // Receiving an FTPError means that the last transfer strategy failed and we should
                        // try the next one. Any other exception should stop the evaluation of strategies because
                        // something else went wrong.
                        if (!(err_1 instanceof FtpContext_1.FTPError)) {
                            throw err_1;
                        }
                        return [3 /*break*/, 5];
                    case 5:
                        _i++;
                        return [3 /*break*/, 1];
                    case 6: throw new Error("None of the available transfer strategies work.");
                }
            });
        });
    };
}
/**
 * Prepare a data socket using passive mode over IPv6.
 */
function enterPassiveModeIPv6(client) {
    return __awaiter(this, void 0, void 0, function () {
        var res, port, controlHost;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, client.send("EPSV")];
                case 1:
                    res = _a.sent();
                    port = parseIPv6PasvResponse(res.message);
                    if (!port) {
                        throw new Error("Can't parse EPSV response: " + res.message);
                    }
                    controlHost = client.ftp.socket.remoteAddress;
                    if (controlHost === undefined) {
                        throw new Error("Control socket is disconnected, can't get remote address.");
                    }
                    return [4 /*yield*/, connectForPassiveTransfer(controlHost, port, client.ftp)];
                case 2:
                    _a.sent();
                    return [2 /*return*/, res];
            }
        });
    });
}
/**
 * Parse an EPSV response. Returns only the port as in EPSV the host of the control connection is used.
 */
function parseIPv6PasvResponse(message) {
    // Get port from EPSV response, e.g. "229 Entering Extended Passive Mode (|||6446|)"
    var groups = message.match(/\|{3}(.+)\|/);
    if (groups === null || groups[1] === undefined) {
        throw new Error("Can't parse response to 'EPSV': " + message);
    }
    var port = parseInt(groups[1], 10);
    if (Number.isNaN(port)) {
        throw new Error("Can't parse response to 'EPSV', port is not a number: " + message);
    }
    return port;
}
/**
 * Prepare a data socket using passive mode over IPv4.
 */
function enterPassiveModeIPv4(client) {
    return __awaiter(this, void 0, void 0, function () {
        var res, target, controlHost;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, client.send("PASV")];
                case 1:
                    res = _a.sent();
                    target = parseIPv4PasvResponse(res.message);
                    if (!target) {
                        throw new Error("Can't parse PASV response: " + res.message);
                    }
                    controlHost = client.ftp.socket.remoteAddress;
                    if (ipIsPrivateV4Address(target.host) && controlHost && !ipIsPrivateV4Address(controlHost)) {
                        target.host = controlHost;
                    }
                    return [4 /*yield*/, connectForPassiveTransfer(target.host, target.port, client.ftp)];
                case 2:
                    _a.sent();
                    return [2 /*return*/, res];
            }
        });
    });
}
/**
 * Parse a PASV response.
 */
function parseIPv4PasvResponse(message) {
    // Get host and port from PASV response, e.g. "227 Entering Passive Mode (192,168,1,100,10,229)"
    var groups = message.match(/([-\d]+,[-\d]+,[-\d]+,[-\d]+),([-\d]+),([-\d]+)/);
    if (groups === null || groups.length !== 4) {
        throw new Error("Can't parse response to 'PASV': " + message);
    }
    return {
        host: groups[1].replace(/,/g, "."),
        port: (parseInt(groups[2], 10) & 255) * 256 + (parseInt(groups[3], 10) & 255)
    };
}
/**
 * Returns true if an IP is a private address according to https://tools.ietf.org/html/rfc1918#section-3.
 * This will handle IPv4-mapped IPv6 addresses correctly but return false for all other IPv6 addresses.
 *
 * @param ip  The IP as a string, e.g. "192.168.0.1"
 */
function ipIsPrivateV4Address(ip) {
    if (ip === void 0) { ip = ""; }
    // Handle IPv4-mapped IPv6 addresses like ::ffff:192.168.0.1
    if (ip.startsWith("::ffff:")) {
        ip = ip.substr(7); // Strip ::ffff: prefix
    }
    var octets = ip.split(".").map(function (o) { return parseInt(o, 10); });
    return octets[0] === 10 // 10.0.0.0 - 10.255.255.255
        || (octets[0] === 172 && octets[1] >= 16 && octets[1] <= 31) // 172.16.0.0 - 172.31.255.255
        || (octets[0] === 192 && octets[1] === 168); // 192.168.0.0 - 192.168.255.255
}
function connectForPassiveTransfer(host, port, ftp) {
    return new Promise(function (resolve, reject) {
        var handleConnErr = function (err) {
            err.message = "Can't open data connection in passive mode: " + err.message;
            reject(err);
        };
        var socket = ftp._newSocket();
        socket.on("error", handleConnErr);
        socket.connect({ port: port, host: host, family: ftp.ipFamily }, function () {
            if (ftp.socket instanceof tls_1.TLSSocket) {
                socket = tls_1.connect(Object.assign({}, ftp.tlsOptions, {
                    // Upgrade the existing socket connection.
                    socket: socket,
                    // Reuse the TLS session negotiated earlier when the control connection
                    // was upgraded. Servers expect this because it provides additional
                    // security. If a completely new session would be negotiated, a hacker
                    // could guess the port and connect to the new data connection before we do
                    // by just starting his/her own TLS session.
                    session: ftp.socket.getSession()
                }));
                // It's the responsibility of the transfer task to wait until the
                // TLS socket issued the event 'secureConnect'. We can't do this
                // here because some servers will start upgrading after the
                // specific transfer request has been made. List and download don't
                // have to wait for this event because the server sends whenever it
                // is ready. But for upload this has to be taken into account,
                // see the details in the upload() function below.
            }
            // Let the FTPContext listen to errors from now on, remove local handler.
            socket.removeListener("error", handleConnErr);
            ftp.dataSocket = socket;
            resolve();
        });
    });
}
/**
 * Helps resolving/rejecting transfers.
 *
 * This is used internally for all FTP transfers. For example when downloading, the server might confirm
 * with "226 Transfer complete" when in fact the download on the data connection has not finished
 * yet. With all transfers we make sure that a) the result arrived and b) has been confirmed by
 * e.g. the control connection. We just don't know in which order this will happen.
 */
var TransferResolver = /** @class */ (function () {
    /**
     * Instantiate a TransferResolver
     */
    function TransferResolver(ftp, progress) {
        this.ftp = ftp;
        this.progress = progress;
        this.response = undefined;
        this.dataTransferDone = false;
    }
    /**
     * Mark the beginning of a transfer.
     *
     * @param name - Name of the transfer, usually the filename.
     * @param type - Type of transfer, usually "upload" or "download".
     */
    TransferResolver.prototype.onDataStart = function (name, type) {
        // Let the data socket be in charge of tracking timeouts during transfer.
        // The control socket sits idle during this time anyway and might provoke
        // a timeout unnecessarily. The control connection will take care
        // of timeouts again once data transfer is complete or failed.
        if (this.ftp.dataSocket === undefined) {
            throw new Error("Data transfer should start but there is no data connection.");
        }
        this.ftp.socket.setTimeout(0);
        this.ftp.dataSocket.setTimeout(this.ftp.timeout);
        this.progress.start(this.ftp.dataSocket, name, type);
    };
    /**
     * The data connection has finished the transfer.
     */
    TransferResolver.prototype.onDataDone = function (task) {
        this.progress.updateAndStop();
        // Hand-over timeout tracking back to the control connection. It's possible that
        // we don't receive the response over the control connection that the transfer is
        // done. In this case, we want to correctly associate the resulting timeout with
        // the control connection.
        this.ftp.socket.setTimeout(this.ftp.timeout);
        if (this.ftp.dataSocket) {
            this.ftp.dataSocket.setTimeout(0);
        }
        this.dataTransferDone = true;
        this.tryResolve(task);
    };
    /**
     * The control connection reports the transfer as finished.
     */
    TransferResolver.prototype.onControlDone = function (task, response) {
        this.response = response;
        this.tryResolve(task);
    };
    /**
     * An error has been reported and the task should be rejected.
     */
    TransferResolver.prototype.onError = function (task, err) {
        this.progress.updateAndStop();
        this.ftp.socket.setTimeout(this.ftp.timeout);
        this.ftp.dataSocket = undefined;
        task.reject(err);
    };
    /**
     * Control connection sent an unexpected request requiring a response from our part. We
     * can't provide that (because unknown) and have to close the contrext with an error because
     * the FTP server is now caught up in a state we can't resolve.
     */
    TransferResolver.prototype.onUnexpectedRequest = function (response) {
        var err = new Error("Unexpected FTP response is requesting an answer: " + response.message);
        this.ftp.closeWithError(err);
    };
    TransferResolver.prototype.tryResolve = function (task) {
        // To resolve, we need both control and data connection to report that the transfer is done.
        var canResolve = this.dataTransferDone && this.response !== undefined;
        if (canResolve) {
            this.ftp.dataSocket = undefined;
            task.resolve(this.response);
        }
    };
    return TransferResolver;
}());
/**
 * Upload stream data as a file. For example:
 *
 * `upload(ftp, fs.createReadStream(localFilePath), remoteFilename)`
 */
function upload(ftp, progress, source, remoteFilename) {
    var resolver = new TransferResolver(ftp, progress);
    var command = "STOR " + remoteFilename;
    return ftp.handle(command, function (res, task) {
        if (res instanceof Error) {
            resolver.onError(task, res);
        }
        else if (res.code === 150 || res.code === 125) { // Ready to upload
            var dataSocket_1 = ftp.dataSocket;
            if (!dataSocket_1) {
                resolver.onError(task, new Error("Upload should begin but no data connection is available."));
                return;
            }
            // If we are using TLS, we have to wait until the dataSocket issued
            // 'secureConnect'. If this hasn't happened yet, getCipher() returns undefined.
            var canUpload = "getCipher" in dataSocket_1 ? dataSocket_1.getCipher() !== undefined : true;
            onConditionOrEvent(canUpload, dataSocket_1, "secureConnect", function () {
                ftp.log("Uploading to " + describeAddress(dataSocket_1) + " (" + describeTLS(dataSocket_1) + ")");
                resolver.onDataStart(remoteFilename, "upload");
                source.pipe(dataSocket_1).once("finish", function () {
                    dataSocket_1.destroy(); // Explicitly close/destroy the socket to signal the end.
                    resolver.onDataDone(task);
                });
            });
        }
        else if (positiveCompletion(res.code)) { // Transfer complete
            resolver.onControlDone(task, res);
        }
        else if (positiveIntermediate(res.code)) {
            resolver.onUnexpectedRequest(res);
        }
        // Ignore all other positive preliminary response codes (< 200)
    });
}
/**
 * Download data from the data connection. Used for downloading files and directory listings.
 */
function download(ftp, progress, destination, command, remoteFilename) {
    if (remoteFilename === void 0) { remoteFilename = ""; }
    if (!ftp.dataSocket) {
        throw new Error("Download will be initiated but no data connection is available.");
    }
    // It's possible that data transmission begins before the control socket
    // receives the announcement. Start listening for data immediately.
    ftp.dataSocket.pipe(destination);
    var resolver = new TransferResolver(ftp, progress);
    return ftp.handle(command, function (res, task) {
        if (res instanceof Error) {
            resolver.onError(task, res);
        }
        else if (res.code === 150 || res.code === 125) { // Ready to download
            var dataSocket = ftp.dataSocket;
            if (!dataSocket) {
                resolver.onError(task, new Error("Download should begin but no data connection is available."));
                return;
            }
            ftp.log("Downloading from " + describeAddress(dataSocket) + " (" + describeTLS(dataSocket) + ")");
            resolver.onDataStart(remoteFilename, "download");
            // Confirm the transfer as soon as the data socket transmission ended.
            // It's possible, though, that the data transmission is complete before
            // the control socket receives the accouncement that it will begin.
            // Check if the data socket is not already closed.
            onConditionOrEvent(dataSocket.destroyed, dataSocket, "end", function () { return resolver.onDataDone(task); });
        }
        else if (res.code === 350) { // Restarting at startAt.
            ftp.send("RETR " + remoteFilename);
        }
        else if (positiveCompletion(res.code)) { // Transfer complete
            resolver.onControlDone(task, res);
        }
        else if (positiveIntermediate(res.code)) {
            resolver.onUnexpectedRequest(res);
        }
        // Ignore all other positive preliminary response codes (< 200)
    });
}
/**
 * Calls a function immediately if a condition is met or subscribes to an event and calls
 * it once the event is emitted.
 *
 * @param condition  The condition to test.
 * @param emitter  The emitter to use if the condition is not met.
 * @param eventName  The event to subscribe to if the condition is not met.
 * @param action  The function to call.
 */
function onConditionOrEvent(condition, emitter, eventName, action) {
    if (condition === true) {
        action();
    }
    else {
        emitter.once(eventName, function () { return action(); });
    }
}
/**
 * Upload the contents of a local directory to the working directory. This will overwrite
 * existing files and reuse existing directories.
 */
function uploadDirContents(client, localDirPath) {
    return __awaiter(this, void 0, void 0, function () {
        var files, _i, files_1, file, fullPath, stats;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, fsReadDir(localDirPath)];
                case 1:
                    files = _a.sent();
                    _i = 0, files_1 = files;
                    _a.label = 2;
                case 2:
                    if (!(_i < files_1.length)) return [3 /*break*/, 10];
                    file = files_1[_i];
                    fullPath = path_1.join(localDirPath, file);
                    return [4 /*yield*/, fsStat(fullPath)];
                case 3:
                    stats = _a.sent();
                    if (!stats.isFile()) return [3 /*break*/, 5];
                    return [4 /*yield*/, client.upload(fs_1.createReadStream(fullPath), file)];
                case 4:
                    _a.sent();
                    return [3 /*break*/, 9];
                case 5:
                    if (!stats.isDirectory()) return [3 /*break*/, 9];
                    return [4 /*yield*/, openDir(client, file)];
                case 6:
                    _a.sent();
                    return [4 /*yield*/, uploadDirContents(client, fullPath)];
                case 7:
                    _a.sent();
                    return [4 /*yield*/, client.cdup()];
                case 8:
                    _a.sent();
                    _a.label = 9;
                case 9:
                    _i++;
                    return [3 /*break*/, 2];
                case 10: return [2 /*return*/];
            }
        });
    });
}
/**
 * Try to create a directory and enter it. This will not raise an exception if the directory
 * couldn't be created if for example it already exists.
 */
function openDir(client, dirName) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, client.send("MKD " + dirName, true)]; // Ignore FTP error codes
                case 1:
                    _a.sent(); // Ignore FTP error codes
                    return [4 /*yield*/, client.cd(dirName)];
                case 2:
                    _a.sent();
                    return [2 /*return*/];
            }
        });
    });
}
function ensureLocalDirectory(path) {
    return __awaiter(this, void 0, void 0, function () {
        var err_2;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    _a.trys.push([0, 2, , 4]);
                    return [4 /*yield*/, fsStat(path)];
                case 1:
                    _a.sent();
                    return [3 /*break*/, 4];
                case 2:
                    err_2 = _a.sent();
                    return [4 /*yield*/, fsMkDir(path)];
                case 3:
                    _a.sent();
                    return [3 /*break*/, 4];
                case 4: return [2 /*return*/];
            }
        });
    });
}
