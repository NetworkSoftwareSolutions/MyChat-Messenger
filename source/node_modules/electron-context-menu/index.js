'use strict';

const electron = require('electron');
// const ipc      = electron.ipcMain;

let download = null;
let mainWin  = null;
let addList  = null;

function ExtractFileName(Path){
    var count = 0;

    for (var i = Path.length - 1; i >= 0; i--){
        count ++;

        if ((Path[i] === '\\') || (Path[i] === '/')) {
            return Path.slice(i + 1, i + count);
        }
    }

    return Path;
}

function ExtractPath(Path){
    for (var i = Path.length - 1; i >= 0; i--){
        if ((Path[i] === '\\') || (Path[i] === '/')) {
            return Path.slice(0, i);
        }
    }

    return Path;
}

function getLinkInfoByXY(win, x, y) {
    win.webContents.executeJavaScript(`
        var _electronHandler = require("electron").ipcRenderer;
        var x = "XXX";
        var y = "YYY";
        var link = document.elementFromPoint(x, y);
        _electronHandler.send("__FILE_LINK_DATA", {
            id      : link.id, 
            href    : link.href, 
            
            filePath: link.getAttribute("filepath"),
            fileDT  : link.getAttribute("filedt"),
            fileSize: link.getAttribute("filesize")
        });
    `.replace("XXX", x).replace('YYY', y));
}

function create(win, opts) {
	(win.webContents || win.getWebContents()).on('context-menu', (e, props) => {
	    if (props){
            const editFlags = props.editFlags;
            const hasText   = props.selectionText.trim().length > 0;
            const can       = type => editFlags[`can${type}`] && hasText;

            let linkUrl = props.linkURL || props.srcURL || (["png", "jpg", "jpeg", "bmp"].indexOf(props.pageURL.split('.')[props.pageURL.split('.').length - 1]) !== -1 ? props.pageURL : "");

            e.preventDefault();

            let menuTpl = [{
                type: 'separator'
            }, {
                label  : 'Cut',
                role   : can('Cut') ? 'cut' : '',
                enabled: can('Cut'),
                visible: props.isEditable
            }, {
                label  : 'Copy',
                role   : can('Copy') ? 'copy' : '',
                enabled: can('Copy'),
                visible: props.isEditable || hasText
            }, {
                label  : 'Paste',
                role   : editFlags.canPaste ? 'paste' : '',
                enabled: editFlags.canPaste,
                visible: props.isEditable
            }, {
                type: 'separator'
            }];

            if (linkUrl && props.mediaType === 'image') {
                menuTpl = [{
                    type: 'separator'
                }, {
                    label: 'Copy Link',
                    click() {
                        electron.clipboard.writeText(linkUrl);
                    }
                }, {
                    type: 'separator'
                }, {
                    label: 'Save Image',
                    click(item, win) {
                        const fileUrl  = linkUrl;
                        const name     = decodeURI(ExtractFileName(fileUrl));

                        if (download){
                            download(fileUrl);
                        }
                    }
                }, {
                    type: 'separator'
                }];
            }

            if (linkUrl && !!props.linkURL && props.mediaType === 'none') {
                menuTpl = [{
                    type: 'separator'
                }, {
                    label: 'Copy Link',
                    click() {
                        electron.clipboard.writeText(linkUrl);
                    }
                }, {
                    type: 'separator'
                }];
            }

            if (props.misspelledWord && addList){
                menuTpl.unshift(...addList.prepend);
            } else
            if (!props.misspelledWord && addList && addList.prepend && menuTpl.length > addList.prepend.length){
                menuTpl = menuTpl.slice(0, addList.prepend.length) ;
            }

            // filter out leading/trailing separators
            // TODO: https://github.com/electron/electron/issues/5869
            menuTpl = delUnusedElements(menuTpl);

            if (menuTpl.length > 0) {
                const menu = (electron.Menu || electron.remote.Menu).buildFromTemplate(menuTpl);

                /*
                 * When electron.remote is not available this runs in the browser process.
                 * We can safely use win in this case as it refers to the window the
                 * context-menu should open in.
                 * When this is being called from a webView, we can't use win as this
                 * would refere to the webView which is not allowed to render a popup menu.
                 */
                
                try {
                    menu.popup(electron.remote ? electron.remote.getCurrentWindow() : win);
                } catch (e) {
                    console.error(e.message);
                }

            }
        } else {
	        console.warn("ContextMenu: props is empty! (" + props + ")");
        }
	});
}

function delUnusedElements(menuTpl) {
	let notDeletedPrevEl;

	return menuTpl.filter(el => el.visible !== false).filter((el, i, arr) => {
		const toDelete = el.type === 'separator' && (!notDeletedPrevEl || i === arr.length - 1 || arr[i + 1].type === 'separator');

		notDeletedPrevEl = toDelete ? notDeletedPrevEl : el;

		return !toDelete;
	});
}

function spellcheckMenu(list) {
    addList = list;
}

module.exports = {
    init: (opts = {}) => {
        if (opts.download) {
            download = opts.download;
        }

        if (opts.window) {
            const win = opts.window;
            const webContents = win.webContents || win.getWebContents();

            mainWin = win;

            // When window is a webview that has not yet finished loading webContents is not available
            if (webContents === undefined) {
                win.addEventListener('dom-ready', () => {
                    create(win, opts);
                }, {once: true});
            } else {
                create(win, opts);
            }
        } else {
            (electron.BrowserWindow || electron.remote.BrowserWindow).getAllWindows().forEach(win => {
                create(win, opts);
            });

            (electron.app || electron.remote.app).on('browser-window-created', (e, win) => {
                create(win, opts);
            });
        }
    },

    spellcheckMenu
};
